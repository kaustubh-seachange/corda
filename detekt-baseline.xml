<?xml version="1.0" ?>
<SmellBaseline>
  <Blacklist></Blacklist>
  <Whitelist>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$FINALISING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$GENERATING_TX : Step</ID>
    <ID>ClassNaming:AbstractCashFlow.kt$AbstractCashFlow.Companion$SIGNING_TX : Step</ID>
    <ID>ClassNaming:BuyerFlow.kt$BuyerFlow$STARTING_BUY : Step</ID>
    <ID>ClassNaming:CompositeMemberCompositeSchemaToClassCarpenterTests.kt$I_</ID>
    <ID>ClassNaming:CordaServiceTest.kt$CordaServiceTest.DummyServiceFlow.Companion$TEST_STEP : Step</ID>
    <ID>ClassNaming:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer.Companion$AWAITING_REQUEST : Step</ID>
    <ID>ClassNaming:CustomVaultQuery.kt$TopupIssuerFlow.TopupIssuer.Companion$SENDING_TOP_UP_ISSUE_REQUEST : Step</ID>
    <ID>ClassNaming:DeserializeNeedingCarpentryTests.kt$DeserializeNeedingCarpentryTests$outer</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCheckpointCordapp.kt$SendMessageFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$EXTRACTING_VAULT_STATES : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$ID_OTHER_NODES : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$OTHER_TX_COMPONENTS : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$SENDING_AND_RECEIVING_DATA : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$SIGS_GATHERING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_BUILDING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_SIGNING : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$TX_VERIFICATION : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$InitiatorFlow.Companion$VERIFYING_SIGS : Step</ID>
    <ID>ClassNaming:FlowCookbook.kt$ResponderFlow.Companion$RECEIVING_AND_SENDING_DATA : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$ExceptionFlow$START_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$InitiatedReceiveFlow$RECEIVED_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$InitiatedReceiveFlow$START_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$ReceiveFlow$RECEIVED_STEP : Step</ID>
    <ID>ClassNaming:FlowFrameworkTests.kt$ReceiveFlow$START_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$AsyncRetryFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$InitiatedFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$InitiatorFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$RetryFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:FlowRetryTest.kt$ThrowingFlow.Companion$FIRST_STEP : Step</ID>
    <ID>ClassNaming:GenericsTests.kt$GenericsTests$cl : ClassLoader</ID>
    <ID>ClassNaming:GenericsTests.kt$GenericsTests$implementsGenericInterfaceI&lt;out T&gt;</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Receive.Companion$RECEIVING_CERTIFICATES : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Receive.Companion$RECEIVING_IDENTITIES : Step</ID>
    <ID>ClassNaming:IdentitySyncFlow.kt$IdentitySyncFlow.Send.Companion$SYNCING_IDENTITIES : Step</ID>
    <ID>ClassNaming:NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.kt$NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:NodeStatePersistenceTests.kt$SendMessageFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.ContinueMessageChainFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.SplitMessagesFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$FINALISING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$GENERATING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$SIGNING_TRANSACTION : Step</ID>
    <ID>ClassNaming:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow.Companion$VERIFYING_TRANSACTION : Step</ID>
    <ID>ClassNaming:SellerFlow.kt$SellerFlow.Companion$SELF_ISSUING : Step</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testBoolean</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testDouble</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testFloat</ID>
    <ID>ClassNaming:SerializationOutputTests.kt$SerializationOutputTests$testShort</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$AWAITING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$GENERATING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$SIGNING_IDENTITY : Step</ID>
    <ID>ClassNaming:SwapIdentitiesFlow.kt$SwapIdentitiesFlow.Companion$VERIFYING_IDENTITY : Step</ID>
    <ID>ClassNaming:TestCommsFlow.kt$TestCommsFlowInitiator$RECIEVED_ALL : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$GENERATING_ID : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Primary.Companion$SENDING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary.Companion$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$COLLECTING_SIGNATURES : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$AWAITING_PROPOSAL : Step</ID>
    <ID>ClassNaming:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.Companion$VERIFYING_AND_SIGNING : Step</ID>
    <ID>ComplexCondition:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$c.isWhitespace() || c.isJavaIdentifierPart() || c.isJavaIdentifierStart() || c == '.' || c == ',' || c == '?' || c == '*'</ID>
    <ID>ComplexCondition:Address.kt$Address.Companion$parts.size != 2 || parts[0].isBlank() || parts[1].isBlank() || parts[1].toIntOrNull() == null</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$!that.javaClass.name.endsWith("ObjectField") || arrayValue != null || that.field.type == java.lang.String::class.java || value == null</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$(checkpointId != null) || ((clazz.name == instrumentClassname) &amp;&amp; (input.total() &gt;= minimumSize) &amp;&amp; (input.total() &lt;= maximumSize))</ID>
    <ID>ComplexCondition:CheckpointAgent.kt$CheckpointHook$(checkpointId != null) || ((obj.javaClass.name == instrumentClassname) &amp;&amp; (output.total() &gt;= minimumSize) &amp;&amp; (output.total() &lt;= maximumSize))</ID>
    <ID>ComplexCondition:ConfigUtilities.kt$value is Temporal || value is NetworkHostAndPort || value is CordaX500Name || value is Path || value is URL || value is UUID || value is X500Principal</ID>
    <ID>ComplexCondition:CordaClassResolver.kt$CordaClassResolver$type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))</ID>
    <ID>ComplexCondition:DeserializationInput.kt$DeserializationInput$type != TypeIdentifier.UnknownType.getLocalType() &amp;&amp; serializer.type != type &amp;&amp; with(serializer.type) { !isSubClassOf(type) &amp;&amp; !materiallyEquivalentTo(type) }</ID>
    <ID>ComplexCondition:FlowMessaging.kt$FlowMessagingImpl$(exception is KryoException || exception is NotSerializableException) &amp;&amp; message is ExistingSessionMessage &amp;&amp; message.payload is ErrorSessionMessage</ID>
    <ID>ComplexCondition:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$it != null &amp;&amp; (it is FlowLogic&lt;*&gt; || it is FlowStateMachine&lt;*&gt; || it is Fiber&lt;*&gt; || it is SerializeAsToken)</ID>
    <ID>ComplexCondition:InternalUtils.kt$it.type == this &amp;&amp; it.isPublic &amp;&amp; it.isStatic &amp;&amp; it.isFinal</ID>
    <ID>ComplexCondition:Main.kt$Main$(hostname != null) &amp;&amp; (port != null) &amp;&amp; (username != null) &amp;&amp; (password != null)</ID>
    <ID>ComplexCondition:Schema.kt$obj == null || obj is DescribedType || obj is Binary || forGenericType(type).run { isPrimitive(this) || this == TopType }</ID>
    <ID>ComplexCondition:TopLevelTransition.kt$TopLevelTransition$currentState.isTransactionTracked &amp;&amp; checkpoint.flowState is FlowState.Started &amp;&amp; checkpoint.flowState.flowIORequest is FlowIORequest.WaitForLedgerCommit &amp;&amp; checkpoint.flowState.flowIORequest.hash == event.transaction.id</ID>
    <ID>ComplexCondition:WireTransaction.kt$WireTransaction$notary != null &amp;&amp; (inputs.isNotEmpty() || references.isNotEmpty() || timeWindow != null)</ID>
    <ID>ComplexMethod:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>ComplexMethod:AMQPBridgeTest.kt$AMQPBridgeTest$@Test fun `test acked and nacked messages`()</ID>
    <ID>ComplexMethod:AMQPChannelHandler.kt$AMQPChannelHandler$override fun userEventTriggered(ctx: ChannelHandlerContext, evt: Any)</ID>
    <ID>ComplexMethod:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>ComplexMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>ComplexMethod:ANSIProgressRenderer.kt$ANSIProgressRenderer$@Synchronized protected fun draw(moveUp: Boolean, error: Throwable? = null)</ID>
    <ID>ComplexMethod:AbstractConcatenatedList.kt$AbstractConcatenatedList$// This is where we create a listener for a *nested* list. Note that 'indexMap' doesn't need to be adjusted on any // of these changes as the indices of nested lists don't change, just their contents. private fun createListener(wrapped: WrappedObservableList&lt;A&gt;): ListChangeListener&lt;A&gt;</ID>
    <ID>ComplexMethod:AbstractConcatenatedList.kt$AbstractConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>ComplexMethod:AbstractFlattenedList.kt$AbstractFlattenedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out ObservableValue&lt;out A&gt;&gt;)</ID>
    <ID>ComplexMethod:AbstractMappedList.kt$AbstractMappedList$override fun sourceChanged(change: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>ComplexMethod:AbstractReplayedList.kt$AbstractReplayedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out A&gt;)</ID>
    <ID>ComplexMethod:ActionExecutorImpl.kt$ActionExecutorImpl$@Suspendable override fun executeAction(fiber: FlowFiber, action: Action)</ID>
    <ID>ComplexMethod:AggregatedListTest.kt$AggregatedListTest$@Test fun removeWorks()</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ fun apply(balances: List&lt;SourceAndAmount&lt;T, P&gt;&gt;, newRef: Any? = null): List&lt;SourceAndAmount&lt;T, P&gt;&gt;</ID>
    <ID>ComplexMethod:Amount.kt$AmountTransfer$ override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$private fun set(key: K, value: V, logWarning: Boolean, store: (K, V) -&gt; V?): Boolean</ID>
    <ID>ComplexMethod:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$private fun doActivity()</ID>
    <ID>ComplexMethod:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>ComplexMethod:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>ComplexMethod:BridgeControlListener.kt$BridgeControlListener$private fun processControlMessage(msg: ClientMessage)</ID>
    <ID>ComplexMethod:CashSelectionH2Impl.kt$CashSelectionH2Impl$// We are using an H2 specific means of selecting a minimum set of rows that match a request amount of coins: // 1) There is no standard SQL mechanism of calculating a cumulative total on a field and restricting row selection on the // running total of such an accumulator // 2) H2 uses session variables to perform this accumulator function: // http://www.h2database.com/html/functions.html#set // 3) H2 does not support JOIN's in FOR UPDATE (hence we are forced to execute 2 queries) override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$// This is using PostgreSQL window functions for selecting a minimum set of rows that match a request amount of coins: // 1) This may also be possible with user-defined functions (e.g. using PL/pgSQL) // 2) The window function accumulated column (`total`) does not include the current row (starts from 0) and cannot // appear in the WHERE clause, hence restricting row selection and adjusting the returned total in the outer query. // 3) Currently (version 9.6), FOR UPDATE cannot be specified with window functions override fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun &lt;T&gt; getArrayValue(clazz: Class&lt;T&gt;, value: Any?): String?</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$CheckpointHook$private fun prettyStatsTree(indent: Int, statsInfo: StatsInfo, identityInfo: IdentityInfo, builder: StringBuilder)</ID>
    <ID>ComplexMethod:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>ComplexMethod:CheckpointDumper.kt$CheckpointDumper$fun dump()</ID>
    <ID>ComplexMethod:CheckpointDumper.kt$CheckpointDumper$private fun FlowIORequest&lt;*&gt;.toSuspendedOn(suspendedTimestamp: Instant, now: Instant): SuspendedOn</ID>
    <ID>ComplexMethod:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>ComplexMethod:CompatibleTransactionTests.kt$CompatibleTransactionTests$@Test fun `Command visibility tests`()</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$// For Iterables figure out the type parameter and apply the same logic as above on the individual elements. private fun Iterable&lt;*&gt;.toConfigIterable(field: Field): Iterable&lt;Any?&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: CryptoService? = null)</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$@Suppress("PLATFORM_CLASS_MAPPED_TO_KOTLIN") // Reflect over the fields of the receiver and generate a value Map that can use to create Config object. private fun Any.toConfigMap(): Map&lt;String, Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getCollectionValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Collection&lt;Any&gt;</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun Config.getSingleValue(path: String, type: KType, onUnknownKeys: (Set&lt;String&gt;, logger: Logger) -&gt; Unit, nestedPath: String?, baseDirectory: Path?): Any?</ID>
    <ID>ComplexMethod:ConfigUtilities.kt$private fun convertValue(value: Any): Any</ID>
    <ID>ComplexMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>ComplexMethod:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>ComplexMethod:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>ComplexMethod:CordaCliWrapper.kt$fun CordaCliWrapper.start(args: Array&lt;String&gt;)</ID>
    <ID>ComplexMethod:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>ComplexMethod:CordaRPCClient.kt$CordaRPCClientConfiguration$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:CordaRPCClientTest.kt$CordaRPCClientTest$@Test fun `shutdown command stops the node`()</ID>
    <ID>ComplexMethod:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private fun doFindCustomSerializer(clazz: Class&lt;*&gt;, declaredType: Type): AMQPSerializer&lt;Any&gt;?</ID>
    <ID>ComplexMethod:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>ComplexMethod:DriverDSLImpl.kt$DriverDSLImpl$override fun start()</ID>
    <ID>ComplexMethod:Expect.kt$ fun &lt;S, E : Any&gt; S.genericExpectEvents( isStrict: Boolean = true, stream: S.((E) -&gt; Unit) -&gt; Unit, expectCompose: () -&gt; ExpectCompose&lt;E&gt; )</ID>
    <ID>ComplexMethod:FinalityFlow.kt$FinalityFlow$@Suspendable @Throws(NotaryException::class) override fun call(): SignedTransaction</ID>
    <ID>ComplexMethod:FlowMonitor.kt$FlowMonitor$private fun warningMessageForFlowWaitingOnIo(request: FlowIORequest&lt;*&gt;, flow: FlowStateMachineImpl&lt;*&gt;, suspensionDuration: Duration): String</ID>
    <ID>ComplexMethod:FlowStateMachineImpl.kt$FlowStateMachineImpl$ @Suspendable private fun processEventsUntilFlowIsResumed(isDbTransactionOpenOnEntry: Boolean, isDbTransactionOpenOnExit: Boolean): Any?</ID>
    <ID>ComplexMethod:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$private fun generateRpcSslCertificates(conf: NodeConfiguration)</ID>
    <ID>ComplexMethod:GenericsTests.kt$GenericsTests$@Test fun nestedSerializationInMultipleContextsDoesntColideGenericTypes()</ID>
    <ID>ComplexMethod:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$@Throws(CertificateRequestException::class) override fun retrieveCertificates(requestId: String): CertificateResponse</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$override fun parseCriteria(criteria: AttachmentQueryCriteria.AttachmentsQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: QueryCriteria.VaultQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun &lt;O, R&gt; parseAggregateFunction(root: Root&lt;O&gt;, expression: CriteriaExpression.AggregateFunctionExpression&lt;O, R&gt;): Expression&lt;out Any?&gt;?</ID>
    <ID>ComplexMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private fun parse(sorting: Sort)</ID>
    <ID>ComplexMethod:IRS.kt$InterestRateSwap.CommonLeg$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:IRS.kt$InterestRateSwap.FloatingLeg$override fun equals(other: Any?): Boolean</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$ private fun maybeAbbreviateGenericType(type: Type, extraRecognisedPackage: String): String</ID>
    <ID>ComplexMethod:InteractiveShell.kt$InteractiveShell$@JvmStatic fun runRPCFromString(input: List&lt;String&gt;, out: RenderPrintWriter, context: InvocationContext&lt;out Any&gt;, cordaRPCOps: CordaRPCOps, inputObjectMapper: ObjectMapper): Any?</ID>
    <ID>ComplexMethod:Kryo.kt$ImmutableClassSerializer$override fun read(kryo: Kryo, input: Input, type: Class&lt;T&gt;): T</ID>
    <ID>ComplexMethod:Kryo.kt$ImmutableClassSerializer$override fun write(kryo: Kryo, output: Output, obj: T)</ID>
    <ID>ComplexMethod:LoadTest.kt$LoadTest$fun run(nodes: Nodes, parameters: RunParameters, random: SplittableRandom)</ID>
    <ID>ComplexMethod:LocalTypeInformationBuilder.kt$ private fun constructorForDeserialization(type: Type): KFunction&lt;Any&gt;?</ID>
    <ID>ComplexMethod:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private fun buildForClass(type: Class&lt;*&gt;, typeIdentifier: TypeIdentifier, isOpaque: Boolean): LocalTypeInformation</ID>
    <ID>ComplexMethod:LoginView.kt$LoginView$tailrec fun login(): NodeMonitorModel?</ID>
    <ID>ComplexMethod:Main.kt$Node$fun dumpDag(f: File)</ID>
    <ID>ComplexMethod:MerkleTransaction.kt$FilteredTransaction.Companion$ private fun filterWithFun(wtx: WireTransaction, filtering: Predicate&lt;Any&gt;): List&lt;FilteredComponentGroup&gt;</ID>
    <ID>ComplexMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun bootstrap( directory: Path, cordappJars: List&lt;Path&gt;, copyCordapps: CopyCordapps, fromCordform: Boolean, networkParametersOverrides: NetworkParametersOverrides = NetworkParametersOverrides() )</ID>
    <ID>ComplexMethod:NetworkBootstrapper.kt$NetworkBootstrapper$private fun createNodeDirectoriesIfNeeded(directory: Path, fromCordform: Boolean): Boolean</ID>
    <ID>ComplexMethod:NetworkMapUpdater.kt$NetworkMapUpdater$fun updateNetworkMapCache(): Duration</ID>
    <ID>ComplexMethod:NetworkParametersReader.kt$NetworkParametersReader$fun read(): NetworkParametersAndSigned</ID>
    <ID>ComplexMethod:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>ComplexMethod:NewTransaction.kt$NewTransaction$fun show(window: Window)</ID>
    <ID>ComplexMethod:NewTransaction.kt$NewTransaction$private fun newTransactionDialog(window: Window)</ID>
    <ID>ComplexMethod:Node.kt$Node$override fun startMessagingService(rpcOps: RPCOps, nodeInfo: NodeInfo, myNotaryIdentity: PartyAndCertificate?, networkParameters: NetworkParameters)</ID>
    <ID>ComplexMethod:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected fun &lt;K, V&gt; configuredForNamed(caffeine: Caffeine&lt;K, V&gt;, name: String): Caffeine&lt;K, V&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$private fun makeUpdates(batch: Iterable&lt;CoreTransaction&gt;, statesToRecord: StatesToRecord, previouslySeen: Boolean): List&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>ComplexMethod:NodeVaultService.kt$NodeVaultService$private fun processAndNotify(updates: List&lt;Vault.Update&lt;ContractState&gt;&gt;)</ID>
    <ID>ComplexMethod:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>ComplexMethod:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$@JvmStatic fun premain(argumentsString: String?, instrumentation: Instrumentation)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$ private fun close(notify: Boolean = true)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$// This is the general function that transforms a client side RPC to internal Artemis messages. override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?): Any?</ID>
    <ID>ComplexMethod:RPCClientProxyHandler.kt$RPCClientProxyHandler$private fun attemptReconnect()</ID>
    <ID>ComplexMethod:RPCServer.kt$RPCServer$private fun clientArtemisMessageHandler(artemisMessage: ClientMessage)</ID>
    <ID>ComplexMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$ private fun doInvoke(method: Method, args: Array&lt;out Any&gt;?, maxNumberOfAttempts: Int): Any?</ID>
    <ID>ComplexMethod:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ private tailrec fun establishConnectionWithRetry( retryInterval: Duration = 1.seconds, roundRobinIndex: Int = 0, retries: Int = -1 ): CordaRPCConnection?</ID>
    <ID>ComplexMethod:RemoteTypeCarpenter.kt$SchemaBuildingRemoteTypeCarpenter$override fun carpent(typeInformation: RemoteTypeInformation): Type</ID>
    <ID>ComplexMethod:RpcReconnectTests.kt$RpcReconnectTests$ @Test fun `test that the RPC client is able to reconnect and proceed after node failure, restart, or connection reset`()</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>ComplexMethod:SchemaMigration.kt$SchemaMigration$private fun doRunMigration( run: Boolean, check: Boolean, existingCheckpoints: Boolean? = null )</ID>
    <ID>ComplexMethod:SendTransactionFlow.kt$DataVendingFlow$@Suspendable override fun call(): Void?</ID>
    <ID>ComplexMethod:ShellCmdLineOptions.kt$ShellCmdLineOptions$private fun toConfigFile(): Config</ID>
    <ID>ComplexMethod:ShellCmdLineOptions.kt$ShellConfigurationFile.ShellConfigFile$fun toShellConfiguration(): ShellConfiguration</ID>
    <ID>ComplexMethod:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ComplexMethod:StartedFlowTransition.kt$StartedFlowTransition$override fun transition(): TransitionResult</ID>
    <ID>ComplexMethod:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>ComplexMethod:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>ComplexMethod:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$@Test fun testClientServerTlsExchange()</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ComplexMethod:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>ComplexMethod:TransactionUtils.kt$ fun createComponentGroups(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?): List&lt;ComponentGroup&gt;</ID>
    <ID>ComplexMethod:TransitionExecutorImpl.kt$TransitionExecutorImpl$@Suppress("NestedBlockDepth", "ReturnCount") @Suspendable override fun executeTransition( fiber: FlowFiber, previousState: StateMachineState, event: Event, transition: TransitionResult, actionExecutor: ActionExecutor ): Pair&lt;FlowContinuation, StateMachineState&gt;</ID>
    <ID>ComplexMethod:TypeModellingFingerPrinter.kt$FingerPrintingState$// For a type we haven't seen before, determine the correct path depending on the type of type it is. private fun fingerprintNewType(type: LocalTypeInformation)</ID>
    <ID>ComplexMethod:UniversalContract.kt$UniversalContract$override fun verify(tx: LedgerTransaction)</ID>
    <ID>ComplexMethod:Util.kt$fun &lt;T&gt; debugCompare(perLeft: Perceivable&lt;T&gt;, perRight: Perceivable&lt;T&gt;)</ID>
    <ID>ComplexMethod:Util.kt$fun debugCompare(arrLeft: Arrangement, arrRight: Arrangement)</ID>
    <ID>ComplexMethod:WebServer.kt$fun main(args: Array&lt;String&gt;)</ID>
    <ID>EmptyCatchBlock:ClockUtilsTest.kt$ClockUtilsTest${ }</ID>
    <ID>EmptyCatchBlock:NodeTerminalView.kt$NodeTerminalView${}</ID>
    <ID>EmptyCatchBlock:ObservablesTests.kt$ObservablesTests${ }</ID>
    <ID>EmptyCatchBlock:PersistentUniquenessProvider.kt$PersistentUniquenessProvider${ }</ID>
    <ID>EmptyCatchBlock:RPCClientProxyHandler.kt$RPCClientProxyHandler${}</ID>
    <ID>EmptyCatchBlock:RPCStabilityTests.kt$RPCStabilityTests${}</ID>
    <ID>EmptyCatchBlock:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests${ }</ID>
    <ID>EmptyCatchBlock:TransactionCallbackTest.kt$TransactionCallbackTest${ }</ID>
    <ID>EmptyCatchBlock:WebServer.kt$WebServer${ }</ID>
    <ID>EmptyClassBlock:CordaRPCClient.kt$CordaRPCClient$Companion</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$AsyncRetryFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$RetryFlow$()</ID>
    <ID>EmptyDefaultConstructor:FlowRetryTest.kt$ThrowingFlow$()</ID>
    <ID>EmptyElseBlock:CordaCliWrapper.kt${ }</ID>
    <ID>EmptyIfBlock:ContentSignerBuilder.kt$ContentSignerBuilder.SignatureOutputStream$if (alreadySigned) throw IllegalStateException("Cannot write to already signed object")</ID>
    <ID>EmptyIfBlock:InMemoryIdentityService.kt$InMemoryIdentityService${ }</ID>
    <ID>EmptyKtFile:KryoHook.kt$.KryoHook.kt</ID>
    <ID>EmptyKtFile:ValidatingNotaryService.kt$.ValidatingNotaryService.kt</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$exception</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$exited</ID>
    <ID>EnumNaming:LoginView.kt$LoginView.LoginStatus$loggedIn</ID>
    <ID>EqualsWithHashCodeExist:IRSUtils.kt$FixedRate : Rate</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$DONE : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$STARTING : Step</ID>
    <ID>EqualsWithHashCodeExist:ProgressTracker.kt$ProgressTracker$UNSTARTED : Step</ID>
    <ID>EqualsWithHashCodeExist:Utils.kt$StateRefHere</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(0, maxFaultyReplicas(n)) }</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(1, maxFaultyReplicas(n)) }</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(2, maxFaultyReplicas(n)) }</ID>
    <ID>ForEachOnRange:BFTSmartConfigTests.kt$BFTSmartConfigTests$forEach { n -&gt; assertEquals(n, maxFaultyReplicas(n) + minCorrectReplicas(n)) }</ID>
    <ID>ForEachOnRange:HibernateConfigurationTest.kt$HibernateConfigurationTest$forEach { consumeCash(it.DOLLARS) }</ID>
    <ID>ForEachOnRange:VaultQueryTests.kt$VaultQueryTestsBase$forEach { val newAllStates = vaultService.queryBy&lt;DummyLinearContract.State&gt;(sorting = sorting, criteria = criteria).states assertThat(newAllStates.groupBy(StateAndRef&lt;*&gt;::ref)).hasSameSizeAs(allStates) assertThat(newAllStates).containsExactlyElementsOf(allStates) }</ID>
    <ID>ForEachOnRange:VaultQueryTests.kt$VaultQueryTestsBase$forEach { vaultFiller.fillWithSomeTestLinearStates(1, linearNumber = it.toLong(), linearString = it.toString()) }</ID>
    <ID>ForbiddenComment:AbstractAttachment.kt$AbstractAttachment$// TODO: read file size information from metadata instead of loading the data.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: future implementation to retrieve contract states from a Vault BLOB store</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: make parameters configurable when we get CorDapp configuration.</ID>
    <ID>ForbiddenComment:AbstractCashSelection.kt$AbstractCashSelection$// TODO: revisit the back off strategy for contended spending.</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode$// TODO: Use configuration to indicate composite key should be used instead of public key for the identity.</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode$// TODO: We need a good way of handling "nice to have" shutdown events, especially those that deal with the</ID>
    <ID>ForbiddenComment:AbstractNode.kt$AbstractNode.&lt;no name provided&gt;$// TODO: Exponential backoff? It should reach max interval of eventHorizon/2.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: This step should not be necessary, as signatures are re-checked in verifyRequiredSignatures.</ID>
    <ID>ForbiddenComment:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Acceptor$// TODO: use keys from the keyManagementService instead</ID>
    <ID>ForbiddenComment:AffinityExecutor.kt$AffinityExecutor$// TODO: Rename this to executeWithResult</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: AutoCloseable::class.java.name,</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.io.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.lang.reflect.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: add more from java.net.</ID>
    <ID>ForbiddenComment:AllButBlacklisted.kt$AllButBlacklisted$// TODO: blacklistedClasses += type.name // add it, so checking is faster next time we encounter this class.</ID>
    <ID>ForbiddenComment:Arrangement.kt$Obligation$// TODO: should be replaced with something that uses Corda assets and/or cash?</ID>
    <ID>ForbiddenComment:Arrangement.kt$Obligation$// TODO: should only be allowed to transfer non-negative amounts</ID>
    <ID>ForbiddenComment:Arrangement.kt$RollOut$// TODO: fixing offset</ID>
    <ID>ForbiddenComment:Arrangement.kt$RollOut$// TODO: think about payment offset (ie. settlement) - probably it doesn't belong on a distributed ledger</ID>
    <ID>ForbiddenComment:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.Companion$// TODO: we might want to make this value configurable.</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$// TODO: Implement a discovery engine that can trigger builds of new connections when another node registers? (later)</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$// TODO: Verify that nobody can connect to us and fiddle with our config over the socket due to the secman.</ID>
    <ID>ForbiddenComment:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Define and document the configuration of the bft-smart cluster.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Potentially update the bft-smart API for our use case or rebuild client and server from lower level building</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart$// TODO: Support cluster membership changes. This requires reading about reconfiguration of bft-smart clusters and</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: Hopefully we only need to wait for the client's initial connection to the cluster, and this method can be moved to some startup code.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: Investigate ConcurrentModificationException in this method.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: for now we treat all errors as equal, compare by error type as well</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: is it safe use the last message for sender/session/sequence info</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: only return an aggregate if the majority of signatures are replies</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Client$// TODO: return an error reported by the majority and not just the first one</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.CordaServiceReplica$// TODO: At the cluster level, join all Sender/Receiver threads.</ID>
    <ID>ForbiddenComment:BFTSmart.kt$BFTSmart.Replica$// TODO:</ID>
    <ID>ForbiddenComment:BFTSmartNotaryService.kt$BFTSmartNotaryService.ServiceFlow$// TODO: here we assume that all error will be the same, but there might be invalid onces from mailicious nodes</ID>
    <ID>ForbiddenComment:BankOfCordaClientApi.kt$BankOfCordaClientApi$// TODO: privileged security controls required</ID>
    <ID>ForbiddenComment:BankOfCordaClientApi.kt$BankOfCordaClientApi$// TODO: security controls required</ID>
    <ID>ForbiddenComment:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit</ID>
    <ID>ForbiddenComment:BusinessCalendar.kt$BusinessCalendar.Companion$// TODO: Fix addl period logic</ID>
    <ID>ForbiddenComment:BusinessCalendar.kt$BusinessCalendar.Companion$// TODO: The rest.</ID>
    <ID>ForbiddenComment:Cash.kt$Cash$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:CashPaymentFlow.kt$CashPaymentFlow$// TODO: Have some way of restricting this to states the caller controls</ID>
    <ID>ForbiddenComment:CashTests.kt$CashTests$// TODO: Optimise this so that we don't throw away and rebuild state that can be shared across tests.</ID>
    <ID>ForbiddenComment:CashViewer.kt$CashViewer$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:CashViewer.kt$CashViewer.StateRowGraphic$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:CertRole.kt$CertRole$// TODO: Link to the specification once it has a permanent URL</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Generate equals/hashCode.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Generics.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Sandbox the generated code when a security manager is in use.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: Support annotations.</ID>
    <ID>ForbiddenComment:ClassCarpenter.kt$ClassCarpenterImpl$// TODO: isFoo getter patterns for booleans (this is what Kotlin generates)</ID>
    <ID>ForbiddenComment:ClassWhitelists.kt$GlobalTransientClassWhiteList$// TODO: Need some concept of from which class loader</ID>
    <ID>ForbiddenComment:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$// TODO: Test that timeouts work</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow$// TODO: AbstractStateReplacementFlow needs updating to use this flow.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$CollectSignaturesFlow.Companion$// TODO: Make the progress tracker adapt to the number of counterparties to collect from.</ID>
    <ID>ForbiddenComment:CollectSignaturesFlow.kt$SignTransactionFlow$// TODO: We should have a faster way of verifying we own a single key</ID>
    <ID>ForbiddenComment:CollectionSerializer.kt$CollectionSerializer$// TODO: Can we verify the entries in the list?</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Consider how to handle the case of mistaken issuances, or other need to patch.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Generalise the notion of an owned instrument into a superclass/supercontract. Consider composition vs inheritance.</ID>
    <ID>ForbiddenComment:CommercialPaper.kt$CommercialPaper$// TODO: Think about how to evolve contracts over time with new commands.</ID>
    <ID>ForbiddenComment:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$// TODO: Consider moving these two steps below into generateIssue.</ID>
    <ID>ForbiddenComment:CommercialPaperTests.kt$// TODO: The generate functions aren't tested by these tests: add them.</ID>
    <ID>ForbiddenComment:CompatibilityTest.kt$CompatibilityTest$// TODO: If this type of testing gets momentum, we can create a mini-framework that rides through list of files</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey$// TODO: replace with the more extensive, but slower, checkValidity() test.</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.Companion$// TODO: node.encoded.sequence() might be expensive, consider a faster deterministic compareTo implementation</ID>
    <ID>ForbiddenComment:CompositeKey.kt$CompositeKey.NodeAndWeight$// TODO: this might be expensive, consider a faster deterministic compareTo implementation when weights are equal.</ID>
    <ID>ForbiddenComment:CompositeKeyTests.kt$CompositeKeyTests$// TODO: Look into a DSL for building multi-level composite keys if that becomes a common use case</ID>
    <ID>ForbiddenComment:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: check transaction size is within limits</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$// TODO: copy across encumbrances when performing contract upgrades</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: exclude encumbrance states from this check</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$// TODO: relax this constraint once upgrading encumbered states is supported.</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: if there are encumbrance states in the inputs, just copy them across without modifying</ID>
    <ID>ForbiddenComment:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$// TODO: re-map encumbrance pointers</ID>
    <ID>ForbiddenComment:CordaClassResolver.kt$CordaClassResolver$// TODO: Later we can support annotations on attachment classes and spin up a proxy via bytecode that we know is harmless.</ID>
    <ID>ForbiddenComment:CordaClassResolver.kt$CordaClassResolver$// TODO: come up with a more efficient way. e.g. segregate the name space by class loader.</ID>
    <ID>ForbiddenComment:CordaRPCClient.kt$CordaRPCClientConfiguration$// TODO: acquire this value from Network Map when supported.</ID>
    <ID>ForbiddenComment:Cordapp.kt$Cordapp.Info.ContractAndWorkflow$// TODO: future work in Gradle cordapp plugins to enforce separation of Contract and Workflow classes into separate jars</ID>
    <ID>ForbiddenComment:CordappImpl.kt$CordappImpl$// TODO: Also add [SchedulableFlow] as a Cordapp class</ID>
    <ID>ForbiddenComment:CordappProviderImpl.kt$CordappProviderImpl$// TODO: Use better supported APIs in Java 9</ID>
    <ID>ForbiddenComment:CordappProviderImplTests.kt$CordappProviderImplTests.Companion$// TODO: Cordapp name should differ from the JAR name</ID>
    <ID>ForbiddenComment:CoreFlowHandlers.kt$NotaryChangeHandler$// TODO: Right now all nodes will automatically approve the notary change. We need to figure out if stricter controls are necessary.</ID>
    <ID>ForbiddenComment:CrossCashTest.kt$CrossCashState$// TODO: Alternative: We may possibly reduce the complexity of the search even further using some form of</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: Check if non-ECC keys satisfy params (i.e. approved/valid RSA modulus size).</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: We currently use SHA256(seed) when retrying, but BIP32 just skips a counter (i) that results to an invalid key.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change the val name to a more descriptive one as it's now confusing and looks like a Key type.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: change val name to SPHINCS256_SHA512. This will break backwards compatibility.</ID>
    <ID>ForbiddenComment:Crypto.kt$Crypto$// TODO: perform all cryptographic operations via Crypto.</ID>
    <ID>ForbiddenComment:CryptoUtils.kt$// TODO: SignatureException should be used only for a damaged signature, as per `java.security.Signature.verify()`.</ID>
    <ID>ForbiddenComment:CustomSerializer.kt$CustomSerializer.SubClass$// TODO: should this be a custom serializer at all, or should it just be a plain AMQPSerializer?</ID>
    <ID>ForbiddenComment:CustomSerializer.kt$CustomSerializer.SubClass$// TODO: should this be empty or contain the schema of the super?</ID>
    <ID>ForbiddenComment:DbTransactionsResolver.kt$DbTransactionsResolver$// TODO: This approach has two problems. Analyze and resolve them:</ID>
    <ID>ForbiddenComment:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$// TODO: re-organise registrations into logical groups before v1.0</ID>
    <ID>ForbiddenComment:DigitalSignatureWithCert.kt$// TODO: Rename this to DigitalSignature.WithCert once we're happy for it to be public API. The methods will need documentation</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl$// TODO: Derive name from the full picked name, don't just wrap the common name</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl$//TODO: remove this once we can bundle quasar properly.</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl.Companion$// TODO: There is pending work to fix this issue without custom blacklisting. See: https://r3-cev.atlassian.net/browse/CORDA-2164.</ID>
    <ID>ForbiddenComment:DriverDSLImpl.kt$DriverDSLImpl.LocalNetworkMap$// TODO: this object will copy NodeInfo files from started nodes to other nodes additional-node-infos/</ID>
    <ID>ForbiddenComment:DummyFungibleContract.kt$DummyFungibleContract$// TODO: This doesn't work with the trader demo, so use the underlying key instead</ID>
    <ID>ForbiddenComment:E2ETestKeyManagementService.kt$E2ETestKeyManagementService$// TODO: A full KeyManagementService implementation needs to record activity to the Audit Service and to limit</ID>
    <ID>ForbiddenComment:EncodingUtils.kt$// TODO: follow the crypto-conditions ASN.1 spec, some changes are needed to be compatible with the condition</ID>
    <ID>ForbiddenComment:Envelope.kt$Envelope$// TODO: don't recognise a type descriptor.</ID>
    <ID>ForbiddenComment:Envelope.kt$Envelope$// TODO: make the schema parsing lazy since mostly schemas will have been seen before and we only need it if we</ID>
    <ID>ForbiddenComment:Explorer.kt$Explorer$// TODO: Remove this code when serialisation has been upgraded.</ID>
    <ID>ForbiddenComment:FetchDataFlow.kt$FetchDataFlow$// TODO: Support "large message" response streaming so response sizes are not limited by RAM.</ID>
    <ID>ForbiddenComment:FiberUtils.kt$// TODO: This method uses a built-in Quasar function to make a map of all ThreadLocals. This is probably inefficient, but the only API readily available.</ID>
    <ID>ForbiddenComment:FinanceTypes.kt$// TODO: Make Calendar data come from an oracle</ID>
    <ID>ForbiddenComment:FinanceTypes.kt$Frequency$// TODO: Revisit post-Vega and see if annualCompoundCount is still needed.</ID>
    <ID>ForbiddenComment:FixingFlow.kt$FixingFlow.Fixer$// TODO: this is in no way secure and will be replaced by general session initiation logic in the future</ID>
    <ID>ForbiddenComment:FlowIORequest.kt$FlowIORequest.ForceCheckpoint$// TODO: consider using an empty FlowAsyncOperation instead</ID>
    <ID>ForbiddenComment:FlowLogicRef.kt$FlowLogicRef$// TODO: align this with the existing [FlowRef] in the bank-side API (probably replace some of the API classes)</ID>
    <ID>ForbiddenComment:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$// TODO: Replace with a per app classloader/cordapp provider/cordapp loader - this will do for now</ID>
    <ID>ForbiddenComment:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$// TODO: This is used via RPC but it's probably better if we pass in argument names and values explicitly</ID>
    <ID>ForbiddenComment:GenerateRpcSslCertsCli.kt$GenerateRpcSslCerts$// TODO: consider adding a password strength policy.</ID>
    <ID>ForbiddenComment:GuiUtilities.kt$// TODO: This is a temporary fix for the UI to show the correct issuer identity, this will break when we start randomizing keys. More work is needed here when the identity work is done.</ID>
    <ID>ForbiddenComment:HibernateConfiguration.kt$HibernateConfiguration$// TODO: require mechanism to set schemaOptions (databaseSchema, tablePrefix) which are not global to session</ID>
    <ID>ForbiddenComment:IRS.kt$FloatingRatePaymentEvent$// TODO: Should an uncalculated amount return a zero ? null ? etc.</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap$// TODO: Confirm: would someone really enter a swap with a negative fixed rate?</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap$// TODO: further tests</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.Commands.Mature$// Trade has matured; no more actions. Cleanup. // TODO: Do we need this?</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.State$// TODO: Jexl is purely for prototyping. It may be replaced</ID>
    <ID>ForbiddenComment:IRS.kt$InterestRateSwap.State$// TODO: Whatever we do use must be secure and sandboxed</ID>
    <ID>ForbiddenComment:IRSTests.kt$// TODO: How I want it to look</ID>
    <ID>ForbiddenComment:IRSTests.kt$// TODO: this seems to fail quite dramatically</ID>
    <ID>ForbiddenComment:IRSUtils.kt$// TODO: For further discussion.</ID>
    <ID>ForbiddenComment:IRSUtils.kt$RatioUnit$// TODO: Discuss this type</ID>
    <ID>ForbiddenComment:IdempotentFlow.kt$TimedFlow$// TODO: allow specifying retry settings per flow</ID>
    <ID>ForbiddenComment:IdenticonRenderer.kt$IdenticonRenderer$// TODO: support transparency.</ID>
    <ID>ForbiddenComment:IdentityService.kt$IdentityService$// TODO: This should be done via the network map cache, which is the authoritative source of well known identities</ID>
    <ID>ForbiddenComment:IdentitySyncFlow.kt$IdentitySyncFlow.Send$// TODO: Can this be triggered automatically from [SendTransactionFlow]?</ID>
    <ID>ForbiddenComment:IdentitySyncFlow.kt$IdentitySyncFlow.Send$// TODO: Consider if this too restrictive - we perhaps should be checking the name on the signing certificate in the certificate path instead</ID>
    <ID>ForbiddenComment:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$// TODO: Generate certificate with an EdDSA key rather than ECDSA</ID>
    <ID>ForbiddenComment:InitialRegistrationCli.kt$InitialRegistration$// TODO: Move node identity generation logic from node to registration helper.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Add a command to view last N lines/tail/control log4j2 loggers.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Add command history.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Command completion.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Configure default renderers, send objects down the pipeline, add support for xml output format.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Do something sensible with commands that return a future.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Fix up the 'dashboard' command which has some rendering issues.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Get rid of the 'java' command, it's kind of worthless.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Make it notice new shell commands added after the node started.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Resurrect or reimplement the mail plugin.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$// TODO: Review or fix the JVM commands which have bitrotted and some are useless.</ID>
    <ID>ForbiddenComment:InteractiveShell.kt$InteractiveShell$// TODO: A default renderer could be used, instead of an object mapper. See: http://www.crashub.org/1.3/reference.html#_renderers</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Add inline back when a new Kotlin version is released and check if the java.lang.VerifyError</ID>
    <ID>ForbiddenComment:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future.</ID>
    <ID>ForbiddenComment:IrsDemoClientApi.kt$IRSDemoClientApi$// TODO: Add uploading of files to the HTTP API</ID>
    <ID>ForbiddenComment:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$// TODO: use programmatic API support to implement signing (see https://docs.oracle.com/javase/9/docs/api/jdk/security/jarsigner/JarSigner.html)</ID>
    <ID>ForbiddenComment:KeyStoreConfigHelpers.kt$// TODO: X509Utilities.validateCertificateChain()</ID>
    <ID>ForbiddenComment:Kryo.kt$PublicKeySerializer$// TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser.</ID>
    <ID>ForbiddenComment:LegalNameValidator.kt$LegalNameValidator.Rule.Companion$// TODO: Implement confusable character detection if we add more scripts.</ID>
    <ID>ForbiddenComment:LocalTypeInformationBuilder.kt$// TODO: Revisit this when Kotlin issue is fixed.</ID>
    <ID>ForbiddenComment:LoggingBuyerFlow.kt$LoggingBuyerFlow$// TODO: This is potentially very expensive, and requires transaction details we may no longer have once</ID>
    <ID>ForbiddenComment:MockServices.kt$MockServices.Companion$// TODO: Can we use an X509 principal generator here?</ID>
    <ID>ForbiddenComment:NetParams.kt$NetParamsSigner$// TODO: not supported</ID>
    <ID>ForbiddenComment:NetworkBootstrapper.kt$NetworkBootstrapper$// TODO: pass a commandline parameter to the bootstrapper instead. Better yet, a notary config map</ID>
    <ID>ForbiddenComment:NetworkMapCacheTest.kt$NetworkMapCacheTest$// TODO: Should have a test case with anonymous lookup</ID>
    <ID>ForbiddenComment:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$//TODO: Remove sleep in unit test.</ID>
    <ID>ForbiddenComment:Node.kt$Node.Companion$// TODO: make this configurable.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: PLT-147: The attachment should be randomised to prevent brute force guessing and thus privacy leaks.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: Switch to a two-phase insert so we can handle attachments larger than RAM.</ID>
    <ID>ForbiddenComment:NodeAttachmentService.kt$NodeAttachmentService$// TODO: this is racey. ENT-2870</ID>
    <ID>ForbiddenComment:NodeConfigurationImpl.kt$NodeConfigurationImpl$// TODO: There are two implications here:</ID>
    <ID>ForbiddenComment:NodeInfoConstants.kt$// TODO: Add to Corda node.conf to allow customisation</ID>
    <ID>ForbiddenComment:NodeInfoWatcher.kt$NodeInfoWatcher$// TODO: Use NIO watch service instead?</ID>
    <ID>ForbiddenComment:NodeInterestRates.kt$NodeInterestRates.FixContainer$// TODO: the calendar data needs to be specified for every fix type in the input string</ID>
    <ID>ForbiddenComment:NodeInterestRates.kt$NodeInterestRates.UnknownFix$// TODO: can we split into two? Fix not available (retryable/transient) and unknown (permanent)</ID>
    <ID>ForbiddenComment:NodeTerminalView.kt$NodeTerminalView$// TODO: Remove this special case once Rick's serialisation work means we can deserialise states that weren't on our own classpath.</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: Optimise this.</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: Perhaps these can be stored in a batch?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: This is a catch-all solution. But why is the default pageNumber set to be -1 in the first place?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: This is expensive - is there another way?</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: improve typing of returned other results</ID>
    <ID>ForbiddenComment:NodeVaultService.kt$NodeVaultService$// TODO: revisit (use single instance of parser for all queries)</ID>
    <ID>ForbiddenComment:NodeVaultServiceTest.kt$NodeVaultServiceTest$// TODO: Unit test linear state relevancy checks</ID>
    <ID>ForbiddenComment:NodeWebServer.kt$NodeWebServer$// TODO: Redesign</ID>
    <ID>ForbiddenComment:NotaryChangeFlow.kt$NotaryChangeFlow$// TODO: We need a much faster way of finding our key in the transaction</ID>
    <ID>ForbiddenComment:NotaryChangeTests.kt$NotaryChangeTests$// TODO: Add more test cases once we have a general flow/service exception handling mechanism:</ID>
    <ID>ForbiddenComment:NotaryChangeTests.kt$NotaryChangeTests$// TODO: Re-enable the test when parameter currentness checks are in place, ENT-2666.</ID>
    <ID>ForbiddenComment:NotaryError.kt$StateConsumptionDetails$// TODO: include notary timestamp?</ID>
    <ID>ForbiddenComment:NotaryFlow.kt$NotaryFlow.Client$// TODO: This is not required any more once our AMQP serialization supports turning off object referencing.</ID>
    <ID>ForbiddenComment:NotaryServiceFlow.kt$NotaryServiceFlow.Companion$// TODO: Determine an appropriate limit and also enforce in the network parameters and the transaction builder.</ID>
    <ID>ForbiddenComment:NotaryUtils.kt$// TODO: if requestSignature was generated over an old version of NotarisationRequest, we need to be able to</ID>
    <ID>ForbiddenComment:OGUtils.kt$// TODO: Do this correctly</ID>
    <ID>ForbiddenComment:Obligation.kt$Obligation$// TODO: Handle proxies nominated by parties, i.e. a central clearing service</ID>
    <ID>ForbiddenComment:ObligationUtils.kt$ObligationUtils$// TODO: A much better (but more complex) solution would be to have two iterators, one for obligations,</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: Check that re-running this on the same transaction multiple times does the right thing.</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions exiting inputs from</ID>
    <ID>ForbiddenComment:OnLedgerAsset.kt$OnLedgerAsset.Companion$// TODO: We should be prepared to produce multiple transactions spending inputs from</ID>
    <ID>ForbiddenComment:OracleUtils.kt$// TODO: we would ordinarily convert clock to same time zone as the index/source would announce in</ID>
    <ID>ForbiddenComment:ParametersUtilities.kt$// TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer</ID>
    <ID>ForbiddenComment:Perceivable.kt$// TODO: fix should have implied default date and perhaps tenor when used in a rollOut template</ID>
    <ID>ForbiddenComment:Perceivable.kt$Interest$// todo: holidays</ID>
    <ID>ForbiddenComment:PersistentStateService.kt$PersistentStateService$// TODO: Manage version evolution of the schemas via additional tooling.</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$//TODO: Change import namespaces vega -&gt; ....</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$PortfolioApi$// TODO: Stop using localdate.now</ID>
    <ID>ForbiddenComment:PortfolioApi.kt$PortfolioApi$// TODO: enhancement to Vault Query to check for any participant in participants attribute</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: Expose the concept of errors.</ID>
    <ID>ForbiddenComment:ProgressTracker.kt$// TODO: It'd be helpful if this class was at least partly thread safe.</ID>
    <ID>ForbiddenComment:ProviderMap.kt$// TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider.</ID>
    <ID>ForbiddenComment:PublicKeySerializer.kt$PublicKeySerializer$// TODO: Instead of encoding to the default X509 format, we could have a custom per key type (space-efficient) serialiser.</ID>
    <ID>ForbiddenComment:RPCStabilityTests.kt$RPCStabilityTests$// TODO: This is ignored because Artemis slow consumers are broken. I'm not deleting it in case we can get the feature fixed.</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$// TODO: read &amp; put entries in batches</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Commands.CommitTransaction$// TODO: Cluster membership changes need testing.</ID>
    <ID>ForbiddenComment:RaftTransactionCommitLog.kt$RaftTransactionCommitLog.Commands.CommitTransaction$// TODO: I'm wondering if we should support resizing notary clusters, or if we could require users to</ID>
    <ID>ForbiddenComment:RaftUniquenessProvider.kt$RaftUniquenessProvider$// TODO: use local transport for client-server communications</ID>
    <ID>ForbiddenComment:RatesFixFlow.kt$RatesFixFlow$// TODO: Kick to a user confirmation / ui flow if it's out of bounds instead of raising an exception.</ID>
    <ID>ForbiddenComment:RatesFixFlow.kt$RatesFixFlow.FixQueryFlow$// TODO: add deadline to receive</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$// TODO: This could be done in parallel with other fetches for extra speed.</ID>
    <ID>ForbiddenComment:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$// TODO: this operation should not require an explicit transaction</ID>
    <ID>ForbiddenComment:RestrictedEntityManager.kt$RestrictedEntityManager$// TODO: Figure out which other methods on EntityManager need to be blocked?</ID>
    <ID>ForbiddenComment:ScheduledActivityObserver.kt$ScheduledActivityObserver.Companion$// TODO: Beware we are calling dynamically loaded contract code inside here.</ID>
    <ID>ForbiddenComment:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$// TODO: the queries below are not atomic so we need to allow enough time for the scheduler to finish. Would be better to query scheduler.</ID>
    <ID>ForbiddenComment:SendTransactionFlow.kt$DataVendingFlow$// Security TODO: Check for abnormally large or malformed data requests</ID>
    <ID>ForbiddenComment:SerializationHelper.kt$// TODO: surely we check it is concrete at this point with no TypeVariables</ID>
    <ID>ForbiddenComment:SerializationOutputTests.kt$SerializationOutputTests$// TODO: Generic interfaces / superclasses</ID>
    <ID>ForbiddenComment:SerializationOutputTests.kt$SerializationOutputTests$// TODO: add some schema assertions to check correctly formed.</ID>
    <ID>ForbiddenComment:SerializationScheme.kt$SerializationFactoryImpl$// TODO: This is read-mostly. Probably a faster implementation to be found.</ID>
    <ID>ForbiddenComment:ServiceHub.kt$ServicesForResolution$// TODO: future implementation to use a Vault state ref -&gt; contract state BLOB table and perform single query bulk load</ID>
    <ID>ForbiddenComment:ServiceHubCoreInternal.kt$ServiceHubCoreInternal$// TODO: This should really be called ServiceHubInternal but that name is already taken by net.corda.node.services.api.ServiceHubInternal.</ID>
    <ID>ForbiddenComment:ServiceHubInternal.kt$WritableTransactionStorage$// TODO: Throw an exception if trying to add a transaction with fewer signatures than an existing entry.</ID>
    <ID>ForbiddenComment:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// TODO: check only one (or until one is resolved successfully), max recursive invocations check?</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We could probably optimise the below by</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: We need a much better way of structuring this data.</ID>
    <ID>ForbiddenComment:SignedTransaction.kt$SignedTransaction$// TODO: allow non-blocking verification.</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Receiver$// TODO: The attachments need to be added somewhere</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Receiver$// TODO: handle failures</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: In the real world, this would be tolerance aware for different types</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: The attachments need to be added somewhere</ID>
    <ID>ForbiddenComment:SimmFlow.kt$SimmFlow.Requester$// TODO: handle failures</ID>
    <ID>ForbiddenComment:SinglePartyNotaryService.kt$SinglePartyNotaryService$// TODO: Log the request here. Benchmarking shows that logging is expensive and we might get better performance</ID>
    <ID>ForbiddenComment:StateMachineManagerUtils.kt$//TODO: instead of replacing the progress tracker after constructing the flow logic, we should inject it during fiber deserialization</ID>
    <ID>ForbiddenComment:Structures.kt$MoveCommand$// TODO: Replace Class here with a general contract constraints object</ID>
    <ID>ForbiddenComment:SwapData.kt$SwapData$// TODO: Fix below to be correct - change tenor and reference data</ID>
    <ID>ForbiddenComment:SwapDataView.kt$// TODO: Should be able to display an array ?</ID>
    <ID>ForbiddenComment:ThrowableSerializer.kt$ThrowableSerializer$// TODO: This will need reworking when we have multiple class loaders</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$// TODO: Add support for making recursive resolution optional if it becomes an issue.</ID>
    <ID>ForbiddenComment:TransactionBuilder.kt$TransactionBuilder$//TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$// TODO: Implement the contract sandbox loading of the contract attachments</ID>
    <ID>ForbiddenComment:TransactionState.kt$TransactionState$//TODO: add link to docsite page, when there is one.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: [ENT-2666] Implement network parameters fuzzy checking. By design in Corda network we have propagation time delay.</ID>
    <ID>ForbiddenComment:TransactionUtils.kt$// TODO: we could avoid deserialising unrelated signers.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException$// TODO: Make this descend from TransactionVerificationException so that untrusted attachments cause flows to be hospitalized.</ID>
    <ID>ForbiddenComment:TransactionVerificationException.kt$TransactionVerificationException.TransactionRequiredContractUnspecifiedException$// TODO: add reference to documentation</ID>
    <ID>ForbiddenComment:TransactionViewer.kt$TransactionViewer.ContractStatesView$// TODO: Anonymous should probably be italicised or similar</ID>
    <ID>ForbiddenComment:TransformTypes.kt$TransformTypes$// TODO: annotated with some annotation</ID>
    <ID>ForbiddenComment:TransformTypes.kt$TransformTypes$// TODO: it would be awesome to auto build this list by scanning for transform annotations themselves</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Also, the term Deal is used here where we might prefer Agreement.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: Make this flow more generic.</ID>
    <ID>ForbiddenComment:TwoPartyDealFlow.kt$TwoPartyDealFlow$// TODO: The subclasses should probably be broken out into individual flows rather than making this an ever expanding collection of subclasses.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow$// TODO: Common elements in multi-party transaction consensus and signing should be refactored into a superclass of this</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer.RECORDING$// TODO: Currently triggers a race condition on Team City. See https://github.com/corda/corda/issues/733.</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// FIXME: Knowledge of confidential identities is lost on node shutdown, so Bob's node now refuses to sign the</ID>
    <ID>ForbiddenComment:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$// TODO: Verify that the result was inserted into the transaction database.</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: calendar + rolling conventions</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: look into schedule for final dates</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: not sure this is necessary??</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: think about multi layered rollouts</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract$// TODO: we may have to save original start date in order to roll out correctly</ID>
    <ID>ForbiddenComment:UniversalContract.kt$UniversalContract.Commands.Split$// todo: Who should sign this?</ID>
    <ID>ForbiddenComment:VaultFiller.kt$VaultFiller$// TODO: need to make all FungibleAsset commands (issue, move, exit) generic</ID>
    <ID>ForbiddenComment:VaultSchema.kt$VaultSchemaV1.VaultStates$// TODO: create a distinct table to hold serialized state data (once DBTransactionStore is encrypted)</ID>
    <ID>ForbiddenComment:VaultWithCashTest.kt$// TODO: Move this to the cash contract tests once mock services are further split up.</ID>
    <ID>ForbiddenComment:WebServerConfig.kt$WebServerConfig$// TODO: remove this once config format is updated</ID>
    <ID>ForbiddenComment:WebServerConfig.kt$WebServerConfig$// TODO: replace with credentials supplied by a user</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: prevent notary field from being set if there are no inputs and no time-window.</ID>
    <ID>ForbiddenComment:WireTransaction.kt$WireTransaction$// TODO: revisit once Deterministic JVM code updated</ID>
    <ID>ForbiddenComment:X509Utilities.kt$CertificateType.LEGAL_IDENTITY$// TODO: Identity certs should have tight name constraints on child certificates</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_client_certificate_untrusted_to_server()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_no_ssl_on_client_side_and_ssl_on_server_side()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_ssl_disabled()</ID>
    <ID>FunctionNaming:ArtemisRpcTests.kt$ArtemisRpcTests$@Test fun rpc_with_ssl_enabled()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Boolean()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun CordaX500Name()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Double()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Enum()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Instant()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Int()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun LocalDate()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Long()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun NetworkHostAndPort()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Path()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun Set()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun String()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun URL()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun UUID()</ID>
    <ID>FunctionNaming:ConfigParsingTest.kt$ConfigParsingTest$@Test fun X500Principal()</ID>
    <ID>FunctionNaming:ContractFunctions.kt$// building an fx swap using abstract swap fun fx_swap2(expiry: String, notional: Long, strike: Double, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>FunctionNaming:ContractFunctions.kt$fun fx_swap(expiry: String, notional: BigDecimal, strike: BigDecimal, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Double, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Int, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun &lt;T : Any&gt; AMOUNT(amount: Long, token: T): Amount&lt;T&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun DOLLARS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun POUNDS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Double): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Int): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:Currencies.kt$fun SWISS_FRANCS(amount: Long): Amount&lt;Currency&gt;</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun AnonymousParty()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun ByteSequence()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun CertPath()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun Command()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun CompositeKey()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun CordaX500Name()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun DigitalSignature()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun DigitalSignatureWithCert()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun Instant()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun NetworkHostAndPort()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun PrivacySalt()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun PublicKey()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun SerializedBytes()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun SignatureMetadata()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun TransactionSignature()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun TransactionState()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun UUID()</ID>
    <ID>FunctionNaming:JacksonSupportTest.kt$JacksonSupportTest$@Test fun X500Principal()</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _transaction(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: T.() -&gt; EnforceVerifyOrFail): WireTransaction</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _tweak(dsl: LedgerDSLInterpreter&lt;T&gt;.() -&gt; Unit)</ID>
    <ID>FunctionNaming:LedgerDSLInterpreter.kt$LedgerDSLInterpreter$ fun _unverifiedTransaction(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: T.() -&gt; Unit): WireTransaction</ID>
    <ID>FunctionNaming:NamedCacheTest.kt$NamedCacheTest$@Test fun TestCheckCacheName()</ID>
    <ID>FunctionNaming:NodeHandleTests.kt$NodeHandleTests$@Test fun object_defined_functions_are_static_for_node_rpc_ops()</ID>
    <ID>FunctionNaming:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:PasswordTest.kt$PasswordTest$@Test fun constructor_and_getters()</ID>
    <ID>FunctionNaming:PasswordTest.kt$PasswordTest$@Test fun toString_is_masked()</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allSteps(level: Int = 0): List&lt;Pair&lt;Int, Step&gt;&gt;</ID>
    <ID>FunctionNaming:ProgressTracker.kt$ProgressTracker$private fun _allStepsLabels(level: Int = 0): List&lt;Pair&lt;Int, String&gt;&gt;</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun absent_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun absent_value_of_list_type_with_single_element_and_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun absent_value_of_list_type_with_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_value_of_list_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_value_of_list_type_with_default_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_absent_with_default_value()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_present_value_of_list_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_present_value_with_correct_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun optional_present_value_with_wrong_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_of_list_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_of_list_type_with_single_element_and_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_of_list_type_with_whole_list_mapping()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_with_correct_type()</ID>
    <ID>FunctionNaming:PropertyTest.kt$PropertyTest$@Test fun present_value_with_wrong_type()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun absent_list_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun absent_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun absent_value_in_nested_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun integer_numeric_type_when_floating_expected_works()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun invalid_mapped_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun list_type_when_declared_single()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun missing_list_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun missing_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun missing_value_in_nested_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun nested_property_without_schema_does_not_validate()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun single_type_when_declared_list()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun valid_mapped_property()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun whole_list_validation_invalid_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun whole_list_validation_valid_value()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_element_type_for_list()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_floating_numeric_type_when_integer_expected()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_type()</ID>
    <ID>FunctionNaming:PropertyValidationTest.kt$PropertyValidationTest$@Test fun wrong_type_in_nested_property()</ID>
    <ID>FunctionNaming:ReceiveAllFlowTests.kt$ReceiveMultipleFlowTests$@Test fun showcase_flows_as_closures()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_does_not_show_sensitive_values()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun describe_with_nested_properties_list_does_not_show_sensitive_values()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_nested_properties()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_unknown_properties()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_unknown_properties_non_strict()</ID>
    <ID>FunctionNaming:SchemaTest.kt$SchemaTest$@Test fun validation_with_wrong_nested_properties()</ID>
    <ID>FunctionNaming:SerializationOutput.kt$SerializationOutput$internal fun &lt;T : Any&gt; _serialize(obj: T, context: SerializationContext): SerializedBytes&lt;T&gt;</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun chained_delegated_properties_are_not_added_multiple_times()</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun parse_list_aggregation()</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun validate_list_aggregation()</ID>
    <ID>FunctionNaming:SpecificationTest.kt$SpecificationTest$@Test fun validate_with_domain_specific_errors()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun args_to_config()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_override_config_from_file()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun cmd_options_to_config_from_file()</ID>
    <ID>FunctionNaming:StandaloneShellArgsParserTest.kt$StandaloneShellArgsParserTest$@Test fun empty_args_to_cmd_options()</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String,String&gt;)</ID>
    <ID>FunctionNaming:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _tweak(dsl: TransactionDSLInterpreter.() -&gt; EnforceVerifyOrFail): EnforceVerifyOrFail</ID>
    <ID>FunctionNaming:UtilsTest.kt$UtilsTest$@Test fun serialize_deserialize_configuration()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTests$ @Test fun trackCashStates_unconsumed()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_all()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTests$@Test fun trackCashStates_consumed()</ID>
    <ID>FunctionNaming:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun unconsumedCashStatesForSpending_single_issuer_reference()</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): Vault.Page&lt;T&gt;</ID>
    <ID>FunctionNaming:VaultService.kt$VaultService$ @Throws(VaultQueryException::class) fun &lt;T : ContractState&gt; _trackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_configuration()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_key()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_metadata()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_no_value()</ID>
    <ID>FunctionNaming:VersionExtractorTest.kt$VersionExtractorTest$@Test fun version_header_extraction_present()</ID>
    <ID>FunctionNaming:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$@Test fun correct_parsing_function_is_used_for_present_version()</ID>
    <ID>FunctionNaming:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$@Test fun default_value_is_used_for_absent_version()</ID>
    <ID>LargeClass:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>LargeClass:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>LongMethod:FlowCookbook.kt$InitiatorFlow$@Suppress("RemoveExplicitTypeArguments") @Suspendable override fun call()</ID>
    <ID>LongMethod:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>LongParameterList:AMQPSerializer.kt$AMQPSerializer$(obj: Any, data: Data, type: Type, output: SerializationOutput, context: SerializationContext, debugIndent: Int = 0)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, stateAndRefs: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;)</ID>
    <ID>LongParameterList:AbstractCashSelection.kt$AbstractCashSelection$(services: ServiceHub, amount: Amount&lt;Currency&gt;, onlyFromIssuerParties: Set&lt;AbstractParty&gt; = emptySet(), notary: Party? = null, lockId: UUID, withIssuerRefs: Set&lt;OpaqueBytes&gt; = emptySet())</ID>
    <ID>LongParameterList:AbstractNode.kt$(databaseConfig: DatabaseConfig, wellKnownPartyFromX500Name: (CordaX500Name) -&gt; Party?, wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?, schemaService: SchemaService, hikariProperties: Properties, cacheFactory: NamedCacheFactory, customClassLoader: ClassLoader?)</ID>
    <ID>LongParameterList:AbstractNode.kt$(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>LongParameterList:ArtemisMessagingServer.kt$ArtemisMessagingServer$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean)</ID>
    <ID>LongParameterList:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, sslOptions: BrokerRpcSslOptions, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean)</ID>
    <ID>LongParameterList:ArtemisRpcTests.kt$ArtemisRpcTests$(nodeSSlconfig: MutualSslConfiguration, brokerSslOptions: BrokerRpcSslOptions?, useSslForBroker: Boolean, clientSslOptions: ClientRpcSslOptions?, address: NetworkHostAndPort = ports.nextHostAndPort(), adminAddress: NetworkHostAndPort = ports.nextHostAndPort(), baseDirectory: Path = tempFolder.root.toPath() )</ID>
    <ID>LongParameterList:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T)</ID>
    <ID>LongParameterList:BFTSmart.kt$BFTSmart.Replica$( states: List&lt;StateRef&gt;, txId: SecureHash, callerName: CordaX500Name, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:BusinessCalendar.kt$BusinessCalendar.Companion$(startDate: LocalDate, period: Frequency, calendar: BusinessCalendar = EMPTY, dateRollConvention: DateRollConvention = DateRollConvention.Following, noOfAdditionalPeriods: Int = Integer.MAX_VALUE, endDate: LocalDate? = null, periodOffset: Int? = null)</ID>
    <ID>LongParameterList:Cash.kt$Cash$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, amount: Amount&lt;Currency&gt;, ourIdentity: PartyAndCertificate, to: AbstractParty, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CashUtils.kt$CashUtils$(services: ServiceHub, tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;Currency&gt;&gt;, ourIdentity: PartyAndCertificate, onlyFromParties: Set&lt;AbstractParty&gt; = emptySet(), anonymous: Boolean = true)</ID>
    <ID>LongParameterList:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(port: Int, name: CordaX500Name = ALICE_NAME, crlCheckSoftFail: Boolean, nodeCrlDistPoint: String = "http://${server.hostAndPort}/crl/node.crl", tlsCrlDistPoint: String? = "http://${server.hostAndPort}/crl/empty.crl", maxMessageSize: Int = MAX_MESSAGE_SIZE)</ID>
    <ID>LongParameterList:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.Companion$(clrServer: CrlServer, signatureAlgorithm: String, caCertificate: X509Certificate, caPrivateKey: PrivateKey, endpoint: String, indirect: Boolean, vararg serialNumbers: BigInteger)</ID>
    <ID>LongParameterList:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$(baseDirectory: Path, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD)</ID>
    <ID>LongParameterList:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$(certificatesDirectory: Path, keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME, keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD, keyPassword: String = keyStorePassword, trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME, trustStorePassword: String = TrustStore.DEFAULT_STORE_PASSWORD, trustStoreKeyPassword: String = TrustStore.DEFAULT_KEY_PASSWORD, @Suppress("UNUSED_PARAMETER") useOpenSsl: Boolean = false)</ID>
    <ID>LongParameterList:ContractAttachment.kt$ContractAttachment.Companion$(attachment: Attachment, contract: ContractClassName, additionalContracts: Set&lt;ContractClassName&gt; = emptySet(), uploader: String? = null, signerKeys: List&lt;PublicKey&gt; = emptyList(), version: Int = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(expiry: String, notional: BigDecimal, strike: BigDecimal, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(expiry: String, notional: Long, strike: Double, foreignCurrency: Currency, domesticCurrency: Currency, partyA: Party, partyB: Party)</ID>
    <ID>LongParameterList:ContractFunctions.kt$(partyA: Party, amountA: BigDecimal, currencyA: Currency, partyB: Party, amountB: BigDecimal, currencyB: Currency)</ID>
    <ID>LongParameterList:ContractJarTestUtils.kt$ContractJarTestUtils$(workingDir: Path, contractNames: List&lt;String&gt;, signed: Boolean = false, version: Int = 1, generateManifest: Boolean = true, jarFileName : String? = null)</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt; = this.inputs, notary: Party = this.notary, legacyContractAttachment: Attachment = this.legacyContractAttachment, upgradedContractClassName: ContractClassName = this.upgradedContract::class.java.name, upgradedContractAttachment: Attachment = this.upgradedContractAttachment, id: SecureHash = this.id, privacySalt: PrivacySalt = this.privacySalt, sigs: List&lt;TransactionSignature&gt; = this.sigs, networkParameters: NetworkParameters = this.networkParameters )</ID>
    <ID>LongParameterList:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters, upgradedContract: UpgradedContract&lt;ContractState, *&gt; )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClient$( username: String, password: String, externalTrace: Trace?, impersonatedActor: Actor?, targetLegalIdentity: CordaX500Name?, gracefulReconnect: GracefulReconnect? = null )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCClientConfiguration$( connectionMaxRetryInterval: Duration = this.connectionMaxRetryInterval, minimumServerProtocolVersion: Int = this.minimumServerProtocolVersion, trackRpcCallSites: Boolean = this.trackRpcCallSites, reapInterval: Duration = this.reapInterval, observationExecutorPoolSize: Int = this.observationExecutorPoolSize, cacheConcurrencyLevel: Int = this.cacheConcurrencyLevel, connectionRetryInterval: Duration = this.connectionRetryInterval, connectionRetryIntervalMultiplier: Double = this.connectionRetryIntervalMultiplier, maxReconnectAttempts: Int = this.maxReconnectAttempts, maxFileSize: Int = this.maxFileSize, deduplicationCacheExpiry: Duration = this.deduplicationCacheExpiry )</ID>
    <ID>LongParameterList:CordaRPCClient.kt$CordaRPCConnection.Companion$( username: String, password: String, addresses: List&lt;NetworkHostAndPort&gt;, rpcConfiguration: CordaRPCClientConfiguration, gracefulReconnect: GracefulReconnect, sslConfiguration: ClientRpcSslOptions? = null, classLoader: ClassLoader? = null )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("UNUSED_PARAMETER") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E )</ID>
    <ID>LongParameterList:CordaRPCOps.kt$( @Suppress("unused_parameter") flowConstructor: (A, B, C, D, E, F) -&gt; R, arg0: A, arg1: B, arg2: C, arg3: D, arg4: E, arg5: F )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters )</ID>
    <ID>LongParameterList:Driver.kt$DriverParameters$( isDebug: Boolean, driverDirectory: Path, portAllocation: PortAllocation, debugPortAllocation: PortAllocation, systemProperties: Map&lt;String, String&gt;, useTestClock: Boolean, startNodesInProcess: Boolean, waitForAllNodesToFinish: Boolean, notarySpecs: List&lt;NotarySpec&gt;, extraCordappPackagesToScan: List&lt;String&gt;, jmxPolicy: JmxPolicy, networkParameters: NetworkParameters, cordappsForAllNodes: Set&lt;TestCordapp&gt;? )</ID>
    <ID>LongParameterList:DriverDSL.kt$DriverDSL$( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize )</ID>
    <ID>LongParameterList:DriverDSL.kt$DriverDSL$( defaultParameters: NodeParameters = NodeParameters(), providedName: CordaX500Name? = defaultParameters.providedName, rpcUsers: List&lt;User&gt; = defaultParameters.rpcUsers, verifierType: VerifierType = defaultParameters.verifierType, customOverrides: Map&lt;String, Any?&gt; = defaultParameters.customOverrides, startInSameProcess: Boolean? = defaultParameters.startInSameProcess, maximumHeapSize: String = defaultParameters.maximumHeapSize, logLevelOverride: String? = defaultParameters.logLevelOverride )</ID>
    <ID>LongParameterList:DummyFungibleContract.kt$DummyFungibleContract$(inputs: List&lt;State&gt;, outputs: List&lt;State&gt;, tx: LedgerTransaction, issueCommand: CommandWithParties&lt;Commands.Issue&gt;, currency: Currency, issuer: PartyAndReference)</ID>
    <ID>LongParameterList:IRS.kt$FloatingRatePaymentEvent$(date: LocalDate = this.date, accrualStartDate: LocalDate = this.accrualStartDate, accrualEndDate: LocalDate = this.accrualEndDate, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, fixingDate: LocalDate = this.fixingDate, notional: Amount&lt;Currency&gt; = this.notional, rate: Rate = this.rate)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap$(floatingLeg: FloatingLeg, fixedLeg: FixedLeg, calculation: Calculation, common: Common, oracle: Party, notary: Party)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap.FixedLeg$(fixedRatePayer: AbstractParty = this.fixedRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, fixedRate: FixedRate = this.fixedRate)</ID>
    <ID>LongParameterList:IRS.kt$InterestRateSwap.FloatingLeg$(floatingRatePayer: AbstractParty = this.floatingRatePayer, notional: Amount&lt;Currency&gt; = this.notional, paymentFrequency: Frequency = this.paymentFrequency, effectiveDate: LocalDate = this.effectiveDate, effectiveDateAdjustment: DateRollConvention? = this.effectiveDateAdjustment, terminationDate: LocalDate = this.terminationDate, terminationDateAdjustment: DateRollConvention? = this.terminationDateAdjustment, dayCountBasisDay: DayCountBasisDay = this.dayCountBasisDay, dayCountBasisYear: DayCountBasisYear = this.dayCountBasisYear, dayInMonth: Int = this.dayInMonth, paymentRule: PaymentRule = this.paymentRule, paymentDelay: Int = this.paymentDelay, paymentCalendar: BusinessCalendar = this.paymentCalendar, interestPeriodAdjustment: AccrualAdjustment = this.interestPeriodAdjustment, rollConvention: DateRollConvention = this.rollConvention, fixingRollConvention: DateRollConvention = this.fixingRollConvention, resetDayInMonth: Int = this.resetDayInMonth, fixingPeriod: Int = this.fixingPeriodOffset, resetRule: PaymentRule = this.resetRule, fixingsPerPayment: Frequency = this.fixingsPerPayment, fixingCalendar: BusinessCalendar = this.fixingCalendar, index: String = this.index, indexSource: String = this.indexSource, indexTenor: Tenor = this.indexTenor )</ID>
    <ID>LongParameterList:IdenticonRenderer.kt$IdenticonRenderer$(g: GraphicsContext, x: Double, y: Double, patchIndex: Int, turn: Int, patchSize: Double, _invert: Boolean, color: PatchColor)</ID>
    <ID>LongParameterList:Injectors.kt$( metricRegistry: MetricRegistry, parallelism: Int, overallDuration: Duration, injectionRate: Rate, queueSizeMetricName: String = "QueueSize", workDurationMetricName: String = "WorkDuration", work: () -&gt; Unit )</ID>
    <ID>LongParameterList:InteractiveShell.kt$InteractiveShell$(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>LongParameterList:InternalTestUtils.kt$(hikariProperties: Properties, databaseConfig: DatabaseConfig, wellKnownPartyFromX500Name: (CordaX500Name) -&gt; Party?, wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?, schemaService: SchemaService = NodeSchemaService(), internalSchemas: Set&lt;MappedSchema&gt; = NodeSchemaService().internalSchemas(), cacheFactory: NamedCacheFactory = TestingNamedCacheFactory(), ourName: CordaX500Name = TestIdentity(ALICE_NAME, 70).name)</ID>
    <ID>LongParameterList:InternalTestUtils.kt$(inputs: List&lt;StateRef&gt;, attachments: List&lt;SecureHash&gt;, outputs: List&lt;TransactionState&lt;*&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt = PrivacySalt())</ID>
    <ID>LongParameterList:JarSignatureTestUtils.kt$JarSignatureTestUtils$(alias: String = "Test", storePassword: String = "secret!", name: String = CODE_SIGNER.toString(), keyalg: String = "RSA", keyPassword: String = storePassword, storeName: String = "_teststore")</ID>
    <ID>LongParameterList:MockServices.kt$MockServices.Companion$( cordappLoader: CordappLoader, identityService: IdentityService, networkParameters: NetworkParameters, initialIdentity: TestIdentity, moreKeys: Set&lt;KeyPair&gt;, keyManagementService: KeyManagementService, schemaService: SchemaService, persistence: CordaPersistence )</ID>
    <ID>LongParameterList:MockServices.kt$MockServices.Companion$( cordappPackages: List&lt;String&gt;, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), moreKeys: Set&lt;KeyPair&gt;, moreIdentities: Set&lt;PartyAndCertificate&gt;, cacheFactory: TestingNamedCacheFactory = TestingNamedCacheFactory() )</ID>
    <ID>LongParameterList:NetworkBootstrapperTest.kt$NetworkBootstrapperTest$(copyCordapps: CopyCordapps = CopyCordapps.FirstRunOnly, packageOwnership: Map&lt;String, PublicKey&gt;? = emptyMap(), minimumPlatformVerison: Int? = PLATFORM_VERSION, maxMessageSize: Int? = DEFAULT_MAX_MESSAGE_SIZE, maxTransactionSize: Int? = DEFAULT_MAX_TRANSACTION_SIZE, eventHorizon: Duration? = 30.days)</ID>
    <ID>LongParameterList:NetworkMapUpdater.kt$NetworkMapUpdater$(trustRoot: X509Certificate, currentParametersHash: SecureHash, ourNodeInfo: SignedNodeInfo, networkParameters: NetworkParameters, keyManagementService: KeyManagementService, networkParameterAcceptanceSettings: NetworkParameterAcceptanceSettings)</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations )</ID>
    <ID>LongParameterList:NetworkParameters.kt$NetworkParameters$(minimumPlatformVersion: Int = this.minimumPlatformVersion, notaries: List&lt;NotaryInfo&gt; = this.notaries, maxMessageSize: Int = this.maxMessageSize, maxTransactionSize: Int = this.maxTransactionSize, modifiedTime: Instant = this.modifiedTime, epoch: Int = this.epoch, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = this.whitelistedContractImplementations, eventHorizon: Duration = this.eventHorizon )</ID>
    <ID>LongParameterList:NodeParameters.kt$NodeParameters$( providedName: CordaX500Name?, rpcUsers: List&lt;User&gt;, verifierType: VerifierType, customOverrides: Map&lt;String, Any?&gt;, startInSameProcess: Boolean?, maximumHeapSize: String )</ID>
    <ID>LongParameterList:NodeParameters.kt$NodeParameters$( providedName: CordaX500Name?, rpcUsers: List&lt;User&gt;, verifierType: VerifierType, customOverrides: Map&lt;String, Any?&gt;, startInSameProcess: Boolean?, maximumHeapSize: String, additionalCordapps: Collection&lt;TestCordapp&gt; = emptySet(), flowOverrides: Map&lt;out Class&lt;out FlowLogic&lt;*&gt;&gt;, Class&lt;out FlowLogic&lt;*&gt;&gt;&gt; )</ID>
    <ID>LongParameterList:NotaryChangeTransactions.kt$NotaryChangeLedgerTransaction.Companion$(inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, newNotary: Party, id: SecureHash, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters)</ID>
    <ID>LongParameterList:ObjectSerializer.kt$ComposableObjectWriter$( obj: Any, data: Data, @Suppress("UNUSED_PARAMETER") type: Type, output: SerializationOutput, context: SerializationContext, debugIndent: Int )</ID>
    <ID>LongParameterList:ObjectSerializer.kt$EvolutionObjectSerializer.Companion$(localTypeInformation: LocalTypeInformation.Composable, remoteTypeInformation: RemoteTypeInformation.Composable, constructor: LocalConstructorInformation, properties: Map&lt;String, LocalPropertyInformation&gt;, classLoader: ClassLoader, mustPreserveData: Boolean)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, acceptableContract: SecureHash, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, dueBefore: Instant, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:ObligationUtils.kt$ObligationUtils$(tx: TransactionBuilder, obligor: AbstractParty, issuanceDef: Obligation.Terms&lt;P&gt;, pennies: Long, beneficiary: AbstractParty, notary: Party)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amount: Amount&lt;T&gt;, to: AbstractParty, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, amountIssued: Amount&lt;Issued&lt;T&gt;&gt;, assetStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData, generateExitCommand: (Amount&lt;Issued&lt;T&gt;&gt;) -&gt; CommandData)</ID>
    <ID>LongParameterList:OnLedgerAsset.kt$OnLedgerAsset.Companion$(tx: TransactionBuilder, payments: List&lt;PartyAndAmount&lt;T&gt;&gt;, acceptableStates: List&lt;StateAndRef&lt;S&gt;&gt;, payChangeTo: AbstractParty, deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;, generateMoveCommand: () -&gt; CommandData)</ID>
    <ID>LongParameterList:ParametersUtilities.kt$( notaries: List&lt;NotaryInfo&gt; = emptyList(), minimumPlatformVersion: Int = 1, modifiedTime: Instant = Instant.now(), maxMessageSize: Int = 10485760, // TODO: Make this configurable and consistence across driver, bootstrapper, demobench and NetworkMapServer maxTransactionSize: Int = maxMessageSize * 50, whitelistedContractImplementations: Map&lt;String, List&lt;AttachmentId&gt;&gt; = emptyMap(), epoch: Int = 1, eventHorizon: Duration = 30.days, packageOwnership: Map&lt;String, PublicKey&gt; = emptyMap() )</ID>
    <ID>LongParameterList:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongParameterList:PhysicalLocationStructures.kt$WorldCoordinate$(screenWidth: Double, screenHeight: Double, topLatitude: Double, bottomLatitude: Double, leftLongitude: Double, rightLongitude: Double)</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$( participants: List&lt;AbstractParty&gt;? = this.participants, owner: List&lt;AbstractParty&gt;? = this.owner, quantity: ColumnPredicate&lt;Long&gt;? = this.quantity, issuer: List&lt;AbstractParty&gt;? = this.issuer, issuerRef: List&lt;OpaqueBytes&gt;? = this.issuerRef, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, relevancyStatus: Vault.RelevancyStatus = this.relevancyStatus )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$( participants: List&lt;AbstractParty&gt;? = this.participants, uuid: List&lt;UUID&gt;? = this.uuid, externalId: List&lt;String&gt;? = this.externalId, status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, relevancyStatus: Vault.RelevancyStatus = this.relevancyStatus )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null, externalIds: List&lt;UUID&gt; = emptyList() )</ID>
    <ID>LongParameterList:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = this.status, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = this.contractStateTypes, stateRefs: List&lt;StateRef&gt;? = this.stateRefs, notary: List&lt;AbstractParty&gt;? = this.notary, softLockingCondition: SoftLockingCondition? = this.softLockingCondition, timeCondition: TimeCondition? = this.timeCondition )</ID>
    <ID>LongParameterList:RPCClient.kt$RPCClient$( rpcOpsClass: Class&lt;I&gt;, username: String, password: String, externalTrace: Trace? = null, impersonatedActor: Actor? = null, targetLegalIdentity: CordaX500Name? = null )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, listOps: List&lt;I&gt;, brokerHandle: RpcBrokerHandle, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, brokerHandle: RpcBrokerHandle, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 10L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, ops: I, queueDrainTimeout: Duration = 5.seconds )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( serverName: String = "driver-rpc-server-${random63BitValue()}", rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 5L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, customPort: NetworkHostAndPort? = null, listOps: List&lt;I&gt; )</ID>
    <ID>LongParameterList:RPCDriver.kt$RPCDriverDSL$( serverName: String = "driver-rpc-server-${random63BitValue()}", rpcUser: User = rpcTestUser, nodeLegalName: CordaX500Name = fakeNodeLegalName, maxFileSize: Int = MAX_MESSAGE_SIZE, maxBufferedBytesPerClient: Long = 5L * MAX_MESSAGE_SIZE, configuration: RPCServerConfiguration = RPCServerConfiguration.DEFAULT, customPort: NetworkHostAndPort? = null, ops: I )</ID>
    <ID>LongParameterList:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$(name: String, send: Boolean = false, consume: Boolean = false, createDurableQueue: Boolean = false, deleteDurableQueue: Boolean = false, createNonDurableQueue: Boolean = false, deleteNonDurableQueue: Boolean = false, manage: Boolean = false, browse: Boolean = false)</ID>
    <ID>LongParameterList:SerializationEnvironment.kt$SerializationEnvironment.Companion$( serializationFactory: SerializationFactory, p2pContext: SerializationContext, rpcServerContext: SerializationContext? = null, rpcClientContext: SerializationContext? = null, storageContext: SerializationContext? = null, checkpointContext: CheckpointSerializationContext? = null, checkpointSerializer: CheckpointSerializer? = null )</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$( whitelist: ClassWhitelist, carpenterClassLoader: ClassLoader, lenientCarpenterEnabled: Boolean = false, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false)</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$( whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry = DefaultDescriptorBasedSerializerRegistry(), allowEvolution: Boolean = true, overrideFingerPrinter: FingerPrinter? = null, onlyCustomSerializers: Boolean = false, mustPreserveDataWhenEvolving: Boolean = false)</ID>
    <ID>LongParameterList:SerializerFactoryBuilder.kt$SerializerFactoryBuilder$(whitelist: ClassWhitelist, classCarpenter: ClassCarpenter, descriptorBasedSerializerRegistry: DescriptorBasedSerializerRegistry, allowEvolution: Boolean, overrideFingerPrinter: FingerPrinter?, onlyCustomSerializers: Boolean, mustPreserveDataWhenEvolving: Boolean)</ID>
    <ID>LongParameterList:ServiceHubInternal.kt$ServiceHubInternal.Companion$(statesToRecord: StatesToRecord, txs: Collection&lt;SignedTransaction&gt;, validatedTransactions: WritableTransactionStorage, stateMachineRecordedTransactionMapping: StateMachineRecordedTransactionMappingStorage, vaultService: VaultServiceInternal, database: CordaPersistence)</ID>
    <ID>LongParameterList:SignatureConstraintVersioningTests.kt$SignatureConstraintVersioningTests$( cordapp: CustomCordapp, newCordapp: CustomCordapp, whiteListedCordapps: Map&lt;ContractClassName, List&lt;CustomCordapp&gt;&gt;, systemProperties: Map&lt;String, String&gt;, startNodesInProcess: Boolean, minimumPlatformVersion: Int = 4, specifyExistingConstraint: Boolean = false, addAnotherAutomaticConstraintState: Boolean = false )</ID>
    <ID>LongParameterList:SinglePartyNotaryService.kt$SinglePartyNotaryService$( inputs: List&lt;StateRef&gt;, txId: SecureHash, caller: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow?, references: List&lt;StateRef&gt; )</ID>
    <ID>LongParameterList:StateMachineState.kt$Checkpoint.Companion$( invocationContext: InvocationContext, flowStart: FlowStart, flowLogicClass: Class&lt;FlowLogic&lt;*&gt;&gt;, frozenFlowLogic: SerializedBytes&lt;FlowLogic&lt;*&gt;&gt;, ourIdentity: Party, subFlowVersion: SubFlowVersion, isEnabledTimedFlow: Boolean )</ID>
    <ID>LongParameterList:TLSAuthenticationTests.kt$TLSAuthenticationTests$( rootCAScheme: SignatureScheme, intermediateCAScheme: SignatureScheme, client1CAScheme: SignatureScheme, client1TLSScheme: SignatureScheme, client2CAScheme: SignatureScheme, client2TLSScheme: SignatureScheme )</ID>
    <ID>LongParameterList:TLSAuthenticationTests.kt$TLSAuthenticationTests$( serverSocketFactory: SSLServerSocketFactory, clientSocketFactory: SSLSocketFactory, serverPort: Int = 0, // Use 0 to get first free socket. clientPort: Int = 0, // Use 0 to get first free socket. cipherSuitesServer: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES, cipherSuitesClient: Array&lt;String&gt; = CORDA_TLS_CIPHER_SUITES )</ID>
    <ID>LongParameterList:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$(contractClassName: ContractClassName, label: String?, notary: Party, encumbrance: Int?, attachmentConstraint: AttachmentConstraint, contractState: ContractState)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext)</ID>
    <ID>LongParameterList:TransactionUtils.kt$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?, references: List&lt;StateRef&gt;, networkParametersHash: SecureHash?)</ID>
    <ID>LongParameterList:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount&lt;Issued&lt;Currency&gt;&gt;, attachmentID: SecureHash?, notary: Party)</ID>
    <ID>LongParameterList:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party, node: TestStartedNode, identity: Party, notaryNode: TestStartedNode, vararg extraSigningNodes: TestStartedNode )</ID>
    <ID>LongParameterList:UniquenessProvider.kt$UniquenessProvider$( states: List&lt;StateRef&gt;, txId: SecureHash, callerIdentity: Party, requestSignature: NotarisationRequestSignature, timeWindow: TimeWindow? = null, references: List&lt;StateRef&gt; = emptyList() )</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, atLeastThisManyStates: Int, atMostThisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT)</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(howMuch: Amount&lt;Currency&gt;, issuerServices: ServiceHub, thisManyStates: Int, issuedBy: PartyAndReference, owner: AbstractParty? = null, rng: Random? = null, statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT)</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now())</ID>
    <ID>LongParameterList:VaultFiller.kt$VaultFiller$(numberToCreate: Int, externalId: String? = null, participants: List&lt;AbstractParty&gt; = emptyList(), uniqueIdentifier: UniqueIdentifier? = null, linearString: String = "", linearNumber: Long = 0L, linearBoolean: Boolean = false, linearTimestamp: Instant = now(), constraint: AttachmentConstraint = AutomaticPlaceholderConstraint, includeMe: Boolean = true)</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime )</ID>
    <ID>LongParameterList:VaultService.kt$Vault.StateMetadata$( ref: StateRef = this.ref, contractStateClassName: String = this.contractStateClassName, recordedTime: Instant = this.recordedTime, consumedTime: Instant? = this.consumedTime, status: Vault.StateStatus = this.status, notary: AbstractParty? = this.notary, lockId: String? = this.lockId, lockUpdateTime: Instant? = this.lockUpdateTime, relevancyStatus: Vault.RelevancyStatus? )</ID>
    <ID>LongParameterList:WireTransaction.kt$WireTransaction.Companion$(inputs: List&lt;StateRef&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;Command&lt;*&gt;&gt;, attachments: List&lt;SecureHash&gt;, notary: Party?, timeWindow: TimeWindow?)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, issuerSigner: ContentSigner, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuer: X500Principal, issuerPublicKey: PublicKey, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Date, Date&gt;, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:X509Utilities.kt$X509Utilities$(certificateType: CertificateType, issuerCertificate: X509Certificate, issuerKeyPair: KeyPair, subject: X500Principal, subjectPublicKey: PublicKey, validityWindow: Pair&lt;Duration, Duration&gt; = DEFAULT_VALIDITY_WINDOW, nameConstraints: NameConstraints? = null, crlDistPoint: String? = null, crlIssuer: X500Name? = null)</ID>
    <ID>LongParameterList:internalAccessTestHelpers.kt$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>MagicNumber:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$128</ID>
    <ID>MagicNumber:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$128</ID>
    <ID>MagicNumber:AMQPServer.kt$AMQPServer$100</ID>
    <ID>MagicNumber:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$128</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$3</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$4</ID>
    <ID>MagicNumber:AbstractCashSelection.kt$AbstractCashSelection$5</ID>
    <ID>MagicNumber:AbstractNode.kt$AbstractNode$50</ID>
    <ID>MagicNumber:AccessOrderLinkedHashMap.kt$AccessOrderLinkedHashMap$0.75f</ID>
    <ID>MagicNumber:AccessOrderLinkedHashMap.kt$AccessOrderLinkedHashMap$16</ID>
    <ID>MagicNumber:AllExceptionMapper.kt$AllExceptionMapper$500</ID>
    <ID>MagicNumber:ArraySerializer.kt$ArraySerializer$4</ID>
    <ID>MagicNumber:ArtemisMessagingClient.kt$ArtemisMessagingClient$30000</ID>
    <ID>MagicNumber:ArtemisMessagingClient.kt$ArtemisMessagingClient$60000</ID>
    <ID>MagicNumber:ArtemisMessagingServer.kt$ArtemisMessagingServer$10L</ID>
    <ID>MagicNumber:ArtemisMessagingServer.kt$ArtemisMessagingServer$2000</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10006</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10009</ID>
    <ID>MagicNumber:AttachmentDemo.kt$10010</ID>
    <ID>MagicNumber:AttachmentTrustTable.kt$AttachmentTrustTable$3</ID>
    <ID>MagicNumber:AttachmentsClassLoader.kt$AttachmentsClassLoader$4</ID>
    <ID>MagicNumber:AzureSmbVolume.kt$AzureSmbVolume$5000</ID>
    <ID>MagicNumber:BFTSmart.kt$BFTSmart.Client$100</ID>
    <ID>MagicNumber:BFTSmart.kt$BFTSmart.Replica.&lt;no name provided&gt;$20000</ID>
    <ID>MagicNumber:BFTSmartConfigInternal.kt$3</ID>
    <ID>MagicNumber:BFTSmartConfigInternal.kt$BFTSmartConfigInternal$200</ID>
    <ID>MagicNumber:BootstrapperView.kt$BootstrapperView$4</ID>
    <ID>MagicNumber:BusinessCalendar.kt$BusinessCalendar.Companion$30.0</ID>
    <ID>MagicNumber:BusinessCalendar.kt$BusinessCalendar.Companion$360.0</ID>
    <ID>MagicNumber:ByteArrays.kt$10</ID>
    <ID>MagicNumber:ByteArrays.kt$16</ID>
    <ID>MagicNumber:ByteArrays.kt$4</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$1024</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$256</ID>
    <ID>MagicNumber:ByteBufferStreams.kt$64</ID>
    <ID>MagicNumber:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$3</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer$5.0</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.CashWidget$10.0</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.CashWidget$300</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.StateRowGraphic$16</ID>
    <ID>MagicNumber:CashViewer.kt$CashViewer.StateRowGraphic$30.0</ID>
    <ID>MagicNumber:ClassCarpenter.kt$ClassCarpenterImpl$3</ID>
    <ID>MagicNumber:ClientRpcExample.kt$ClientRpcExample$3</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$0.7</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$0.8</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$1000</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$10000</ID>
    <ID>MagicNumber:ClientRpcTutorial.kt$2000</ID>
    <ID>MagicNumber:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$10</ID>
    <ID>MagicNumber:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$30</ID>
    <ID>MagicNumber:CompositeSignature.kt$CompositeSignature$1024</ID>
    <ID>MagicNumber:ConfigExporter.kt$3</ID>
    <ID>MagicNumber:ConnectionManager.kt$ConnectionManager$22</ID>
    <ID>MagicNumber:ConnectionStateMachine.kt$ConnectionStateMachine$1500</ID>
    <ID>MagicNumber:ConnectionStateMachine.kt$ConnectionStateMachine$4</ID>
    <ID>MagicNumber:CordaPersistence.kt$DatabaseConfig.Defaults$100L</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClient$128</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$3</ID>
    <ID>MagicNumber:CordaRPCClient.kt$CordaRPCClientConfiguration$5</ID>
    <ID>MagicNumber:CordaSecurityProvider.kt$CordaSecurityProvider$0.1</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$2048</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$256</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$3072</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$4</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$5</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$6</ID>
    <ID>MagicNumber:Crypto.kt$Crypto$8</ID>
    <ID>MagicNumber:CryptoUtils.kt$8</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$10</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$30.0</ID>
    <ID>MagicNumber:Dashboard.kt$Dashboard$350</ID>
    <ID>MagicNumber:DefaultKryoCustomizer.kt$DefaultKryoCustomizer.ContractAttachmentSerializer$32</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$1000</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$5</ID>
    <ID>MagicNumber:DriverDSLImpl.kt$DriverDSLImpl$60</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F193</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F385</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F469</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4B0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4BB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4CE</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4DA</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F4F0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F51C</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F537</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F60E</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F634</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x1F6AB</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x200D</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2620</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x26A0</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2705</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x27A1</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0x2B05</ID>
    <ID>MagicNumber:Emoji.kt$Emoji$0xFE0F</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.2</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.3</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.7</ID>
    <ID>MagicNumber:EventGenerator.kt$ErrorFlowsEventGenerator$0.8</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$0.1</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$0.9</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$10000</ID>
    <ID>MagicNumber:EventGenerator.kt$EventGenerator$1000000</ID>
    <ID>MagicNumber:Eventually.kt$100</ID>
    <ID>MagicNumber:Eventually.kt$5</ID>
    <ID>MagicNumber:ExceptionsErrorCodeFunctions.kt$3</ID>
    <ID>MagicNumber:ExceptionsErrorCodeFunctions.kt$36</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.01</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.18</ID>
    <ID>MagicNumber:ExchangeRateModel.kt$1.31</ID>
    <ID>MagicNumber:FixingFlow.kt$FixingFlow.Fixer.&lt;no name provided&gt;$30</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$30</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$45</ID>
    <ID>MagicNumber:FlowCookbook.kt$InitiatorFlow$777</ID>
    <ID>MagicNumber:FlowCookbook.kt$ResponderFlow$99</ID>
    <ID>MagicNumber:FlowCookbook.kt$ResponderFlow.&lt;no name provided&gt;$777</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic$300</ID>
    <ID>MagicNumber:FlowLogic.kt$FlowLogic.Companion$5</ID>
    <ID>MagicNumber:FlowMonitor.kt$FlowMonitor$1000</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$14</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$16</ID>
    <ID>MagicNumber:FlowStackSnapshot.kt$64</ID>
    <ID>MagicNumber:Generator.kt$Generator.Companion$16</ID>
    <ID>MagicNumber:Generator.kt$Generator.Companion$17</ID>
    <ID>MagicNumber:GuiUtilities.kt$1000</ID>
    <ID>MagicNumber:GuiUtilities.kt$1000.0</ID>
    <ID>MagicNumber:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$10</ID>
    <ID>MagicNumber:HttpUtils.kt$HttpUtils$5</ID>
    <ID>MagicNumber:HttpUtils.kt$HttpUtils$60</ID>
    <ID>MagicNumber:IOUFlowResponder.kt$IOUFlowResponder.&lt;no name provided&gt;$100</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$360.0</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$4</ID>
    <ID>MagicNumber:IRS.kt$RatePaymentEvent$8</ID>
    <ID>MagicNumber:IRSUtils.kt$PercentageRatioUnit$100</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$16</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$90.0</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$0x3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$10</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$11</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$12</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$13</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$14</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$15</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$16</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$18</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$20</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$21</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$22</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$24</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$256</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$27</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$3</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$32.0f</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$4</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$6</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$7</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$8</ID>
    <ID>MagicNumber:IdenticonRenderer.kt$IdenticonRenderer$90</ID>
    <ID>MagicNumber:InputStreamSerializer.kt$InputStreamSerializer$4096</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$3</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$5</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork$30000</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork$50</ID>
    <ID>MagicNumber:InternalMockNetwork.kt$InternalMockNetwork.MockNode$1000</ID>
    <ID>MagicNumber:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$30000</ID>
    <ID>MagicNumber:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$60000</ID>
    <ID>MagicNumber:InternalTestUtils.kt$40</ID>
    <ID>MagicNumber:InternalTestUtils.kt$500</ID>
    <ID>MagicNumber:InternalTestUtils.kt$70</ID>
    <ID>MagicNumber:InternalUtils.kt$30</ID>
    <ID>MagicNumber:InternalUtils.kt$InputStreamAndHash.Companion$1024</ID>
    <ID>MagicNumber:Interpolators.kt$CubicSplineInterpolator$3</ID>
    <ID>MagicNumber:Interpolators.kt$CubicSplineInterpolator$3.0</ID>
    <ID>MagicNumber:IrsDemoWebApplication.kt$IrsDemoWebApplication$100</ID>
    <ID>MagicNumber:IrsDemoWebApplication.kt$IrsDemoWebApplication$1000</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$CordappLoaderTemplate$36</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$CordappLoaderTemplate$64</ID>
    <ID>MagicNumber:JarScanningCordappLoader.kt$JarScanningCordappLoader$1000</ID>
    <ID>MagicNumber:JarSignatureCollector.kt$JarSignatureCollector$1024</ID>
    <ID>MagicNumber:JarSignatureTestUtils.kt$JarSignatureTestUtils$14</ID>
    <ID>MagicNumber:KMSUtils.kt$3650</ID>
    <ID>MagicNumber:Kryo.kt$InputStreamSerializer$4096</ID>
    <ID>MagicNumber:KryoStreams.kt$1024</ID>
    <ID>MagicNumber:KryoStreams.kt$64</ID>
    <ID>MagicNumber:Literal.kt$1000</ID>
    <ID>MagicNumber:Literal.kt$1000000</ID>
    <ID>MagicNumber:LocalSerializationRule.kt$LocalSerializationRule$128</ID>
    <ID>MagicNumber:Main.kt$Main$600.0</ID>
    <ID>MagicNumber:Main.kt$Main$800.0</ID>
    <ID>MagicNumber:Main.kt$Node$10</ID>
    <ID>MagicNumber:Main.kt$Node$3</ID>
    <ID>MagicNumber:Main.kt$Transaction$5</ID>
    <ID>MagicNumber:MainView.kt$MainView$10.0</ID>
    <ID>MagicNumber:MainView.kt$MainView$12.0</ID>
    <ID>MagicNumber:MainView.kt$MainView$150</ID>
    <ID>MagicNumber:MainView.kt$MainView$30</ID>
    <ID>MagicNumber:MainView.kt$MainView$5.0</ID>
    <ID>MagicNumber:MessageSizeChecksInterceptor.kt$ArtemisMessageSizeChecksInterceptor$4</ID>
    <ID>MagicNumber:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$1024L</ID>
    <ID>MagicNumber:MockContractAttachment.kt$113</ID>
    <ID>MagicNumber:MockContractAttachment.kt$15</ID>
    <ID>MagicNumber:MockContractAttachment.kt$2</ID>
    <ID>MagicNumber:MockContractAttachment.kt$20</ID>
    <ID>MagicNumber:MockContractAttachment.kt$24</ID>
    <ID>MagicNumber:MockContractAttachment.kt$3</ID>
    <ID>MagicNumber:MockContractAttachment.kt$4</ID>
    <ID>MagicNumber:MockContractAttachment.kt$47</ID>
    <ID>MagicNumber:MockContractAttachment.kt$5</ID>
    <ID>MagicNumber:MockContractAttachment.kt$52</ID>
    <ID>MagicNumber:MockContractAttachment.kt$54</ID>
    <ID>MagicNumber:MockContractAttachment.kt$55</ID>
    <ID>MagicNumber:MockContractAttachment.kt$6</ID>
    <ID>MagicNumber:MockContractAttachment.kt$66</ID>
    <ID>MagicNumber:MockContractAttachment.kt$67</ID>
    <ID>MagicNumber:MockContractAttachment.kt$7</ID>
    <ID>MagicNumber:MockContractAttachment.kt$73</ID>
    <ID>MagicNumber:MockContractAttachment.kt$75</ID>
    <ID>MagicNumber:MockContractAttachment.kt$78</ID>
    <ID>MagicNumber:MockContractAttachment.kt$79</ID>
    <ID>MagicNumber:MockContractAttachment.kt$8</ID>
    <ID>MagicNumber:MockContractAttachment.kt$80</ID>
    <ID>MagicNumber:MockContractAttachment.kt$97</ID>
    <ID>MagicNumber:MockNetworkParametersService.kt$MockNetworkParametersStorage$20</ID>
    <ID>MagicNumber:MockServices.kt$MockServices$10000</ID>
    <ID>MagicNumber:MockServices.kt$MockServices.Companion.&lt;no name provided&gt;$512</ID>
    <ID>MagicNumber:NettyTestClient.kt$NettyTestClient$5</ID>
    <ID>MagicNumber:NettyTestHandler.kt$NettyTestHandler$5</ID>
    <ID>MagicNumber:NettyTestServer.kt$NettyTestServer$100</ID>
    <ID>MagicNumber:NettyTestServer.kt$NettyTestServer$5</ID>
    <ID>MagicNumber:Network.kt$Network$0.8</ID>
    <ID>MagicNumber:Network.kt$Network$1.2</ID>
    <ID>MagicNumber:Network.kt$Network$10</ID>
    <ID>MagicNumber:Network.kt$Network$10.0</ID>
    <ID>MagicNumber:Network.kt$Network$15.0</ID>
    <ID>MagicNumber:Network.kt$Network$180.0</ID>
    <ID>MagicNumber:Network.kt$Network$2.5</ID>
    <ID>MagicNumber:Network.kt$Network$2000.0</ID>
    <ID>MagicNumber:Network.kt$Network$3.0</ID>
    <ID>MagicNumber:Network.kt$Network$300.0</ID>
    <ID>MagicNumber:Network.kt$Network$4</ID>
    <ID>MagicNumber:Network.kt$Network$5.0</ID>
    <ID>MagicNumber:Network.kt$Network$500.0</ID>
    <ID>MagicNumber:Network.kt$Network$6.0</ID>
    <ID>MagicNumber:Network.kt$Network$85.0511</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper$3</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper$30</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$3</ID>
    <ID>MagicNumber:NetworkBootstrapper.kt$NetworkBootstrapper.Companion$40</ID>
    <ID>MagicNumber:NetworkHostAndPort.kt$NetworkHostAndPort$0xffff</ID>
    <ID>MagicNumber:NetworkMap.kt$NetworkMap$10</ID>
    <ID>MagicNumber:NetworkMapServer.kt$NetworkMapServer$500</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$24</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$4</ID>
    <ID>MagicNumber:NetworkMapUpdater.kt$NetworkMapUpdater$50</ID>
    <ID>MagicNumber:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$10</ID>
    <ID>MagicNumber:NetworkRegistrationHelper.kt$NodeRegistrationHelper$10</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$10.0</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$16</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$20.0</ID>
    <ID>MagicNumber:NewTransaction.kt$NewTransaction$40.0</ID>
    <ID>MagicNumber:Node.kt$Node$128</ID>
    <ID>MagicNumber:Node.kt$Node$256</ID>
    <ID>MagicNumber:Node.kt$Node$4</ID>
    <ID>MagicNumber:Node.kt$Node.Companion$171</ID>
    <ID>MagicNumber:Node.kt$Node.Companion$40</ID>
    <ID>MagicNumber:NodeCmdLineOptions.kt$NodeCmdLineOptions$2222</ID>
    <ID>MagicNumber:NodeConfiguration.kt$1024L</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration$5</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration.Companion$20</ID>
    <ID>MagicNumber:NodeConfiguration.kt$NodeConfiguration.Companion$300</ID>
    <ID>MagicNumber:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$5</ID>
    <ID>MagicNumber:NodeInfo.kt$NodeInfoSigner$4</ID>
    <ID>MagicNumber:NodeInfoWatcher.kt$NodeInfoWatcher$5</ID>
    <ID>MagicNumber:NodeNamedCache.kt$DefaultNamedCacheFactory$1024L</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess$60</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess.Factory$120</ID>
    <ID>MagicNumber:NodeProcess.kt$NodeProcess.Factory$5</ID>
    <ID>MagicNumber:NodeRPC.kt$NodeRPC$5</ID>
    <ID>MagicNumber:NodeSchedulerService.kt$NodeSchedulerService$60</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$10</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$100.0</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$1000</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$20</ID>
    <ID>MagicNumber:NodeStartup.kt$NodeStartup$7</ID>
    <ID>MagicNumber:NodeTabView.kt$NodeTabView$24.0</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$160</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$2.5</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView$80</ID>
    <ID>MagicNumber:NodeTerminalView.kt$NodeTerminalView.TerminalSettingsProvider$50</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$100</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$32768</ID>
    <ID>MagicNumber:NodeWebServer.kt$NodeWebServer$40</ID>
    <ID>MagicNumber:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$4</ID>
    <ID>MagicNumber:Notarise.kt$10</ID>
    <ID>MagicNumber:Notarise.kt$10003</ID>
    <ID>MagicNumber:NullKeys.kt$NullKeys$32</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$0.015</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$100000000.0</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$12</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2014</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2015</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$2021</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$21</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$7</ID>
    <ID>MagicNumber:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$9</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.001</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.00123</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.0025</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.0091</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.01</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.015</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$0.03</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$100000000.0</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$12</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$17</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2013</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2014</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2016</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2020</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2021</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$2024</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$22</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$24</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$27</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$3</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$4</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$5</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$6</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$61600000.0</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$7</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$8</ID>
    <ID>MagicNumber:OGSwapPricingExample.kt$SwapPricingExample$9</ID>
    <ID>MagicNumber:OGUtils.kt$0.001</ID>
    <ID>MagicNumber:ObjectDiffer.kt$ObjectDiffer$3</ID>
    <ID>MagicNumber:ObjectDiffer.kt$ObjectDiffer$4</ID>
    <ID>MagicNumber:Obligation.kt$Obligation.Terms$30</ID>
    <ID>MagicNumber:OracleUtils.kt$11</ID>
    <ID>MagicNumber:OracleUtils.kt$24</ID>
    <ID>MagicNumber:OracleUtils.kt$45</ID>
    <ID>MagicNumber:OrdinalIO.kt$OrdinalBits$128</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingClient$30000</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingClient$60000</ID>
    <ID>MagicNumber:P2PMessagingClient.kt$P2PMessagingConsumer$10</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$0.02</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$0.8</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$10</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$20</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$23L</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$5</ID>
    <ID>MagicNumber:Parameters.kt$Parameters$50</ID>
    <ID>MagicNumber:ParametersUtilities.kt$30</ID>
    <ID>MagicNumber:ParametersUtilities.kt$50</ID>
    <ID>MagicNumber:Password.kt$Password$5</ID>
    <ID>MagicNumber:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$100</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$180</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$180.0</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$360.0</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$4</ID>
    <ID>MagicNumber:PhysicalLocationStructures.kt$WorldCoordinate$90</ID>
    <ID>MagicNumber:PortfolioApi.kt$PortfolioApi$2016</ID>
    <ID>MagicNumber:PortfolioApi.kt$PortfolioApi$6</ID>
    <ID>MagicNumber:ProfileController.kt$ProfileController$3</ID>
    <ID>MagicNumber:QuasarInstrumentationHook.kt$QuasarInstrumentationHookAgent.Companion$20</ID>
    <ID>MagicNumber:R3Pty.kt$R3Pty$30</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$30000</ID>
    <ID>MagicNumber:RPCClient.kt$RPCClient$60000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$1000</ID>
    <ID>MagicNumber:RPCClientProxyHandler.kt$RPCClientProxyHandler$16384</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$10L</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$5</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL$5L</ID>
    <ID>MagicNumber:RPCDriver.kt$RPCDriverDSL.Companion$10</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$100</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$3</ID>
    <ID>MagicNumber:RPCDriver.kt$RandomRpcUser.Companion$4</ID>
    <ID>MagicNumber:RPCServer.kt$RPCServer$5</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps$4</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$1000</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$10</ID>
    <ID>MagicNumber:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$9</ID>
    <ID>MagicNumber:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$4</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$2000</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$5L</ID>
    <ID>MagicNumber:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$8</ID>
    <ID>MagicNumber:SSHDConfiguration.kt$SSHDConfiguration$0xffff</ID>
    <ID>MagicNumber:SSLHelper.kt$32</ID>
    <ID>MagicNumber:Schema.kt$CompositeType.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$CompositeType.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$Descriptor$0xffff</ID>
    <ID>MagicNumber:Schema.kt$Descriptor$32</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$5</ID>
    <ID>MagicNumber:Schema.kt$Field.Companion$6</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$3</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$4</ID>
    <ID>MagicNumber:Schema.kt$RestrictedType.Companion$5</ID>
    <ID>MagicNumber:SearchField.kt$SearchField$10</ID>
    <ID>MagicNumber:SearchField.kt$SearchField$5.0</ID>
    <ID>MagicNumber:SecureArtemisConfiguration.kt$SecureArtemisConfiguration$128</ID>
    <ID>MagicNumber:SecureArtemisConfiguration.kt$SecureArtemisConfiguration$16</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.Companion$32</ID>
    <ID>MagicNumber:SecureHash.kt$SecureHash.SHA256$32</ID>
    <ID>MagicNumber:ShutdownManager.kt$ShutdownManager$5</ID>
    <ID>MagicNumber:ShutdownManager.kt$ShutdownManager$60</ID>
    <ID>MagicNumber:SimmFlow.kt$100</ID>
    <ID>MagicNumber:SimmFlow.kt$1e-9</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital$1.5</ID>
    <ID>MagicNumber:StaffedFlowHospital.kt$StaffedFlowHospital$10</ID>
    <ID>MagicNumber:StandaloneShell.kt$StandaloneShell$7</ID>
    <ID>MagicNumber:StateRevisionFlow.kt$StateRevisionFlow.Requester$30</ID>
    <ID>MagicNumber:Structures.kt$PrivacySalt$32</ID>
    <ID>MagicNumber:TargetVersionDependentRules.kt$StateContractValidationEnforcementRule$4</ID>
    <ID>MagicNumber:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$1234</ID>
    <ID>MagicNumber:TestUtils.kt$10000</ID>
    <ID>MagicNumber:TestUtils.kt$30000</ID>
    <ID>MagicNumber:TraderDemo.kt$TraderDemo$1_000_000_000_000</ID>
    <ID>MagicNumber:TraderDemo.kt$TraderDemo$1_100_000_000_000</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$10</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$1000.0</ID>
    <ID>MagicNumber:TraderDemoClientApi.kt$TraderDemoClientApi$3</ID>
    <ID>MagicNumber:TransactionBuilder.kt$TransactionBuilder$4</ID>
    <ID>MagicNumber:TransactionDSLInterpreter.kt$TransactionDSL$30</ID>
    <ID>MagicNumber:TransactionUtils.kt$4</ID>
    <ID>MagicNumber:TransactionVerificationException.kt$TransactionVerificationException.ConstraintPropagationRejection$3</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$15.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$20.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$200.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$26.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer$400.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$10.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$16</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$30.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.ContractStatesView$5.0</ID>
    <ID>MagicNumber:TransactionViewer.kt$TransactionViewer.TransactionWidget$30.0</ID>
    <ID>MagicNumber:TransformsSchema.kt$UnknownTestTransform.Companion$3</ID>
    <ID>MagicNumber:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$60</ID>
    <ID>MagicNumber:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$30</ID>
    <ID>MagicNumber:UniversalContract.kt$UniversalContract$100.0</ID>
    <ID>MagicNumber:Util.kt$24</ID>
    <ID>MagicNumber:Util.kt$60</ID>
    <ID>MagicNumber:VaultFiller.kt$VaultFiller$3</ID>
    <ID>MagicNumber:VaultStateMigration.kt$VaultStateIterator$1000</ID>
    <ID>MagicNumber:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$10</ID>
    <ID>MagicNumber:WebServer.kt$10</ID>
    <ID>MagicNumber:WebServer.kt$100.0</ID>
    <ID>MagicNumber:WebServer.kt$WebServer$500</ID>
    <ID>MagicNumber:WireTransaction.kt$WireTransaction$4</ID>
    <ID>MagicNumber:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow$60</ID>
    <ID>MagicNumber:WorkflowTransactionBuildTutorial.kt$SubmitTradeApprovalFlow$60</ID>
    <ID>MagicNumber:X509Utilities.kt$X509Utilities$3650</ID>
    <ID>MagicNumber:errorAndTerminate.kt$10</ID>
    <ID>MatchingDeclarationName:AMQPSerializerFactories.kt$net.corda.serialization.internal.amqp.AMQPSerializerFactories.kt</ID>
    <ID>MatchingDeclarationName:AMQPTestSerialiationScheme.kt$net.corda.node.internal.serialization.testutils.AMQPTestSerialiationScheme.kt</ID>
    <ID>MatchingDeclarationName:AttachmentDemo.kt$net.corda.attachmentdemo.AttachmentDemo.kt</ID>
    <ID>MatchingDeclarationName:AzureRegistryLocator.kt$net.corda.networkbuilder.containers.push.azure.AzureRegistryLocator.kt</ID>
    <ID>MatchingDeclarationName:CheckpointSerializationScheme.kt$net.corda.serialization.internal.CheckpointSerializationScheme.kt</ID>
    <ID>MatchingDeclarationName:CheckpointSerializationTestHelpers.kt$net.corda.testing.core.internal.CheckpointSerializationTestHelpers.kt</ID>
    <ID>MatchingDeclarationName:ClassCarpenterTestUtils.kt$net.corda.serialization.internal.carpenter.ClassCarpenterTestUtils.kt</ID>
    <ID>MatchingDeclarationName:ConfigException.kt$net.corda.core.cordapp.ConfigException.kt</ID>
    <ID>MatchingDeclarationName:ConfigUtilities.kt$net.corda.node.services.config.ConfigUtilities.kt</ID>
    <ID>MatchingDeclarationName:ContractsDSL.kt$net.corda.core.contracts.ContractsDSL.kt</ID>
    <ID>MatchingDeclarationName:CordaUtils.kt$net.corda.core.internal.CordaUtils.kt</ID>
    <ID>MatchingDeclarationName:CurrencyParameterSensitivitySerialiser.kt$net.corda.vega.plugin.customserializers.CurrencyParameterSensitivitySerialiser.kt</ID>
    <ID>MatchingDeclarationName:FinanceWorkflowsUtils.kt$net.corda.finance.workflows.utils.FinanceWorkflowsUtils.kt</ID>
    <ID>MatchingDeclarationName:FlowStackSnapshot.kt$net.corda.testing.internal.FlowStackSnapshot.kt</ID>
    <ID>MatchingDeclarationName:FlowsExecutionModeRpcTest.kt$net.corda.client.rpc.FlowsExecutionModeRpcTest.kt</ID>
    <ID>MatchingDeclarationName:IRSDemo.kt$net.corda.irs.web.demo.IRSDemo.kt</ID>
    <ID>MatchingDeclarationName:InterestSwapRestAPI.kt$net.corda.irs.web.api.InterestSwapRestAPI.kt</ID>
    <ID>MatchingDeclarationName:InternalAccessTestHelpers.kt$net.corda.serialization.internal.InternalAccessTestHelpers.kt</ID>
    <ID>MatchingDeclarationName:IrsDemoClientApi.kt$net.corda.irs.web.demo.IrsDemoClientApi.kt</ID>
    <ID>MatchingDeclarationName:KeyStoreConfigHelpers.kt$net.corda.nodeapi.internal.KeyStoreConfigHelpers.kt</ID>
    <ID>MatchingDeclarationName:Main.kt$net.corda.bootstrapper.Main.kt</ID>
    <ID>MatchingDeclarationName:Measure.kt$net.corda.client.rpc.Measure.kt</ID>
    <ID>MatchingDeclarationName:MockNetworkParametersService.kt$net.corda.testing.node.internal.MockNetworkParametersService.kt</ID>
    <ID>MatchingDeclarationName:NamedCache.kt$net.corda.core.internal.NamedCache.kt</ID>
    <ID>MatchingDeclarationName:NetParams.kt$net.corda.netparams.NetParams.kt</ID>
    <ID>MatchingDeclarationName:NetworkParametersServiceInternal.kt$net.corda.core.internal.NetworkParametersServiceInternal.kt</ID>
    <ID>MatchingDeclarationName:OGSwapPricingCcpExample.kt$net.corda.vega.analytics.example.OGSwapPricingCcpExample.kt</ID>
    <ID>MatchingDeclarationName:OGSwapPricingExample.kt$net.corda.vega.analytics.example.OGSwapPricingExample.kt</ID>
    <ID>MatchingDeclarationName:PlatformSecureRandom.kt$net.corda.core.crypto.internal.PlatformSecureRandom.kt</ID>
    <ID>MatchingDeclarationName:Query.kt$net.corda.webserver.api.Query.kt</ID>
    <ID>MatchingDeclarationName:ReceiveAllFlowTests.kt$net.corda.coretests.flows.ReceiveAllFlowTests.kt</ID>
    <ID>MatchingDeclarationName:ReferenceInputStateTests.kt$net.corda.coretests.transactions.ReferenceInputStateTests.kt</ID>
    <ID>MatchingDeclarationName:RigorousMock.kt$net.corda.testing.internal.RigorousMock.kt</ID>
    <ID>MatchingDeclarationName:RpcServerCordaFutureSerialiser.kt$net.corda.node.serialization.amqp.RpcServerCordaFutureSerialiser.kt</ID>
    <ID>MatchingDeclarationName:SSLHelper.kt$net.corda.nodeapi.internal.protonwrapper.netty.SSLHelper.kt</ID>
    <ID>MatchingDeclarationName:SampleData.kt$net.corda.deterministic.verifier.SampleData.kt</ID>
    <ID>MatchingDeclarationName:SerializationHelper.kt$net.corda.networkbuilder.serialization.SerializationHelper.kt</ID>
    <ID>MatchingDeclarationName:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>MatchingDeclarationName:Specification.kt$net.corda.common.configuration.parsing.internal.Specification.kt</ID>
    <ID>MatchingDeclarationName:SpringDriver.kt$net.corda.test.spring.SpringDriver.kt</ID>
    <ID>MatchingDeclarationName:SupportedTransforms.kt$net.corda.serialization.internal.amqp.SupportedTransforms.kt</ID>
    <ID>MatchingDeclarationName:TargetVersionDependentRules.kt$net.corda.core.internal.rules.TargetVersionDependentRules.kt</ID>
    <ID>MatchingDeclarationName:TestConstants.kt$net.corda.testing.core.TestConstants.kt</ID>
    <ID>MatchingDeclarationName:TestUtils.kt$net.corda.testing.core.TestUtils.kt</ID>
    <ID>MatchingDeclarationName:TransactionTypes.kt$net.corda.explorer.model.TransactionTypes.kt</ID>
    <ID>MatchingDeclarationName:TutorialFlowStateMachines.kt$net.corda.docs.kotlin.tutorial.flowstatemachines.TutorialFlowStateMachines.kt</ID>
    <ID>MatchingDeclarationName:Utils.kt$io.cryptoblk.core.Utils.kt</ID>
    <ID>MatchingDeclarationName:VirtualCordapps.kt$net.corda.node.internal.cordapp.VirtualCordapps.kt</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager$crlCheckSoftFail: Boolean</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$val msg = "Message exceeds maxMessageSize network parameter, maxMessageSize: [${amqpConfig.maxMessageSize}], message size: [${artemisMessage.bodySize}], " + "dropping message, uuid: ${artemisMessage.getObjectProperty("_AMQ_DUPL_ID")}"</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPBridge$val session = sessionFactory.createSession(NODE_P2P_USER, NODE_P2P_USER, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:AMQPBridgeManager.kt$AMQPBridgeManager.AMQPConfigurationImpl$constructor(config: MutualSslConfiguration, maxMessageSize: Int, crlCheckSoftFail: Boolean) : this(config.keyStore.get(), config.trustStore.get(), maxMessageSize, crlCheckSoftFail)</ID>
    <ID>MaxLineLength:AMQPBridgeTest.kt$AMQPBridgeTest$private</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler$eventProcessor = EventProcessor(ch, serverMode, localCert!!.subjectX500Principal.toString(), remoteCert!!.subjectX500Principal.toString(), userName, password)</ID>
    <ID>MaxLineLength:AMQPChannelHandler.kt$AMQPChannelHandler${ logWarnWithMDC("SSL Handshake closed early.") }</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme$return SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader, context.lenientCarpenterEnabled).apply { register(RpcClientObservableDeSerializer) register(RpcClientCordaFutureSerializer(this)) register(RxNotificationSerializer(this)) }</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$ fun initialiseSerialization(classLoader: ClassLoader? = null, customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt; = emptySet(), serializationWhitelists: Set&lt;SerializationWhitelist&gt; = emptySet(), serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$fun createSerializationEnv(classLoader: ClassLoader? = null, customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt; = emptySet(), serializationWhitelists: Set&lt;SerializationWhitelist&gt; = emptySet(), serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt; = AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised()): SerializationEnvironment</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$nodeSerializationEnv = createSerializationEnv(classLoader, customSerializers, serializationWhitelists, serializerFactoriesForContexts)</ID>
    <ID>MaxLineLength:AMQPClientSerializationScheme.kt$AMQPClientSerializationScheme.Companion$registerScheme(AMQPClientSerializationScheme(customSerializers, serializationWhitelists, serializerFactoriesForContexts))</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$val key = SerializationFactoryCacheKey(context.whitelist, context.deserializationClassLoader, context.preventDataLoss, context.customSerializers)</ID>
    <ID>MaxLineLength:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme${ // This is a hack introduced in version 3 to fix a spring boot issue - CORDA-1747. // It breaks the shell because it overwrites the CordappClassloader with the system classloader that doesn't know about any CorDapps. // In case a spring boot serialization issue with generics is found, a better solution needs to be found to address it. // var contextToUse = context // if (context.useCase == SerializationContext.UseCase.RPCClient) { // contextToUse = context.withClassLoader(getContextClassLoader()) // } val serializerFactory = getSerializerFactory(context) return DeserializationInput(serializerFactory).deserialize(byteSequence, clazz, context) }</ID>
    <ID>MaxLineLength:AMQPSerializerFactories.kt$ fun createClassCarpenter(context: SerializationContext): ClassCarpenter</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer$server.group(bossGroup, workerGroup).channel(NioServerSocketChannel::class.java).option(ChannelOption.SO_BACKLOG, 100).handler(LoggingHandler(LogLevel.INFO)).childHandler(ServerChannelInitializer(this))</ID>
    <ID>MaxLineLength:AMQPServer.kt$AMQPServer$val channelFuture = server.bind(hostName, port).sync() // block/throw here as better to know we failed to claim port than carry on</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor() : this(emptySet(), emptySet(), AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised() )</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, AccessOrderLinkedHashMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;(128).toSynchronised())</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$constructor(cordapps: List&lt;Cordapp&gt;, serializerFactoriesForContexts: MutableMap&lt;SerializationFactoryCacheKey, SerializerFactory&gt;) : this(cordapps.customSerializers, cordapps.serializationWhitelists, serializerFactoriesForContexts)</ID>
    <ID>MaxLineLength:AMQPServerSerializationScheme.kt$AMQPServerSerializationScheme$return SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader, context.lenientCarpenterEnabled).apply { register(RpcServerObservableSerializer()) register(RpcServerCordaFutureSerializer(this)) register(RxNotificationSerializer(this)) }</ID>
    <ID>MaxLineLength:AMQPTestUtils.kt$val dir = ProjectStructure.projectRootDir / "serialization" / "src" / "test" / "resources" / javaClass.packageName_.replace('.', separatorChar)</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingParameterList$data</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser.ParseState.ParsingRawType$data</ID>
    <ID>MaxLineLength:AMQPTypeIdentifierParserTests.kt$AMQPTypeIdentifierParserTests$verify(" java.util.Map &lt; java.util.Map&lt; java.lang.String, java.lang.Integer &gt;, java.util.Map &lt; java.lang.Long , java.lang.String &gt; &gt;")</ID>
    <ID>MaxLineLength:ANSIProgressRenderer.kt$StdoutANSIProgressRenderer$val consoleAppender = manager.configuration.appenders.values.filterIsInstance&lt;ConsoleAppender&gt;().singleOrNull { it.name == "Console-Selector" }</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 5, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_3_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$checkTrackingState(captor, 6, listOf(stepSuccess(STEP_1_LABEL), stepSuccess(STEP_3_LABEL), stepSuccess(STEP_2_LABEL), stepActive(STEP_3_LABEL), stepNotRun(STEP_4_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_2_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_4_LABEL), Pair(0, STEP_5_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$feedSubject.onNext(listOf(Pair(0, STEP_1_LABEL), Pair(1, STEP_3_LABEL), Pair(0, STEP_2_LABEL), Pair(1, STEP_3_LABEL), Pair(2, STEP_4_LABEL)))</ID>
    <ID>MaxLineLength:ANSIProgressRendererTest.kt$ANSIProgressRendererTest$flowProgressHandle = FlowProgressHandleImpl(StateMachineRunId.createRandom(), openFuture&lt;String&gt;(), Observable.empty(), stepsTreeIndexFeed, stepsTreeFeed)</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$ByteSequence.of(byteArrayOf('c'.toByte(), 'o'.toByte(), 'r'.toByte(), 'd'.toByte(), 'a'.toByte(), 0.toByte(), 0.toByte(), 1.toByte()))</ID>
    <ID>MaxLineLength:AbstractAMQPSerializationSchemeTest.kt$AbstractAMQPSerializationSchemeTest$val deserialized = serialized.deserialize(context = context, serializationFactory = serializationEnvironment.serializationFactory)</ID>
    <ID>MaxLineLength:AbstractAttachment.kt$AbstractAttachment.Companion$ @DeleteForDJVM fun SerializeAsTokenContext.attachmentDataLoader(id: SecureHash): () -&gt; ByteArray</ID>
    <ID>MaxLineLength:AbstractCashFlow.kt$CashException : FlowException</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$ protected abstract fun executeQuery(connection: Connection, amount: Amount&lt;Currency&gt;, lockId: UUID, notary: Party?, onlyFromIssuerParties: Set&lt;AbstractParty&gt;, withIssuerRefs: Set&lt;OpaqueBytes&gt;, withResultSet: (ResultSet) -&gt; Boolean): Boolean</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection for $amount retrieved ${stateAndRefs.count()} states totalling $totalPennies pennies: $stateAndRefs")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$log.trace("Coin selection requested $amount but retrieved $totalPennies pennies with state refs: ${stateAndRefs.map { it.ref }}")</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$onlyFromIssuerParties: Set&lt;AbstractParty&gt;</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection$private</ID>
    <ID>MaxLineLength:AbstractCashSelection.kt$AbstractCashSelection.Companion${ instance.set(cashSelectionAlgo) cashSelectionAlgo }</ID>
    <ID>MaxLineLength:AbstractConcatenatedList.kt$AbstractConcatenatedList$abstract</ID>
    <ID>MaxLineLength:AbstractFlattenedList.kt$AbstractFlattenedList$abstract</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$" for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$"Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key"</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// Ideally we should be disabling the FinalityHandler if it's not needed, to prevent any party from submitting transactions to us without // us checking. Previously this was gated on app target version and if there were no apps with target version &lt;= 3 then the handler would // be disabled. However this prevents seemless rolling-upgrades and so it was removed until a better solution comes along. private fun installFinalityHandler()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$// There is already a party in the identity store for this node, but the key has been lost. If this node starts up, it will // publish it's new key to the network map, which Corda cannot currently handle. To prevent this, stop the node from starting. "Private key for the node legal identity not found (alias $legalIdentityPrivateKeyAlias) but the corresponding public key" + " for it exists in the database. This suggests the identity for this node has been lost. Shutting down to prevent network map issues."</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$AllCertificateStores</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$CheckpointVerifier.verifyCheckpointsCompatible(checkpointStorage, cordappProvider.cordapps, versionInfo.platformVersion, services, tokenizableServices)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$database.startHikariPool(props, configuration.database, schemaService.internalSchemas(), metricRegistry, this.cordappLoader, configuration.baseDirectory, configuration.myLegalName)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$flowManager.registerInitiatedCoreFlowFactory(ContractUpgradeFlow.Initiate::class, NotaryChangeHandler::class, ::ContractUpgradeHandler)</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$log.warn("Found more than one node registration with our legal name, this is only expected if our keypair has been regenerated")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$parseSecureHashConfiguration(configuration.blacklistedAttachmentSigningKeys) { "Error while adding signing key $it to blacklistedAttachmentSigningKeys" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$parseSecureHashConfiguration(configuration.cordappSignerKeyFingerprintBlacklist) { "Error while adding key fingerprint $it to blacklistedAttachmentSigningKeys" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$private</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$throw IllegalStateException("CryptoService and signingCertificateStore are not aligned, the entry for key-alias: $alias is only found in $keyExistsIn")</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val cordappProvider = CordappProviderImpl(cordappLoader, CordappConfigFileProvider(configuration.cordappDirectories), attachments).tokenize()</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode$val servicesForResolution = ServicesForResolutionImpl(identityService, attachments, cordappProvider, networkParametersStorage, transactionStorage).also { attachments.servicesForResolution = it }</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.AppServiceHubImpl$override val database: CordaTransactionSupport</ID>
    <ID>MaxLineLength:AbstractNode.kt$AbstractNode.AppServiceHubImpl$require(logicType.isAnnotationPresent(StartableByService::class.java)) { "${logicType.name} was not designed for starting by a CordaService" }</ID>
    <ID>MaxLineLength:AbstractNode.kt$ex is HikariPool.PoolInitializationException -&gt; throw CouldNotCreateDataSourceException("Could not connect to the database. Please check your JDBC connection URL, or the connectivity to the database.", ex)</ID>
    <ID>MaxLineLength:AbstractNode.kt$ex.cause is ClassNotFoundException -&gt; throw CouldNotCreateDataSourceException("Could not find the database driver class. Please add it to the 'drivers' folder. See: https://docs.corda.net/corda-configuration-file.html")</ID>
    <ID>MaxLineLength:AbstractNode.kt$fun CordaPersistence.startHikariPool(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>MaxLineLength:AbstractNode.kt$org.hibernate.type.descriptor.java.JavaTypeDescriptorRegistry.INSTANCE.addDescriptor(AbstractPartyDescriptor(wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous))</ID>
    <ID>MaxLineLength:AbstractNode.kt$return ClientRpcSslOptions(trustStorePath = nodeRpcOptions.sslConfig!!.keyStorePath, trustStorePassword = nodeRpcOptions.sslConfig!!.keyStorePassword)</ID>
    <ID>MaxLineLength:AbstractNode.kt$val attributeConverters = listOf(PublicKeyToTextConverter(), AbstractPartyToX500NameAsStringConverter(wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous))</ID>
    <ID>MaxLineLength:AbstractPartyDescriptor.kt$AbstractPartyDescriptor$private val wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?</ID>
    <ID>MaxLineLength:AbstractPartyToX500NameAsStringConverter.kt$AbstractPartyToX500NameAsStringConverter$private val wellKnownPartyFromAnonymous: (AbstractParty) -&gt; Party?</ID>
    <ID>MaxLineLength:AbstractRPCTest.kt$AbstractRPCTest$startInVmRpcServer(ops = ops, rpcUser = rpcUser, configuration = serverConfiguration, queueDrainTimeout = queueDrainTimeout)</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Acceptor&lt;in T&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow$Instigator&lt;out S : ContractState, out T : ContractState, out M&gt; : FlowLogic</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$@Suspendable private</ID>
    <ID>MaxLineLength:AbstractStateReplacementFlow.kt$AbstractStateReplacementFlow.Instigator$return excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, originalState.state.data.participants)).map { initiateFlow(it.key) to it.value }</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$flowMessaging.sendSessionMessage(sessionState.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, action.senderUUID))</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$private val checkpointBandwidth = metrics.register("Flows.CheckpointVolumeBytesPerSecondCurrent", LatchedGauge(checkpointSizesThisSecond))</ID>
    <ID>MaxLineLength:ActionExecutorImpl.kt$ActionExecutorImpl$private val checkpointBandwidthHist = metrics.register("Flows.CheckpointVolumeBytesPerSecondHist", Histogram(SlidingTimeWindowArrayReservoir(1, TimeUnit.DAYS)))</ID>
    <ID>MaxLineLength:AdditionP2PAddressModeTest.kt$AdditionP2PAddressModeTest$startNode(providedName = DUMMY_BANK_B_NAME, rpcUsers = listOf(testUser), customOverrides = mapOf("p2pAddress" to portAllocation.nextHostAndPort().toString()))</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `H2 address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$@Test fun `rpc admin address`()</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertThat(exception.addresses).contains(address).withFailMessage("Expected addresses to contain $address but was ${exception.addresses}.")</ID>
    <ID>MaxLineLength:AddressBindingFailureTests.kt$AddressBindingFailureTests$assertThatThrownBy { startNode(customOverrides = overrides(address)).getOrThrow() }</ID>
    <ID>MaxLineLength:AllButBlacklisted.kt$AllButBlacklisted$throw IllegalStateException("The $matchType $aMatch of ${type.name} is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:Amount.kt$Amount&lt;T : Any&gt; : Comparable</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$remaining = SourceAndAmount(payer, balance.amount.copy(quantity = Math.subtractExact(balance.amount.quantity, residual)), newRef)</ID>
    <ID>MaxLineLength:Amount.kt$AmountTransfer$result = 31 * result + (source.hashCode() xor destination.hashCode())</ID>
    <ID>MaxLineLength:Amount.kt$TokenizableAssetInfo$/** The nominal display unit size of a single token, potentially with trailing decimal display places if the scale parameter is non-zero. */ val displayTokenSize: BigDecimal</ID>
    <ID>MaxLineLength:AmountTests.kt$AmountTests$val collector = Collectors.toMap&lt;SourceAndAmount&lt;Currency, String&gt;, Pair&lt;String, Currency&gt;, BigDecimal&gt;({ Pair(it.source, it.amount.token) }, { it.amount.toDecimal() }, { x, y -&gt; x + y })</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$ override fun calculateSensitivitiesBatch(trades: List&lt;ResolvedSwapTrade&gt;, pricer: DiscountingSwapProductPricer, ratesProvider: ImmutableRatesProvider): Map&lt;ResolvedSwapTrade, CurrencyAmount&gt;</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$override</ID>
    <ID>MaxLineLength:AnalyticsEngine.kt$OGSIMMAnalyticsEngine$val t = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, it.value.currencyParameterSensitivities, it.value.multiCurrencyAmount)</ID>
    <ID>MaxLineLength:AnonymousParty.kt$AnonymousParty : DestinationAbstractParty</ID>
    <ID>MaxLineLength:AnotherDummyContract.kt$AnotherDummyContract$return TransactionBuilder(notary).withItems(StateAndContract(state, ANOTHER_DUMMY_PROGRAM_ID), Command(Commands.Create(), owner.party.owningKey))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$ operator fun set(key: K, value: V)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$log.warn("Double insert in ${this.javaClass.name} for entity class $persistentEntityClass key $key, not inserting the second time")</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase$oldValueInCache</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // IMPORTANT: The flush is needed because detach() makes the queue of unflushed entries invalid w.r.t. Hibernate internal state if the found entity is unflushed. // We want the detach() so that we rely on our cache memory management and don't retain strong references in the Hibernate session. session.flush() }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase${ // Some database transactions, including us, writing, with readers seeing whatever is in the database and writers seeing the (in memory) value. Transactional.InFlight(this, key, _readerValueLoader = { loadValue(key) }).apply { alsoWrite(value) } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$get() = if (isPresentAsWriter) loadAsWriter() else if (isPresentAsReader) loadAsReader()!! else throw NoSuchElementException("Not present")</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$get() = if (writerValueLoader.get() != _writerValueLoader) writerValueLoader.get()() else if (readerValueLoader.get() != _readerValueLoader) readerValueLoader.get()() else null</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight$private val _writerValueLoader: () -&gt; T = { throw IllegalAccessException("No value loader provided") }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase.Transactional.InFlight${ // Make the lazy loader the writers see actually just return the value that has been set. writerValueLoader.set { _value } // We make all these vals so that the lambdas do not need a reference to this, and so the onCommit only has a weak ref to the value. // We want this so that the cache could evict the value (due to memory constraints etc) without the onCommit callback // retaining what could be a large memory footprint object. val tx = contextTransaction val strongKey = key val strongMap = map if (map.addPendingKey(key, tx)) { // If the transaction commits, update cache to make globally visible if we're first for this key, // and then stop saying the transaction is writing the key. tx.onCommit { strongMap.cache.asMap().computeIfPresent(strongKey) { _, transactional: Transactional&lt;T&gt; -&gt; if (transactional is Transactional.InFlight&lt;*, T&gt;) { transactional.committed.set(true) val value = transactional.peekableValue if (value != null) { Transactional.Committed(value) } else { transactional } } else { transactional } } strongMap.removePendingKey(strongKey, tx) } // If the transaction rolls back, stop saying this transaction is writing the key. tx.onRollback { strongMap.removePendingKey(strongKey, tx) } } }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapNonConcurrentTest.kt$AppendOnlyPersistentMapNonConcurrentTest$NodeSchemaService(setOf(MappedSchema(AppendOnlyPersistentMapTest::class.java, 1, listOf(AppendOnlyPersistentMapNonConcurrentTest.PersistentMapEntry::class.java))))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.SuccessButErrorOnCommit))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest$val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit), Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit))</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest${ // Writes intentionally do not check the database first, so purging between read and write changes behaviour // Also, a purge after write causes the subsequent read to flush to the database, causing the read to generate a constraint violation when single threaded (in same database transaction). val remapped = mapOf(Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.Success, Outcome.Fail) to Scenario(true, ReadOrWrite.Read, ReadOrWrite.Write, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit), Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.Success) to Scenario(true, ReadOrWrite.Write, ReadOrWrite.Read, Outcome.SuccessButErrorOnCommit, Outcome.SuccessButErrorOnCommit)) scenario = remapped[scenario] ?: scenario prepopulateIfRequired() val map = createMap() val a = TestThread("A", map, true).apply { phase1.countDown() phase3.countDown() } val b = TestThread("B", map, true).apply { phase1.countDown() phase3.countDown() } try { database.transaction { a.run() map.invalidate() b.run() } } catch (t: PersistenceException) { // This only helps if thrown on commit, otherwise other latches not counted down. assertEquals(t.message, Outcome.SuccessButErrorOnCommit, a.outcome) } a.await(a::phase4) b.await(b::phase4) assertTrue(map.pendingKeysIsEmpty()) }</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.Companion$Scenario(false, ReadOrWrite.WriteDuplicateAllowed, ReadOrWrite.WriteDuplicateAllowed, Outcome.Success, Outcome.SuccessButErrorOnCommit, Outcome.Fail)</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$inner</ID>
    <ID>MaxLineLength:AppendOnlyPersistentMapTest.kt$AppendOnlyPersistentMapTest.TestThread$val outcome = if (name == "A") scenario.aExpected else if (singleThreaded) scenario.bExpectedIfSingleThreaded else scenario.bExpected</ID>
    <ID>MaxLineLength:ArtemisBroker.kt$fun java.io.IOException.isBindingError()</ID>
    <ID>MaxLineLength:ArtemisMessagingComponent.kt$ArtemisMessagingComponent.RemoteInboxAddress.Companion$require(address.startsWith(PEERS_PREFIX)) { "Failed to map address: $address to a remote topic as it is not in the $PEERS_PREFIX namespace" }</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$acceptorConfigurations = mutableSetOf(p2pAcceptorTcpTransport(NetworkHostAndPort(messagingServerAddress.host, messagingServerAddress.port), config.p2pSslOptions))</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$deleteNonDurableQueue</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalBufferSize_AIO = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingServer.kt$ArtemisMessagingServer$journalBufferSize_NIO = maxMessageSize + JOURNAL_HEADER_SIZE</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$private</ID>
    <ID>MaxLineLength:ArtemisMessagingTest.kt$ArtemisMessagingTest$val (messagingClient, receivedMessages) = createAndStartClientAndServer(clientMaxMessageSize = 100_000, serverMaxMessageSize = 50_000)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker$val serverConfiguration = RpcBrokerConfiguration(baseDirectory, maxMessageSize, jmxEnabled, addresses.primary, adminAddressOptional, sslOptions, useSsl, nodeConfiguration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$fun withSsl(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, sslOptions: BrokerRpcSslOptions, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean): ArtemisBroker</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$fun withoutSsl(configuration: MutualSslConfiguration, address: NetworkHostAndPort, adminAddress: NetworkHostAndPort, securityManager: RPCSecurityManager, maxMessageSize: Int, jmxEnabled: Boolean, baseDirectory: Path, shouldStartLocalShell: Boolean): ArtemisBroker</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$return ArtemisRpcBroker(address, adminAddress, null, false, securityManager, maxMessageSize, jmxEnabled, baseDirectory, configuration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcBroker.kt$ArtemisRpcBroker.Companion$return ArtemisRpcBroker(address, adminAddress, sslOptions, true, securityManager, maxMessageSize, jmxEnabled, baseDirectory, configuration, shouldStartLocalShell)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$ArtemisRpcBroker.withSsl(nodeSSlconfig, address, adminAddress, brokerSslOptions!!, securityManager, maxMessageSize, jmxEnabled, baseDirectory, false)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$ArtemisRpcBroker.withoutSsl(nodeSSlconfig, address, adminAddress, securityManager, maxMessageSize, jmxEnabled, baseDirectory, false)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$InternalRPCMessagingClient(nodeSSlconfig, adminAddress, maxMessageSize, CordaX500Name("MegaCorp", "London", "GB"), RPCServerConfiguration.DEFAULT)</ID>
    <ID>MaxLineLength:ArtemisRpcTests.kt$ArtemisRpcTests$private</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, config: MutualSslConfiguration?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, keyStore: FileBasedCertificateStoreSupplier?, trustStore: FileBasedCertificateStoreSupplier?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pConnectorTcpTransport(hostAndPort: NetworkHostAndPort, config: MutualSslConfiguration?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun p2pConnectorTcpTransport(hostAndPort: NetworkHostAndPort, keyStore: FileBasedCertificateStoreSupplier?, trustStore: FileBasedCertificateStoreSupplier?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcAcceptorTcpTransport(hostAndPort: NetworkHostAndPort, config: BrokerRpcSslOptions?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcConnectorTcpTransport(hostAndPort: NetworkHostAndPort, config: ClientRpcSslOptions?, enableSSL: Boolean = true): TransportConfiguration</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$fun rpcConnectorTcpTransportsFromList(hostAndPortList: List&lt;NetworkHostAndPort&gt;, config: ClientRpcSslOptions?, enableSSL: Boolean = true): List&lt;TransportConfiguration&gt;</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$options[TransportConstants.HANDSHAKE_TIMEOUT] = 0</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$private</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return TransportConfiguration(acceptorFactoryClassName, defaultArtemisOptions(hostAndPort) + defaultSSLOptions + config.toTransportOptions() + (TransportConstants.HANDSHAKE_TIMEOUT to 0))</ID>
    <ID>MaxLineLength:ArtemisTcpTransport.kt$ArtemisTcpTransport.Companion$return TransportConfiguration(connectorFactoryClassName, defaultArtemisOptions(hostAndPort) + defaultSSLOptions + config.toTransportOptions())</ID>
    <ID>MaxLineLength:ArtemisUtils.kt$require(messageSize &lt;= limit) { "Message exceeds maxMessageSize network parameter, maxMessageSize: [$limit], message size: [$messageSize]" }</ID>
    <ID>MaxLineLength:AsyncLoggerContextSelectorNoThreadLocal.kt$AsyncLoggerContextSelectorNoThreadLocal.Companion$return AsyncLoggerContextSelectorNoThreadLocal::class.java.name == PropertiesUtil.getProperties().getStringProperty(Constants.LOG4J_CONTEXT_SELECTOR)</ID>
    <ID>MaxLineLength:Attachment.kt$Attachment$/** * The parties that have correctly signed the whole attachment. * Even though this returns a list of party objects, it is not required that these parties exist on the network, but rather they are a mapping from the signing key to the X.500 name. * * Note: Anyone can sign attachments, not only Corda parties. It's recommended to use [signerKeys]. */ @Deprecated("Use signerKeys. There is no requirement that attachment signers are Corda parties.") val signers: List&lt;Party&gt;</ID>
    <ID>MaxLineLength:AttachmentConstraint.kt$HashAttachmentConstraint$log.warn("Hash constraint check failed: $attachmentId does not match contract attachment JAR ${attachment.id} or contract attachment JAR is untrusted")</ID>
    <ID>MaxLineLength:AttachmentDemoTest.kt$AttachmentDemoTest$cordappsForAllNodes = listOf(findCordapp("net.corda.attachmentdemo.contracts"), findCordapp("net.corda.attachmentdemo.workflows"))</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests$assertThatThrownBy { alice.rpc.startFlow(::ConsumeAndBroadcastFlow, stateRef, bob.nodeInfo.singleIdentity()).returnValue.getOrThrow() }</ID>
    <ID>MaxLineLength:AttachmentLoadingTests.kt$AttachmentLoadingTests.Companion$val issuanceFlowClass: Class&lt;FlowLogic&lt;StateRef&gt;&gt; = uncheckedCast(loadFromIsolated("net.corda.isolated.workflows.IsolatedIssuanceFlow"))</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$client.hackAttachment(attachmentId, "hacked")</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$client.internals.disableDBCloseOnStop()</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest$return (client.smm.allStateMachines[0].stateMachine.resultFuture.apply { mockNet.runNetwork() }.getOrThrow() as ClientResult).attachmentContent</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$AttachmentSerializationTest.CustomAttachmentLogic$private</ID>
    <ID>MaxLineLength:AttachmentSerializationTest.kt$val attachment = session.get&lt;NodeAttachmentService.DBAttachment&gt;(NodeAttachmentService.DBAttachment::class.java, attachmentId.toString())</ID>
    <ID>MaxLineLength:AttachmentStorageInternal.kt$AttachmentStorageInternal$ fun getAllAttachmentsByCriteria(criteria: AttachmentQueryCriteria = AttachmentQueryCriteria.AttachmentsQueryCriteria()): Stream&lt;Pair&lt;String?, Attachment&gt;&gt;</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests$val corruptAttachment = NodeAttachmentService.DBAttachment(attId = id.toString(), content = attachment, version = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>MaxLineLength:AttachmentTests.kt$AttachmentTests.InitiatingFetchAttachmentsFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentB)!!), "Contract $attachmentB should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentC)!!), "Contract $attachmentC should not be trusted (no chain of trust)")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertFalse(attachmentTrustCalculator.calculate(storage.openAttachment(v2Id)!!), "Upgraded contract $v2Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentA)!!), "Contract $attachmentA should be trusted")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentB)!!), "Contract $attachmentB should inherit trust")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(attachmentId)!!), "Attachment $attachmentId should be trusted but isn't")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(signedId)!!), "Signed contract $signedId should be trusted but isn't")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(unsignedId)!!), "Unsigned contract $unsignedId should be trusted but isn't")</ID>
    <ID>MaxLineLength:AttachmentTrustCalculatorTest.kt$AttachmentTrustCalculatorTest$assertTrue(attachmentTrustCalculator.calculate(storage.openAttachment(v1Id)!!), "Initial attachment $v1Id should not be trusted")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.error("$msg skipped, network parameters not retrieved, could not determine node base directory due to system property $NODE_BASE_DIR_KEY being not set.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.info("$msg using network parameters from $path, whitelistedContractImplementations: ${networkParameters.whitelistedContractImplementations}.")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$logger.warn("Several versions based on whitelistedContractImplementations position are available: ${versions.toSet()}. $updateVersionMsg")</ID>
    <ID>MaxLineLength:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$val versions = networkParameters.whitelistedContractImplementations.values.map { it.indexOfFirst { aid -&gt; aid.toString() == attachmentId } }.filter { it &gt;= 0 }</ID>
    <ID>MaxLineLength:AttachmentWithContext.kt$AttachmentWithContext$"This AttachmentWithContext was not initialised properly. Please ensure all Corda contracts extending existing Corda contracts also implement the Contract base class."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$(path == "meta-inf/services/net.corda.core.serialization.serializationwhitelist") -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$else -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$path.startsWith("meta-inf/services") -&gt; true</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader$targetPlatformVersion &lt; 4 &amp;&amp; ignoreDirectories.any { path.startsWith(it) } -&gt; false</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoader${ // Make some preliminary checks to ensure that we're not loading invalid attachments. // All attachments need to be valid JAR or ZIP files. for (attachment in attachments) { if (!isZipOrJar(attachment)) throw TransactionVerificationException.InvalidAttachmentException(sampleTxId, attachment.id) } // Until we have a sandbox to run untrusted code we need to make sure that any loaded class file was whitelisted by the node administrator. val untrusted = attachments .filter(::containsClasses) .filterNot(isAttachmentTrusted) .map(Attachment::id) if (untrusted.isNotEmpty()) { log.warn("Cannot verify transaction $sampleTxId as the following attachment IDs are untrusted: $untrusted." + "You will need to manually install the CorDapp to whitelist it for use. " + "Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue.") throw TransactionVerificationException.UntrustedAttachmentsException(sampleTxId, untrusted) } // Enforce the no-overlap and package ownership rules. checkAttachments(attachments) }</ID>
    <ID>MaxLineLength:AttachmentsClassLoader.kt$AttachmentsClassLoaderBuilder$ fun &lt;T&gt; withAttachmentsClassloaderContext(attachments: List&lt;Attachment&gt;, params: NetworkParameters, txId: SecureHash, isAttachmentTrusted: (Attachment) -&gt; Boolean, parent: ClassLoader = ClassLoader.getSystemClassLoader(), block: (ClassLoader) -&gt; T): T</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$val cordappProviderImpl = CordappProviderImpl(cordappLoaderForPackages(listOf("net.corda.nodeapi.internal")), MockCordappConfigProvider(), MockAttachmentStorage())</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests.AttachmentDummyContract.Companion$const val ATTACHMENT_PROGRAM_ID = "net.corda.nodeapi.internal.AttachmentsClassLoaderStaticContractTests\$AttachmentDummyContract"</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed by a trusted uploader - intersection of keys match existing attachment`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Allow loading an untrusted contract jar if another attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if it is signed by a blacklisted key even if there is another attachment signed by the same keys that is trusted`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$@Test fun `Cannot load an untrusted contract jar if no other attachment exists that was signed with the same keys and uploaded by a trusted uploader`()</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("file1.txt", "same data", "file2.txt", "same other data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("meta-inf/services/com.example.something", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att1 = importAttachment(fakeAttachment("meta-inf/services/net.corda.core.serialization.SerializationWhitelist", "some data").inputStream(), "app", "file1.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("file1.txt", "same data", "file3.txt", "same totally different").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("meta-inf/services/com.example.something", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("meta-inf/services/net.corda.core.serialization.SerializationWhitelist", "some other data").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val att2 = importAttachment(fakeAttachment("net/corda/finance/contracts/isolated/AnotherDummyContract\$State.class", "some attackdata").inputStream(), "app", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val trustedClassJar = importAttachment(fakeAttachment("/com/example/something/VirtuousClass.class", "some other data").inputStream(), "app", "file3.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val untrustedClassJar = importAttachment(fakeAttachment("/com/example/something/MaliciousClass.class", "some malicious data").inputStream(), "untrusted", "file2.jar")</ID>
    <ID>MaxLineLength:AttachmentsClassLoaderTests.kt$AttachmentsClassLoaderTests$val untrustedResourceJar = importAttachment(fakeAttachment("file2.txt", "some malicious data").inputStream(), "untrusted", "file1.jar")</ID>
    <ID>MaxLineLength:AuthDBTests.kt$UsersDB$private</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$override</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.Companion$return Proxy.newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.PermissionsEnforcingInvocationHandler$override fun invoke(proxy: Any, method: Method, arguments: Array&lt;out Any?&gt;?)</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy.PermissionsEnforcingInvocationHandler$private</ID>
    <ID>MaxLineLength:AuthenticatedRpcOpsProxy.kt$private fun &lt;RESULT&gt; guard(methodName: String, context: () -&gt; RpcAuthContext, action: () -&gt; RESULT)</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester$val notary = serviceHub.networkMapCache.notaryIdentities.first() // TODO We should pass the notary as a parameter to the flow, not leave it to random choice.</ID>
    <ID>MaxLineLength:AutoOfferFlow.kt$AutoOfferFlow.Requester$val otherParty = excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, dealToBeOffered.participants)).keys.single()</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService : CryptoService</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$/** * JKS keystore does not support storage for secret keys, so the existing keystore cannot be re-used. * JCEKS keystore supports storage of symmetric keys according to the spec, but there are several issues around classloaders and deserialization filtering (see links below). * - https://stackoverflow.com/questions/49990904/what-is-the-cause-of-java-security-unrecoverablekeyexception-rejected-by-the-j * - https://stackoverflow.com/questions/50393533/java-io-ioexception-invalid-secret-key-format-when-opening-jceks-key-store-wi * Thus, PKCS12 is used for storing the wrapping key. */ private val wrappingKeyStore: KeyStore by lazy { loadOrCreateKeyStore(wrappingKeyStorePath!!, certificateStore.password, "PKCS12") }</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$return ContentSignerBuilder.build(signatureScheme, privateKey, Crypto.findProvider(signatureScheme.providerName), newSecureRandom())</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$throw CryptoServiceException("Cannot generate key for alias $alias and signature scheme ${scheme.schemeCodeName} (id ${scheme.schemeNumberID})", e)</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$val privateKey = cipher.unwrap(wrappedPrivateKey.keyMaterial, keyAlgorithmFromScheme(wrappedPrivateKey.signatureScheme), Cipher.PRIVATE_KEY) as PrivateKey</ID>
    <ID>MaxLineLength:BCCryptoService.kt$BCCryptoService$wrappingKeyStore.setEntry(alias, KeyStore.SecretKeyEntry(wrappingKey), KeyStore.PasswordProtection(certificateStore.entryPassword.toCharArray()))</ID>
    <ID>MaxLineLength:BCCryptoServiceTests.kt$BCCryptoServiceTests$private</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:BFTNotaryServiceTests.kt$BFTNotaryServiceTests.Companion$fun startBftClusterAndNode(clusterSize: Int, mockNet: InternalMockNetwork, exposeRaces: Boolean = false): Pair&lt;Party, TestStartedNode&gt;</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart$Client : SingletonSerializeAsToken</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client$private val sessionTable = (proxy.communicationSystem as NettyClientServerCommunicationSystemClientSide).declaredField&lt;Map&lt;Int, NettyClientServerSession&gt;&gt;("sessionTable").value</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Client${ // TODO: Hopefully we only need to wait for the client's initial connection to the cluster, and this method can be moved to some startup code. // TODO: Investigate ConcurrentModificationException in this method. while (true) { val inactive = sessionTable.entries.mapNotNull { if (it.value.channel.isActive) null else it.key } if (inactive.isEmpty()) break log.info("Client-replica channels not yet active: $clientId to $inactive") Thread.sleep((inactive.size * 100).toLong()) } }</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.CordaServiceReplica$private</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val (committedStates, requests) = bytes.deserialize&lt;Pair&lt;LinkedHashMap&lt;StateRef, SecureHash&gt;, List&lt;PersistentUniquenessProvider.Request&gt;&gt;&gt;()</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:BFTSmart.kt$BFTSmart.Replica.&lt;no name provided&gt;$if (exposeStartupRace) Thread.sleep(20000)</ID>
    <ID>MaxLineLength:BFTSmartConfigInternal.kt$BFTSmartConfigInternal : PathManager</ID>
    <ID>MaxLineLength:BFTSmartConfigInternal.kt$BFTSmartConfigInternal$val systemConfig = String.format(javaClass.getResource("system.config.printf").readText(), n, maxFaultyReplicas(n), if (debug) 1 else 0, (0 until n).joinToString(","))</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$?:</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService$CommittedState : BaseComittedState</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$private</ID>
    <ID>MaxLineLength:BFTSmartNotaryService.kt$BFTSmartNotaryService.Replica$val response = verifyAndCommitTx(commitRequest.payload.coreTransaction, commitRequest.callerIdentity, commitRequest.payload.requestSignature)</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$?:</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$rpc.startFlow(::CashIssueAndPaymentFlow, params.amount, issuerBankPartyRef, issueToParty, anonymous, notaryParty).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:BankOfCordaWebApi.kt$BankOfCordaWebApi$rpc.wellKnownPartyFromX500Name(params.issuerBankName) ?: return Response.status(Response.Status.FORBIDDEN).entity("Unable to locate ${params.issuerBankName} in identity service").build()</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$"Notary ($notaryParty) specified by the transaction is not on the network parameter whitelist: [${notaryWhitelist.joinToString()}]"</ID>
    <ID>MaxLineLength:BaseTransactions.kt$FullTransaction$/** * Network parameters that were in force when this transaction was created. Resolved from the hash of network parameters on the corresponding * wire transaction. */ abstract val networkParameters: NetworkParameters?</ID>
    <ID>MaxLineLength:BasicHSMKeyManagementService.kt$BasicHSMKeyManagementService$require(it.private is AliasPrivateKey) { "${this.javaClass.name} supports AliasPrivateKeys only, but ${it.private.algorithm} key was found" }</ID>
    <ID>MaxLineLength:BlobInspector.kt$BlobInspector$@Option(names = ["--input-format"], paramLabel = "type", description = ["Input format. If the file can't be decoded with the given value it's auto-detected, so you should never normally need to specify this. Possible values: [BINARY, HEX, BASE64]"])</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests$val logFile = logFolder.list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() }</ID>
    <ID>MaxLineLength:BootTests.kt$BootTests.ObjectInputStreamFlow$val data = ByteArrayOutputStream().apply { ObjectOutputStream(this).use { it.writeObject(object : Serializable {}) } }.toByteArray()</ID>
    <ID>MaxLineLength:BootstrapperView.kt$BootstrapperView$return Pair(mapOf(Constants.REGION_ARG_NAME to ChoiceDialog&lt;Region&gt;(Region.EUROPE_WEST, Region.values().toList().sortedBy { it.name() }).showAndWait().get().name()), networkName1)</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$bridgeManager.deployBridge(controlMessage.bridgeInfo.queueName, controlMessage.bridgeInfo.targets, controlMessage.bridgeInfo.legalNames.toSet())</ID>
    <ID>MaxLineLength:BridgeControlListener.kt$BridgeControlListener$val startupMessage = BridgeControl.BridgeToNodeSnapshotRequest(bridgeId).serialize(context = SerializationDefaults.P2P_CONTEXT).bytes</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$Delete : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl$NodeToBridgeSnapshot : BridgeControl</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeControl.NodeToBridgeSnapshot$@CordaSerializable data</ID>
    <ID>MaxLineLength:BridgeControlMessages.kt$BridgeEntry</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule : BaseBrokerJaasLoginModule</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$@Suppress("DEPRECATION") // should use java.security.cert.X509Certificate private</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$CertificateChainCheckPolicy.LeafMustMatch.createCheck(nodeJaasConfig.keyStore, nodeJaasConfig.trustStore).checkCertificateChain(certificates!!)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$CertificateChainCheckPolicy.RootMustMatch.createCheck(p2pJaasConfig!!.keyStore, p2pJaasConfig!!.trustStore).checkCertificateChain(certificates!!)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$fun requireTls(certificates: Array&lt;javax.security.cert.X509Certificate&gt;?)</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$if (e is IllegalArgumentException &amp;&amp; e.stackTrace.any { it.className == "org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASL" }) { log.trace("SASL Login failed.") } else { log.warn("Login failed: ${e.message}") }</ID>
    <ID>MaxLineLength:BrokerJaasLoginModule.kt$BrokerJaasLoginModule${ // This is a known problem, so we swallow this exception. A peer will attempt to connect without presenting client certificates during SASL if (e is IllegalArgumentException &amp;&amp; e.stackTrace.any { it.className == "org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASL" }) { log.trace("SASL Login failed.") } else { log.warn("Login failed: ${e.message}") } if (e is LoginException) { throw e } else { throw FailedLoginException(e.message) } }</ID>
    <ID>MaxLineLength:BuiltNode.kt$BuiltNode$val nodeConfig: NodeConfiguration</ID>
    <ID>MaxLineLength:BusinessCalendar.kt$BusinessCalendar.Companion$dcbDay == DayCountBasisDay.D30 &amp;&amp; dcbYear == DayCountBasisYear.Y360 -&gt; ((endDate.year - startDate.year) * 360.0 + (endDate.monthValue - startDate.monthValue) * 30.0 + endDate.dayOfMonth - startDate.dayOfMonth).toInt()</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytes$/** * The bytes are always cloned so that this object becomes immutable. This has been done * to prevent tampering with entities such as [net.corda.core.crypto.SecureHash] and [net.corda.core.contracts.PrivacySalt], as well as * preserve the integrity of our hash constants [net.corda.core.crypto.SecureHash.zeroHash] and [net.corda.core.crypto.SecureHash.allOnesHash]. * * Cloning like this may become a performance issue, depending on whether or not the JIT * compiler is ever able to optimise away the clone. In which case we may need to revisit * this later. */ final override val bytes: ByteArray = bytes get() = field.clone()</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(offset &gt;= 0 &amp;&amp; offset &lt; bytes.size) { "Offset must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:ByteArrays.kt$OpaqueBytesSubSequence$require(size &gt;= 0 &amp;&amp; offset + size &lt;= bytes.size) { "Sub-sequence size must be greater than or equal to 0, and less than the size of the backing array" }</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", BusinessCalendar.parseDateFromString("2017-03-01").plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", BusinessCalendar.parseDateFromString("2017-03-01"), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cap.kt$Cap$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("6M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Caplet.kt$Caplet$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("6M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:Cash.kt$ @Throws(IllegalArgumentException::class) internal inline fun &lt;reified T : MoveCommand&gt; verifyFlattenedMoveCommand(inputs: List&lt;OwnableState&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;) : MoveCommand</ID>
    <ID>MaxLineLength:Cash.kt$Cash$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:Cash.kt$Cash$val inputAmount = inputs.sumCashOrNull() ?: throw IllegalArgumentException("there is at least one cash input for this group")</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun issuedBy(party: AbstractParty)</ID>
    <ID>MaxLineLength:Cash.kt$Cash.State$infix fun withDeposit(deposit: PartyAndReference): Cash.State</ID>
    <ID>MaxLineLength:Cash.kt$internal</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$AbstractCashSelection .getInstance { serviceHub.jdbcSession().metaData } .unconsumedCashStatesForSpending(serviceHub, amount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashExitFlow.kt$CashExitFlow$val changeOwner = exitStates.asSequence().map { it.state.data.owner }.toSet().firstOrNull() ?: throw InsufficientBalanceException(amount)</ID>
    <ID>MaxLineLength:CashIssueAndPaymentFlow.kt$CashIssueAndPaymentFlow$constructor(request: IssueAndPaymentRequest) : this(request.amount, request.issueRef, request.recipient, request.anonymous, request.notary, tracker())</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(amount: Amount&lt;Currency&gt;, recipient: Party, anonymous: Boolean, notary: Party) : this(amount, recipient, anonymous, tracker(), notary = notary)</ID>
    <ID>MaxLineLength:CashPaymentFlow.kt$CashPaymentFlow$constructor(request: PaymentRequest) : this(request.amount, request.recipient, request.anonymous, tracker(), request.issuerConstraint, request.notary)</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CashSchemaV1.kt$CashSchemaV1.PersistentCashState$@Table(name = "contract_cash_states", indexes = [Index(name = "ccy_code_idx", columnList = "ccy_code"), Index(name = "pennies_idx", columnList = "pennies")])</ID>
    <ID>MaxLineLength:CashSelectionH2Impl.kt$CashSelectionH2Impl$override</ID>
    <ID>MaxLineLength:CashSelectionH2ImplTest.kt$CashSelectionH2ImplTest$val request = CashPaymentFlow.PaymentRequest(1.POUNDS, node.info.legalIdentities[0], true, setOf(node.info.legalIdentities[0], mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashSelectionPostgreSQLImpl.kt$CashSelectionPostgreSQLImpl$override</ID>
    <ID>MaxLineLength:CashSelectionSQLServerImpl.kt$CashSelectionSQLServerImpl$override</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$AbstractCashSelection .getInstance { node.services.jdbcSession().metaData } .unconsumedCashStatesForSpending(node.services, exitedAmount, setOf(issuer.party), builder.notary, builder.lockId, setOf(issuer.reference))</ID>
    <ID>MaxLineLength:CashSelectionTest.kt$CashSelectionTest$issuance.addOutputState(TransactionState(Cash.State(it, nodeIdentity), "net.corda.finance.contracts.asset.Cash", mockNet.defaultNotaryIdentity))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$Cash().generateIssue(this, 100.DOLLARS `issued by` miniCorp.ref(12, 34), owner = AnonymousParty(alice.publicKey), notary = dummyNotary.party)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$CashUtils.generateSpend(ourServices, tx, 80.DOLLARS, ourServices.myInfo.singleIdentityAndCert(), alice.party, setOf(miniCorp.party))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$TransactionState(Cash.State(amount `issued by` issuer.ref(depositRef), ourIdentity), Cash.PROGRAM_ID, dummyNotary.party, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState.state.data.copy(owner = miniCorpAnonymised, amount = 10.DOLLARS `issued by` defaultIssuer), wtx.outputs[0].data)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState0.state.data.copy(owner = miniCorpAnonymised, amount = 500.DOLLARS `issued by` defaultIssuer), wtx.getOutput(0))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$assertEquals(vaultState0.state.data.copy(owner = miniCorpAnonymised, amount = 500.DOLLARS `issued by` defaultIssuer), wtx.outputs[1].data)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$makeTestIdentityService(megaCorp.identity, miniCorp.identity, dummyCashIssuer.identity, dummyNotary.identity, myself.identity)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, "MEGA_CORP cash 2", "MEGA_CORP cash".output&lt;Cash.State&gt;().copy(owner = AnonymousParty(alice.publicKey)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, inState.copy(owner = AnonymousParty(bob.publicKey), amount = 2000.DOLLARS `issued by` defaultIssuer))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)) issuedBy miniCorp.party)</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$output(Cash.PROGRAM_ID, issuerInState.copy(owner = miniCorp.party, amount = issuerInState.amount - (200.DOLLARS `issued by` defaultIssuer)))</ID>
    <ID>MaxLineLength:CashTests.kt$CashTests$val expectedChange = cashStates[0].state.data.copy(amount = cashStates[0].state.data.amount.copy(quantity = expectedChangeAmount), owner = actualChange.owner)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$@Deprecated("Our identity should be specified", replaceWith = ReplaceWith("generateSpend(services, tx, amount, to, ourIdentity, onlyFromParties)"))</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$fun deriveState(txState: TransactionState&lt;Cash.State&gt;, amt: Amount&lt;Issued&lt;Currency&gt;&gt;, owner: AbstractParty): TransactionState&lt;Cash.State&gt;</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$return generateSpend(services, tx, listOf(PartyAndAmount(to, amount)), services.myInfo.legalIdentitiesAndCerts.single(), onlyFromParties)</ID>
    <ID>MaxLineLength:CashUtils.kt$CashUtils$val changeIdentity: AbstractParty = if (anonymous) services.keyManagementService.freshKeyAndCert(ourIdentity, revocationEnabled).party.anonymise() else ourIdentity.party</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Assemble the Issuer node. */ val treeItem = TreeItem(ViewerNode.IssuerNode(issuer.owningKey.toKnownParty().value ?: issuer, equivSumAmount, memberStates))</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$/** * Next we create subgroups based on currency. [memberStates] here is all states holding currency [currency] issued by [issuer] above. * Note that these states will not be displayed in the TreeTable, but rather in the side pane if the user clicks on the row. */ val currencyNodes = AggregatedList(memberStates, { it.state.data.amount.token.product }) { currency, groupedMemberStates -&gt; /** * We sum the states in the subgroup, to be displayed in the "Local Currency" column */ val amounts = groupedMemberStates.map { it.state.data.amount.withoutIssuer() } val sumAmount = amounts.foldObservable(Amount(0, currency), Amount&lt;Currency&gt;::plus) /** * We exchange the sum to the reporting currency, to be displayed in the "&lt;currency&gt; Equiv" column. */ val equivSumAmount = EasyBind.combine(sumAmount, reportingExchange) { sum, exchange -&gt; exchange.second(sum) } /** * Finally assemble the actual TreeTable Currency node. */ TreeItem(ViewerNode.CurrencyNode(sumAmount, equivSumAmount, groupedMemberStates)) }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$is ViewerNode.IssuerNode -&gt; SimpleStringProperty(node.issuer.nameOrNull()?.let { PartyNameFormatter.short.format(it) } ?: "Anonymous")</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer$itemsProperty().bind(selectedNode.map { it?.states?.map { StateRow(LocalDateTime.now(), it) } ?: FXCollections.emptyObservableList() })</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.CashWidget${ // If update arrived in very close succession to the previous one - kill the last point received to eliminate un-necessary noise on the graph. if(lastTimeStamp != null &amp;&amp; currentTimeStamp - lastTimeStamp.toLong() &lt; 1.seconds.toMillis()) { data.safelyTransition { remove(size - 1, size) } } // Add a new data point. data(currentTimeStamp, currAmount) // Limit population of data points to make graph painting faster. data.safelyTransition { if (size &gt; 300) remove(0, 1) } }</ID>
    <ID>MaxLineLength:CashViewer.kt$CashViewer.StateRowGraphic$val resolvedIssuer: AbstractParty = stateRow.stateAndRef.resolveIssuer().value ?: stateRow.stateAndRef.state.data.amount.token.issuer.party</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val confidentialCert = X509Utilities.createCertificate(CertificateType.CONFIDENTIAL_LEGAL_IDENTITY, legalIDCertFromNodeCA, legalIDKeyPairFromNodeCA, nodeSubject, confidentialKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val doormanCert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, intermediateRootCert, intermediateRootKeyPair, doormanSubject, doormanKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val intermediateRootCert = X509Utilities.createCertificate(CertificateType.ROOT_CA, rootCert, rootKeyPair, intermediateRootSubject, intermediateRootKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val legalIDCertFromDoorman = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, doormanCert, doormanKeyPair, nodeSubject, legalIDKeyPairFromDoorman.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val legalIDCertFromNodeCA = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCACert, nodeCAKeyPair, nodeSubject, legalIDKeyPairFromNodeCA.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val nodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, doormanCert, doormanKeyPair, nodeSubject, nodeCAKeyPair.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val tlsCertFromDoorman = X509Utilities.createCertificate(CertificateType.TLS, doormanCert, doormanKeyPair, nodeSubject, tlsKeyPairFromDoorman.public)</ID>
    <ID>MaxLineLength:CertRoleTests.kt$CertRoleTests$val tlsCertFromNodeCA = X509Utilities.createCertificate(CertificateType.TLS, nodeCACert, nodeCAKeyPair, nodeSubject, tlsKeyPairFromNodeCA.public)</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$private</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val (nodeCert, nodeKeys) = nodeKeyStore.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_CA, nodeKeyStore.entryPassword) }</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val newTlsCert = replaceCrlDistPointCaCertificate(tlsCert, CertificateType.TLS, nodeKeys, tlsCrlDistPoint, X500Name.getInstance(ROOT_CA.certificate.subjectX500Principal.encoded))</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val nodeCertChain = listOf(newNodeCert, INTERMEDIATE_CA.certificate, *nodeKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }.drop(2).toTypedArray())</ID>
    <ID>MaxLineLength:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val sslCertChain = listOf(newTlsCert, newNodeCert, INTERMEDIATE_CA.certificate, *sslKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) }.drop(3).toTypedArray())</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromFile(storePath: Path, password: String, entryPassword: String, createNew: Boolean): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromInputStream(stream: InputStream, password: String, entryPassword: String): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun fromResource(storeResourceName: String, password: String, entryPassword: String, classLoader: ClassLoader = Thread.currentThread().contextClassLoader): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$CertificateStore.Companion$fun of(store: X509KeyStore, password: String, entryPassword: String): CertificateStore</ID>
    <ID>MaxLineLength:CertificateStore.kt$DelegatingCertificateStore : CertificateStore</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$keyStoreFileName: String = KeyStore.DEFAULT_STORE_FILE_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$keyStorePassword: String = KeyStore.DEFAULT_STORE_PASSWORD</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$return withCertificatesDirectory(baseDirectory / certificatesDirectoryName, keyStoreFileName, keyStorePassword, keyPassword, trustStoreFileName, trustStorePassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$trustStoreFileName: String = TrustStore.DEFAULT_STORE_FILE_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.Companion$val trustStore = FileBasedCertificateStoreSupplier(certificatesDirectory / trustStoreFileName, trustStorePassword, trustStoreKeyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$@JvmStatic fun withCertificatesDirectory(certificatesDirectory: Path, password: String = DEFAULT_STORE_PASSWORD, keyPassword: String = password, certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME): FileBasedCertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.KeyStore.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$@JvmStatic fun withBaseDirectory(baseDirectory: Path, password: String = DEFAULT_STORE_PASSWORD, keyPassword: String = DEFAULT_KEY_PASSWORD, certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME, certificateStoreFileName: String = DEFAULT_STORE_FILE_NAME): FileBasedCertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$keyPassword: String = DEFAULT_KEY_PASSWORD</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.P2P.TrustStore.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$certificatesDirectoryName: String = DEFAULT_CERTIFICATES_DIRECTORY_NAME</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$keyPassword: String = password</ID>
    <ID>MaxLineLength:CertificateStoreStubs.kt$CertificateStoreStubs.Signing.Companion$return FileBasedCertificateStoreSupplier(baseDirectory / certificatesDirectoryName / certificateStoreFileName, password, keyPassword)</ID>
    <ID>MaxLineLength:CertificateStoreSupplier.kt$FileBasedCertificateStoreSupplier : CertificateStoreSupplier</ID>
    <ID>MaxLineLength:CertificatesUtils.kt$fun saveToKeyStore(keyStorePath: Path, rpcKeyPair: KeyPair, selfSignCert: X509Certificate, password: String = "password", alias: String = "Key"): Path</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointAgent.Companion$println("Running Checkpoint agent with following arguments: instrumentClassname=$instrumentClassname, instrumentType=$instrumentType, minimumSize=$minimumSize, maximumSize=$maximumSize, graphDepth=$graphDepth, printOnce=$printOnce\n")</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$if (parameterTypeNames == listOf("com.esotericsoftware.kryo.Kryo", "com.esotericsoftware.kryo.io.Input", "java.lang.Class")) { if (method.isEmpty) continue log.debug { "Instrumenting on read: ${clazz.name}" } method.insertBefore("$hookClassName.${this::readEnter.name}($2, $3);") method.insertAfter("$hookClassName.${this::readExit.name}($2, $3, (java.lang.Object)\$_);") return clazz } else if (parameterTypeNames == listOf("com.esotericsoftware.kryo.io.Input", "java.lang.Object")) { if (method.isEmpty) continue log.debug { "Instrumenting on field read: ${clazz.name}" } method.insertBefore("$hookClassName.${this::readFieldEnter.name}((java.lang.Object)this);") method.insertAfter("$hookClassName.${this::readFieldExit.name}($2, (java.lang.Object)this);") return clazz }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$CheckpointHook$if (parameterTypeNames == listOf("com.esotericsoftware.kryo.Kryo", "com.esotericsoftware.kryo.io.Output", "java.lang.Object")) { if (method.isEmpty) continue log.debug { "Instrumenting on write: ${clazz.name}" } method.insertBefore("$hookClassName.${this::writeEnter.name}($2, $3);") method.insertAfter("$hookClassName.${this::writeExit.name}($2, $3);") return clazz }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$fun readTrees(events: List&lt;StatsEvent&gt;, index: Int, idMap: IdentityHashMap&lt;Any, IdentityInfo&gt;): Pair&lt;Int, List&lt;Pair&lt;StatsInfo, IdentityInfo&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.Enter: ${exit.value} (hashcode:${exit.value!!.hashCode()}) (count:${idMap[exit.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.Exit: ${event.value} (hashcode:${event.value!!.hashCode()}) (count:${idMap[event.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointAgent.kt$log.debug { "Skipping repeated StatsEvent.ObjectField: ${event.value} (hashcode:${event.value.hashCode()}) (count:${idMap[event.value]?.refCount})" }</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper</ID>
    <ID>MaxLineLength:CheckpointDumper.kt$CheckpointDumper.CheckpointDumperBeanModifier$it.type.isTypeOrSubTypeOf(ProgressTracker::class.java) || it.name == "_stateMachine" || it.name == "deprecatedPartySessionMap"</ID>
    <ID>MaxLineLength:CheckpointDumperTest.kt$CheckpointDumperTest$val checkpoint = Checkpoint.create(InvocationContext.shell(), FlowStart.Explicit, logic.javaClass, frozenLogic, myself.identity.party, SubFlowVersion.CoreFlow(version), false) .getOrThrow()</ID>
    <ID>MaxLineLength:CheckpointSerializationScheme.kt$CheckpointSerializationContextImpl$override val encodingWhitelist: EncodingWhitelist = NullEncodingWhitelist</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException$FlowVersionIncompatibleException : CheckpointIncompatibleException</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException$SubFlowCoreVersionIncompatibleException : CheckpointIncompatibleException</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CannotBeDeserialisedException$"Found checkpoint that cannot be deserialised using the current Corda version. Please revert to the previous version of Corda, "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.CordappNotInstalledException$"Found checkpoint for CorDapp that is no longer installed. Specifically, could not find class $classNotFound. Please install the "</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointIncompatibleException.SubFlowCoreVersionIncompatibleException$"version of Corda (version $oldVersion), drain your node (see https://docs.corda.net/upgrading-cordapps.html#flow-drains), and try again."</ID>
    <ID>MaxLineLength:CheckpointVerifier.kt$CheckpointVerifier$throw CheckpointIncompatibleException.FlowVersionIncompatibleException(subFlow.flowClass, matchingCordapp, subFlowVersion.corDappHash)</ID>
    <ID>MaxLineLength:ClassCarpenterTest.kt$ClassCarpenterTest$ @Test fun `superclasses with double-size primitive constructor parameters`()</ID>
    <ID>MaxLineLength:ClassLoadingUtils.kt$ fun &lt;T: Any&gt; createInstancesOfClassesImplementing(@Suppress("UNUSED_PARAMETER") classloader: ClassLoader, @Suppress("UNUSED_PARAMETER") clazz: Class&lt;T&gt;): Set&lt;T&gt;</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$AbstractMutableClassWhitelist$sealed</ID>
    <ID>MaxLineLength:ClassWhitelists.kt$TransientClassWhiteList : AbstractMutableClassWhitelist</ID>
    <ID>MaxLineLength:ClearNetworkCacheCli.kt$ClearNetworkCacheCli : NodeCliCommand</ID>
    <ID>MaxLineLength:ClientRPCInfrastructureTests.kt$ClientRPCInfrastructureTests$assertEquals("Quote by Mark Twain: Clothes make the man. Naked people have little or no influence on society.", clientQuotes.take())</ID>
    <ID>MaxLineLength:ClientRpcTutorial.kt$val (transactions: List&lt;SignedTransaction&gt;, futureTransactions: Observable&lt;SignedTransaction&gt;) = proxy.internalVerifiedTransactionsFeed()</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant().minus(1.hours)), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertFalse(NodeSchedulerService.awaitWithDeadline(stoppedClock, stoppedClock.instant().minus(1.hours), future), "Should have reached deadline")</ID>
    <ID>MaxLineLength:ClockUtilsTest.kt$ClockUtilsTest$assertTrue(NodeSchedulerService.awaitWithDeadline(stoppedClock, advancedClock.instant(), future), "Should not have reached deadline")</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignatureFlow : FlowLogic</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$CollectSignaturesFlow$override val progressTracker: ProgressTracker = CollectSignaturesFlow.tracker()</ID>
    <ID>MaxLineLength:CollectSignaturesFlow.kt$SignTransactionFlow$override val progressTracker: ProgressTracker = SignTransactionFlow.tracker()</ID>
    <ID>MaxLineLength:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests.TestFlow.Initiator$val sessions = excludeHostNode(serviceHub, groupAbstractPartyByWellKnownParty(serviceHub, state.owners)).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer$private val typeNotation: TypeNotation = RestrictedType(AMQPTypeIdentifiers.nameForType(declaredType), null, emptyList(), "list", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:CollectionSerializer.kt$CollectionSerializer.Companion$fun resolveActual(actualClass: Class&lt;*&gt;, declaredTypeInformation: LocalTypeInformation.ACollection): LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandDescription</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$EnumOptionsChangedError(it.key + " on command ${old.commandName} previously accepted: $oldEnums, and now is missing $toPrint}")</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$PositionalArgumentsChangedError("Positional Parameter [ ${it.parameterName} ] has been removed from subcommand: ${old.commandName}")</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllCommandsArePresent(old: List&lt;CommandDescription&gt;, new: List&lt;CommandDescription&gt;): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$fun checkAllPositionalCharactersArePresent(old: CommandDescription, new: CommandDescription): List&lt;CliBackwardsCompatibilityValidationCheck&gt;</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$private</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$CommandLineCompatibilityChecker$val potentiallyChanged = oldAcceptableTypes.filter { newAcceptableTypes[it.key] != null &amp;&amp; newAcceptableTypes[it.key]!!.toSet() != it.value.toSet() }</ID>
    <ID>MaxLineLength:CommandLineCompatibilityUtils.kt$ParameterDescription</ID>
    <ID>MaxLineLength:CommandLineInterface.kt$CommandLineInterface$nodeAdder.addNode(context, Constants.ALPHA_NUMERIC_ONLY_REGEX.replace(it.key.toLowerCase(), ""), CordaX500Name.parse(it.value))</ID>
    <ID>MaxLineLength:CommandParsers.kt$CliParser$@Option(names = ["--add"], split = ":", description = ["The node to add. Format is &lt;Name&gt;:&lt;X500&gt;. Eg; \"Node1:O=Bank A, L=New York, C=US, OU=Org Unit, CN=Service Name\""])</ID>
    <ID>MaxLineLength:CommandParsers.kt$CliParser$@Option(names = ["-b", "--backend"], description = ["The backend to use when instantiating nodes. Valid values: LOCAL_DOCKER and AZURE."])</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$// Although kotlin is smart enough not to need these, as we are using the ICommercialPaperState, we need to declare them explicitly for use later, override fun withOwner(newOwner: AbstractParty): ICommercialPaperState</ID>
    <ID>MaxLineLength:CommercialPaper.kt$CommercialPaper.State$override fun toString()</ID>
    <ID>MaxLineLength:CommercialPaperIssueFlow.kt$CommercialPaperIssueFlow$constructor(amount: Amount&lt;Currency&gt;, issueRef: OpaqueBytes, recipient: Party, notary: Party) : this(amount, issueRef, recipient, notary, tracker())</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:CommercialPaperSchemaV1.kt$CommercialPaperSchemaV1.PersistentCommercialPaperState$@Table(name = "cp_states", indexes = [Index(name = "ccy_code_index", columnList = "ccy_code"), Index(name = "maturity_index", columnList = "maturity_instant"), Index(name = "face_value_index", columnList = "face_value")])</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric$CommercialPaperUtils.generateRedeem(builder, moveTX.tx.outRef(1), megaCorpServices, megaCorpServices.myInfo.singleIdentityAndCert())</ID>
    <ID>MaxLineLength:CommercialPaperTests.kt$CommercialPaperTestsGeneric.&lt;no name provided&gt;$override fun loadState(stateRef: StateRef): TransactionState&lt;*&gt;</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$ @JvmStatic fun generateIssue(issuance: PartyAndReference, faceValue: Amount&lt;Issued&lt;Currency&gt;&gt;, maturityDate: Instant, notary: Party): TransactionBuilder</ID>
    <ID>MaxLineLength:CommercialPaperUtils.kt$CommercialPaperUtils$ @Throws(InsufficientBalanceException::class) @JvmStatic @Suspendable fun generateRedeem(tx: TransactionBuilder, paper: StateAndRef&lt;CommercialPaper.State&gt;, services: ServiceHub, ourIdentity: PartyAndCertificate)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$ComponentGroup(SIGNERS_GROUP.ordinal, twoCommandsforKey1.map { it.signers.serialize() }.subList(0, 1))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$allCommandsNoKey1Ftx.checkCommandVisibility(DUMMY_KEY_1.public)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxInputs.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(1, ftxOneInput.filteredComponentGroups.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[NOTARY_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionA.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[OUTPUTS_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertEquals(wireTransactionCompatibleA.availableComponentGroups, wireTransactionA.availableComponentGroups)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;ComponentVisibilityException&gt; { noCommandsFtx.checkAllComponentsVisible(SIGNERS_GROUP) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertFailsWith&lt;IllegalStateException&gt; { WireTransaction(componentGroups = componentGroupsLessSigners, privacySalt = PrivacySalt()) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotEquals(wireTransactionA.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal], wireTransaction1ShuffledInputs.accessGroupMerkleRoots()[INPUTS_GROUP.ordinal])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotEquals(wireTransactionCompatibleA, wireTransactionA)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$assertNotNull(ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$private val attachmentGroup by lazy { ComponentGroup(ATTACHMENTS_GROUP.ordinal, attachments.map { it.serialize() }) } // The list is empty.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val alterSignerComponents = signerComponents.subList(0, 2) + signerComponents[1] // Third one is removed and the 2nd command is added twice.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val alterSignersHashes = wtx.accessAvailableComponentHashes()[ComponentGroupEnum.SIGNERS_GROUP.ordinal]!!.subList(0, 2) + componentHash(key1CommandsFtx.filteredComponentGroups[1].nonces[2], alterSignerComponents[2])</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxAlterSignerB = ftxConstructor.call(key1CommandsFtx.id, alterFilteredComponents, key1CommandsFtx.groupHashes.subList(0, 6) + alterMTree.hash)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxCompatibleAll = wireTransactionCompatibleA.buildFilteredTransaction(Predicate { true }) // All filtered, including the unknown component.</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastCommandAndSigners = ftxConstructor.call(key1CommandsFtx.id, updatedFilteredComponentsNoLastCommandAndSigners, key1CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val ftxNoLastSigner = ftxConstructor.call(key2CommandsFtx.id, updatedFilteredComponentsNoSignersKey2SamePMT, key2CommandsFtx.groupHashes)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val twoCommandsforKey1 = listOf(dummyCommand(DUMMY_KEY_1.public, DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_2.public), dummyCommand(DUMMY_KEY_1.public))</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey1SamePMT = listOf(key1CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests$val updatedFilteredComponentsNoSignersKey2SamePMT = listOf(key2CommandsFtx.filteredComponentGroups[0], noLastSignerGroupSamePartialTree)</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ // Filter out all of the components. val ftxNothing = wireTransactionA.buildFilteredTransaction(Predicate { false }) // Nothing filtered. // Although nothing filtered, we still receive the group hashes for the top level Merkle tree. // Note that attachments are not sent, but group hashes include the allOnesHash flag for the attachment group hash; that's why we expect +1 group hashes. assertEquals(wireTransactionA.componentGroups.size + 1, ftxNothing.groupHashes.size) ftxNothing.verify() // Include all of the components. val ftxAll = wireTransactionA.buildFilteredTransaction(Predicate { true }) // All filtered. ftxAll.verify() ftxAll.checkAllComponentsVisible(INPUTS_GROUP) ftxAll.checkAllComponentsVisible(OUTPUTS_GROUP) ftxAll.checkAllComponentsVisible(COMMANDS_GROUP) ftxAll.checkAllComponentsVisible(ATTACHMENTS_GROUP) ftxAll.checkAllComponentsVisible(NOTARY_GROUP) ftxAll.checkAllComponentsVisible(TIMEWINDOW_GROUP) ftxAll.checkAllComponentsVisible(SIGNERS_GROUP) ftxAll.checkAllComponentsVisible(PARAMETERS_GROUP) // Filter inputs only. fun filtering(elem: Any): Boolean { return when (elem) { is StateRef -&gt; true else -&gt; false } } val ftxInputs = wireTransactionA.buildFilteredTransaction(Predicate(::filtering)) // Inputs only filtered. ftxInputs.verify() ftxInputs.checkAllComponentsVisible(INPUTS_GROUP) assertEquals(1, ftxInputs.filteredComponentGroups.size) // We only add component groups that are not empty, thus in this case: the inputs only. assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) // All 3 inputs are present. assertEquals(3, ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) // And their corresponding nonces. assertNotNull(ftxInputs.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) // And the Merkle tree. // Filter one input only. fun filteringOneInput(elem: Any) = elem == inputs[0] val ftxOneInput = wireTransactionA.buildFilteredTransaction(Predicate(::filteringOneInput)) // First input only filtered. ftxOneInput.verify() assertFailsWith&lt;ComponentVisibilityException&gt; { ftxOneInput.checkAllComponentsVisible(INPUTS_GROUP) } assertEquals(1, ftxOneInput.filteredComponentGroups.size) // We only add component groups that are not empty, thus in this case: the inputs only. assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) // 1 input is present. assertEquals(1, ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) // And its corresponding nonce. assertNotNull(ftxOneInput.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) // And the Merkle tree. // The old client (receiving more component types than expected) is still compatible. val componentGroupsCompatibleA = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentGroup // A new unknown component with ordinal 100 that we cannot process. ) val wireTransactionCompatibleA = WireTransaction(componentGroupsCompatibleA, privacySalt) val ftxCompatible = wireTransactionCompatibleA.buildFilteredTransaction(Predicate(::filtering)) ftxCompatible.verify() assertEquals(ftxInputs.inputs, ftxCompatible.inputs) assertEquals(wireTransactionCompatibleA.id, ftxCompatible.id) assertEquals(1, ftxCompatible.filteredComponentGroups.size) assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.components.size) assertEquals(3, ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.nonces.size) assertNotNull(ftxCompatible.filteredComponentGroups.firstOrNull { it.groupIndex == INPUTS_GROUP.ordinal }!!.partialMerkleTree) assertNull(wireTransactionCompatibleA.networkParametersHash) assertNull(ftxCompatible.networkParametersHash) // Now, let's allow everything, including the new component type that we cannot process. val ftxCompatibleAll = wireTransactionCompatibleA.buildFilteredTransaction(Predicate { true }) // All filtered, including the unknown component. ftxCompatibleAll.verify() assertEquals(wireTransactionCompatibleA.id, ftxCompatibleAll.id) // Check we received the last element that we cannot process (backwards compatibility). assertEquals(wireTransactionCompatibleA.componentGroups.size, ftxCompatibleAll.filteredComponentGroups.size) // Hide one component group only. // Filter inputs only. fun filterOutInputs(elem: Any): Boolean { return when (elem) { is StateRef -&gt; false else -&gt; true } } val ftxCompatibleNoInputs = wireTransactionCompatibleA.buildFilteredTransaction(Predicate(::filterOutInputs)) ftxCompatibleNoInputs.verify() assertFailsWith&lt;ComponentVisibilityException&gt; { ftxCompatibleNoInputs.checkAllComponentsVisible(INPUTS_GROUP) } assertEquals(wireTransactionCompatibleA.componentGroups.size - 1, ftxCompatibleNoInputs.filteredComponentGroups.size) assertEquals(wireTransactionCompatibleA.componentGroups.map { it.groupIndex }.max()!!, ftxCompatibleNoInputs.groupHashes.size - 1) }</ID>
    <ID>MaxLineLength:CompatibleTransactionTests.kt$CompatibleTransactionTests${ val groups = createComponentGroups(inputs, outputs, commands, attachments, notary, timeWindow, emptyList(), null) val wireTransactionOldConstructor = WireTransaction(groups, privacySalt) assertEquals(wireTransactionA, wireTransactionOldConstructor) // Malformed tx - attachments is not List&lt;SecureHash&gt;. For this example, we mistakenly added input-state (StateRef) serialised objects with ATTACHMENTS_GROUP.ordinal. val componentGroupsB = listOf( inputGroup, outputGroup, commandGroup, ComponentGroup(ATTACHMENTS_GROUP.ordinal, inputGroup.components), notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsB, privacySalt).attachments.toList() } // Malformed tx - duplicated component group detected. val componentGroupsDuplicatedCommands = listOf( inputGroup, outputGroup, commandGroup, // First commandsGroup. commandGroup, // Second commandsGroup. notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsDuplicatedCommands, privacySalt) } // Malformed tx - inputs is not a serialised object at all. val componentGroupsC = listOf( ComponentGroup(INPUTS_GROUP.ordinal, listOf(OpaqueBytes(ByteArray(8)))), outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup ) assertFails { WireTransaction(componentGroupsC, privacySalt) } val componentGroupsCompatibleA = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentGroup // A new unknown component with ordinal 100 that we cannot process. ) // The old client (receiving more component types than expected) is still compatible. val wireTransactionCompatibleA = WireTransaction(componentGroupsCompatibleA, privacySalt) assertEquals(wireTransactionCompatibleA.availableComponentGroups, wireTransactionA.availableComponentGroups) // The known components are the same. assertNotEquals(wireTransactionCompatibleA, wireTransactionA) // But obviously, its Merkle root has changed Vs wireTransactionA (which doesn't include this extra component). // The old client will throw if receiving an empty component (even if this is unknown). val componentGroupsCompatibleEmptyNew = listOf( inputGroup, outputGroup, commandGroup, notaryGroup, timeWindowGroup, signersGroup, newUnknownComponentEmptyGroup // A new unknown component with ordinal 101 that we cannot process. ) assertFails { WireTransaction(componentGroupsCompatibleEmptyNew, privacySalt) } }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$@Test() fun `composite key validation with graph cycle detection`()</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private val bobSignature by lazy { bobKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(bobPublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$private val charlieSignature by lazy { charlieKey.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(charliePublicKey).schemeNumberID))) }</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val EdSignature = keyPairEd.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairEd.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val K1Signature = keyPairK1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairK1.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val R1Signature = keyPairR1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairR1.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val RSASignature = keyPairRSA.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairRSA.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val SPSignature = keyPairSP.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairSP.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val brokenBobSignature = TransactionSignature(aliceSignature.bytes, bobSignature.by, SignatureMetadata(1, Crypto.findSignatureScheme(bobSignature.by).schemeNumberID))</ID>
    <ID>MaxLineLength:CompositeKeyTests.kt$CompositeKeyTests$val compositeKey = CompositeKey.Builder().addKeys(keyPairRSA.public, keyPairK1.public, keyPairR1.public, keyPairEd.public, keyPairSP.public).build() as CompositeKey</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw InvalidKeyException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature$throw SignatureException("Composite signatures must be assembled independently from signatures provided by the component private keys")</ID>
    <ID>MaxLineLength:CompositeSignature.kt$CompositeSignature.Companion$@JvmStatic fun getService(provider: Provider)</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$assertThatThrownBy { configuration.parseAs&lt;TypedConfiguration&gt;() }</ID>
    <ID>MaxLineLength:ConfigParsingTest.kt$ConfigParsingTest$testPropertyType&lt;X500PrincipalData, X500PrincipalListData, X500Principal&gt;(X500Principal("C=US, L=New York, CN=Corda Root CA, OU=Corda, O=R3 HoldCo LLC"), X500Principal("O=Bank A,L=London,C=GB"), valuesToString = true)</ID>
    <ID>MaxLineLength:ConfigSections.kt$BFTSmartConfigSpec$return valid(BFTSmartConfig(configuration[replicaId], configuration[clusterAddresses], configuration[debug], configuration[exposeRaces]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val initialiseAppSchema by enum(SchemaInitializationType::class).optional().withDefaultValue(DatabaseConfig.Defaults.initialiseAppSchema)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$private val transactionIsolationLevel by enum(TransactionIsolationLevel::class).optional().withDefaultValue(DatabaseConfig.Defaults.transactionIsolationLevel)</ID>
    <ID>MaxLineLength:ConfigSections.kt$DatabaseConfigSpec$return valid(DatabaseConfig(configuration[initialiseSchema], configuration[initialiseAppSchema], configuration[transactionIsolationLevel], configuration[exportHibernateJMXStatistics], configuration[mappedSchemaCacheSize]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NetworkServicesConfigSpec$return valid(NetworkServicesConfig(configuration[doormanURL], configuration[networkMapURL], configuration[pnm], configuration[inferred]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NodeRpcSettingsSpec$return valid(NodeRpcSettings(configuration[address], configuration[adminAddress], configuration[standAloneBroker], configuration[useSsl], configuration[ssl]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$NotaryConfigSpec$return valid(NotaryConfig(configuration[validating], configuration[serviceLegalName], configuration[className], configuration[etaMessageThresholdSeconds], configuration[extraConfig], configuration[raft], configuration[bftSMaRt]))</ID>
    <ID>MaxLineLength:ConfigSections.kt$SSHDConfigurationSpec$override fun parseValid(configuration: Config): Valid&lt;SSHDConfiguration&gt;</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec$dataSource.type == AuthDataSourceType.INMEMORY &amp;&amp; options?.cache != null -&gt; badValue("no cache supported for \"INMEMORY\" data provider")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$private val passwordEncryption by enum(PasswordEncryption::class).optional().withDefaultValue(SecurityConfiguration.AuthService.DataSource.Defaults.passwordEncryption)</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$type == AuthDataSourceType.DB &amp;&amp; (users != null || connection == null) -&gt; badValue("\"DB\" data source type requires \"connection\" and cannot specify \"users\"")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.DataSourceSpec$type == AuthDataSourceType.INMEMORY &amp;&amp; (users == null || connection != null) -&gt; badValue("\"INMEMORY\" data source type requires \"users\" and cannot specify \"connection\"")</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private val expireAfterSecs by long().mapValid { value -&gt; if (value &gt;= 0) validValue(value) else badValue("cannot be less than 0'") }</ID>
    <ID>MaxLineLength:ConfigSections.kt$SecurityConfigurationSpec.AuthServiceSpec.OptionsSpec.CacheSpec$private val maxEntries by long().mapValid { value -&gt; if (value &gt;= 0) validValue(value) else badValue("cannot be less than 0'") }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ // TODO Move this to KeyStoreConfigHelpers. fun NodeConfiguration.configureWithDevSSLCertificate(cryptoService: CryptoService? = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$// Problems: // - Forces you to have a primary constructor with all fields of name and type matching the configuration file structure. // - Encourages weak bean-like types. // - Cannot support a many-to-one relationship between configuration file structures and configuration domain type. This is essential for versioning of the configuration files. // - It's complicated and based on reflection, meaning problems with it are typically found at runtime. // - It doesn't support validation errors in a structured way. If something goes wrong, it throws exceptions, which doesn't support good usability practices like displaying all the errors at once. fun &lt;T : Any&gt; Config.parseAs(clazz: KClass&lt;T&gt;, onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle, nestedPath: String? = null, baseDirectory: Path? = null): T</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$// TODO Move this to KeyStoreConfigHelpers. fun MutualSslConfiguration.configureDevKeyAndTrustStores(myLegalName: CordaX500Name, signingCertificateStore: FileBasedCertificateStoreSupplier, certificatesDirectory: Path, cryptoService: CryptoService? = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$ConfigHelper$val smartDevMode = CordaSystemUtils.isOsMac() || (CordaSystemUtils.isOsWindows() &amp;&amp; !CordaSystemUtils.getOsName().toLowerCase().contains("server"))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$fun Any?.toConfigValue(): ConfigValue</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$inline fun &lt;reified T : Any&gt; Config.parseAs(noinline onUnknownKeys: ((Set&lt;String&gt;, logger: Logger) -&gt; Unit) = UnknownConfigKeysPolicy.FAIL::handle): T</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$private</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$require(clazz.isData) { "Only Kotlin data classes or class annotated with CustomConfigParser can be parsed. Offending: ${clazz.qualifiedName}" }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$return getValueInternal(metadata.name, metadata.returnType, UnknownConfigKeysPolicy.IGNORE::handle, nestedPath = null, baseDirectory = null)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$return uncheckedCast(if (type.arguments.isEmpty()) getSingleValue(path, type, onUnknownKeys, nestedPath, baseDirectory) else getCollectionValue(path, type, onUnknownKeys, nestedPath, baseDirectory))</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$setPrivateKey(it, serviceKeystore.getPrivateKey(it, DEV_CA_KEY_STORE_PASS), serviceKeystore.getCertificateChain(it), signingKeyStore.entryPassword)</ID>
    <ID>MaxLineLength:ConfigUtilities.kt$val signingKeyStore = FileBasedCertificateStoreSupplier(signingCertificateStore.path, signingCertificateStore.storePassword, signingCertificateStore.entryPassword).get(true) .also { it.installDevNodeCaCertPath(myLegalName) }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // These types are supported by Config as use as is value }</ID>
    <ID>MaxLineLength:ConfigUtilities.kt${ // if baseDirectory been specified try resolving path against it. Note if `pathFromConfig` is an absolute path - this instruction has no effect. baseDirectory.resolve(path) }</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Describer</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Schema : ValidatorDescriber</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration$Validator : Validator</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Describer$ fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue = { value -&gt; ConfigValueFactory.fromAnyRef(value.toString()) }): ConfigValue?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property$Definition&lt;TYPE&gt; : MetadataValidatorExtractorDescriberParser</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition$Single&lt;TYPE&gt; : Definition</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun boolean(key: String, sensitive: Boolean = false): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun double(key: String, sensitive: Boolean = false): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun duration(key: String, sensitive: Boolean = false): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun nestedObject(key: String, schema: Schema? = null, sensitive: Boolean = false): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$ fun string(key: String, sensitive: Boolean = false): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Float, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of(key, Float::class.javaObjectType.simpleName, "Provided value exceeds Float range."))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Companion$invalid&lt;Int, Configuration.Validation.Error&gt;(Configuration.Validation.Error.BadValue.of("Provided value exceeds Integer range [${Int.MIN_VALUE}, ${Int.MAX_VALUE}].", key, Int::class.javaObjectType.simpleName))</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.RequiredList$ fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Validation.Error&gt;): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Property.Definition.Standard$ fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(name: String? = null, builder: Property.Definition.Companion.() -&gt; Iterable&lt;Property.Definition&lt;*&gt;&gt;): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Schema.Companion$ fun withProperties(vararg properties: Property.Definition&lt;*&gt;, name: String? = null): Schema</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String? = null, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun boolean(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun double(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun duration(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun float(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun int(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun long(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun nestedObject(schema: Schema? = null, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ fun string(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$ protected abstract fun parseValid(configuration: Config): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$abstract</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Specification$final override fun parse(configuration: Config, options: Configuration.Validation.Options): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadPath : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$BadValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MalformedStructure : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$MissingValue : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$Unknown : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$UnsupportedVersion : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$WrongType : Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal abstract fun with(keyName: String = this.keyName ?: UNKNOWN, typeName: String = this.typeName ?: UNKNOWN): Configuration.Validation.Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$internal fun withContainingPathPrefix(vararg containingPath: String): Error</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error$sealed</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadPath.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): BadPath</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.BadValue.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): BadValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun with(keyName: String, typeName: String): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MalformedStructure.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): MalformedStructure</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun with(keyName: String, typeName: String): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.MissingValue.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): MissingValue</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.Unknown.Companion$fun of(keyName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): Unknown</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType$override fun withContainingPath(vararg containingPath: String)</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun forKey(keyName: String, expectedTypeName: String, actualTypeName: String): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Validation.Error.WrongType.Companion$fun of(message: String, keyName: String? = null, typeName: String = UNKNOWN, containingPath: List&lt;String&gt; = emptyList()): WrongType</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value$Parser&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class) fun valueIn(configuration: Config): TYPE</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Extractor$ @Throws(ConfigException.WrongType::class, ConfigException.BadValue::class) fun valueInOrNull(configuration: Config): TYPE?</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Value.Parser$ fun parse(configuration: Config, options: Configuration.Validation.Options = Configuration.Validation.Options.defaults): Valid&lt;VALUE&gt;</ID>
    <ID>MaxLineLength:Configuration.kt$Configuration.Version.Extractor.Companion$ fun fromPath(versionPath: String, versionDefaultValue: Int = DEFAULT_VERSION_VALUE): Configuration.Version.Extractor</ID>
    <ID>MaxLineLength:ConnectionChange.kt$ConnectionChange$data</ID>
    <ID>MaxLineLength:ConnectionChange.kt$ConnectionChange$return "ConnectionChange remoteAddress: $remoteAddress connected state: $connected cert subject: ${remoteCert?.subjectDN} cert ok: ${!badCert}"</ID>
    <ID>MaxLineLength:ConnectionManager.kt$ fun &lt;A&gt; connectToNodes(remoteNodes: List&lt;RemoteNode&gt;, tunnelPortAllocation: PortAllocation, withConnections: (List&lt;NodeConnection&gt;) -&gt; A): A</ID>
    <ID>MaxLineLength:ConnectionStateMachine.kt$ConnectionStateMachine$logDebugWithMDC { "Put tag ${javax.xml.bind.DatatypeConverter.printHexBinary(delivery.tag)} on wire uuid: ${nextMessage.applicationProperties["_AMQ_DUPL_ID"]}" }</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `On contract annotated with NoConstraintPropagation there is no platform check for propagation, but the transaction builder can't use the AutomaticPlaceholderConstraint`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Switching from the WhitelistConstraint to the Signature Constraint fails if the signature constraint does not inherit all jar signatures`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$@Test fun `Switching from the WhitelistConstraint to the Signature Constraint is possible if the attachment satisfies both constraints, and the signature constraint inherits all jar signatures`()</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFailsWith&lt;IllegalArgumentException&gt; { AutomaticPlaceholderConstraint.canBeTransitionedFrom(AutomaticPlaceholderConstraint, attachment) }</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(HashAttachmentConstraint(allOnesHash), attachmentSigned))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(SignatureAttachmentConstraint(BOB_PUBKEY).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertFalse(WhitelistedByZoneAttachmentConstraint.canBeTransitionedFrom(HashAttachmentConstraint(SecureHash.randomSHA256()), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(HashAttachmentConstraint(SecureHash.randomSHA256()).canBeTransitionedFrom(WhitelistedByZoneAttachmentConstraint, attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$assertTrue(SignatureAttachmentConstraint(ALICE_PUBKEY).canBeTransitionedFrom(SignatureAttachmentConstraint(ALICE_PUBKEY), attachment))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "1"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "2"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.allOnesHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "3"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "1"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "2"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$attachment(Cash.PROGRAM_ID, SecureHash.zeroHash, listOf(hashToSignatureConstraintsKey), mapOf(Attributes.Name.IMPLEMENTATION_VERSION.toString() to "3"))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$ledgerServices.attachments.importContractAttachment(cordapp.contractClassNames, "rpc", signedJarStream, null, listOf(jarAndSigner.second))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$ledgerServices.attachments.importContractAttachment(cordapp.contractClassNames, "rpc", unsignedJarStream, null)</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(allOnesHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(unsignedAttachmentId), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c1", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, HashAttachmentConstraint(allOnesHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c2", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c3", DUMMY_NOTARY, null, SignatureAttachmentConstraint(ALICE_PUBKEY), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c3", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(2000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "c4", DUMMY_NOTARY, null, AlwaysAcceptAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w1", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), ALICE_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(ALICE_PUBKEY), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(Cash.PROGRAM_ID, "w2", DUMMY_NOTARY, null, SignatureAttachmentConstraint(hashToSignatureConstraintsKey), Cash.State(1000.POUNDS `issued by` ALICE_PARTY.ref(1), BOB_PARTY))</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c1", DUMMY_NOTARY, null, HashAttachmentConstraint(zeroHash), NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c2", DUMMY_NOTARY, null, WhitelistedByZoneAttachmentConstraint, NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$output(noPropagationContractClassName, "c3", DUMMY_NOTARY, null, AutomaticPlaceholderConstraint, NoPropagationContractState())</ID>
    <ID>MaxLineLength:ConstraintsPropagationTests.kt$ConstraintsPropagationTests$val jarAndSigner = ContractJarTestUtils.signContractJar(cordapp.jarPath, copyFirst = true, keyStoreDir = keyStoreDir.path)</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ fun AttachmentConstraint.canBeTransitionedFrom(input: AttachmentConstraint, attachment: ContractAttachment): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$ internal fun ContractClassName.contractHasAutomaticConstraintPropagation(classLoader: ClassLoader? = null): Boolean</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$input.isAutomaticHashConstraint() || output.isAutomaticHashConstraint() -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.")</ID>
    <ID>MaxLineLength:ConstraintsUtils.kt$when { // These branches should not happen, as this has been already checked. input is AutomaticPlaceholderConstraint || output is AutomaticPlaceholderConstraint -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticPlaceholderConstraint.") input.isAutomaticHashConstraint() || output.isAutomaticHashConstraint() -&gt; throw IllegalArgumentException("Illegal constraint: AutomaticHashConstraint.") // Transition to the same constraint. input == output -&gt; true // You can't transition from the AlwaysAcceptAttachmentConstraint to anything else, as it could hide something illegal. input is AlwaysAcceptAttachmentConstraint &amp;&amp; output !is AlwaysAcceptAttachmentConstraint -&gt; false // Nothing can be migrated from the HashConstraint except a HashConstraint with the same Hash. (This check is redundant, but added for clarity) input is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; input == output // Anything (except the AlwaysAcceptAttachmentConstraint) can be transformed to a HashAttachmentConstraint. input !is HashAttachmentConstraint &amp;&amp; output is HashAttachmentConstraint -&gt; true // The SignatureAttachmentConstraint allows migration from a Signature constraint with the same key. // TODO - we don't support currently third party signers. When we do, the output key will have to be stronger then the input key. input is SignatureAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; input.key == output.key // HashAttachmentConstraint can be transformed to a SignatureAttachmentConstraint when hash constraint verification checking disabled. HashAttachmentConstraint.disableHashConstraints &amp;&amp; input is HashAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; true // You can transition from the WhitelistConstraint to the SignatureConstraint only if all signers of the JAR are required to sign in the future. input is WhitelistedByZoneAttachmentConstraint &amp;&amp; output is SignatureAttachmentConstraint -&gt; attachment.signerKeys.isNotEmpty() &amp;&amp; output.key.keys.containsAll(attachment.signerKeys) else -&gt; false }</ID>
    <ID>MaxLineLength:ContentSignerBuilder.kt$ContentSignerBuilder.SignatureOutputStream$private fun checkNotSigned(func: () -&gt; Unit)</ID>
    <ID>MaxLineLength:ContractAttachment.kt$ContractAttachment$return "ContractAttachment(attachment=${attachment.id}, contracts='$allContracts', uploader='$uploader', signed='$isSigned', version='$version')"</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$PrepareTransaction : FlowLogic</ID>
    <ID>MaxLineLength:ContractHierarchyTest.kt$ContractHierarchyTest$mockNet = InternalMockNetwork(networkSendManuallyPumped = false, threadPerNode = true, cordappsForAllNodes = listOf(enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$@JvmOverloads fun makeTestContractJar(workingDir: Path, contractNames: List&lt;String&gt;, signed: Boolean = false, version: Int = 1, generateManifest: Boolean = true, jarFileName : String? = null): Path</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$fun signContractJar(jarURL: URL, copyFirst: Boolean, keyStoreDir: Path? = null, alias: String = "testAlias", pwd: String = "testPassword"): Pair&lt;Path, PublicKey&gt;</ID>
    <ID>MaxLineLength:ContractJarTestUtils.kt$ContractJarTestUtils$val source = object : SimpleJavaFileObject(URI.create("string:///${packages.joinToString("/")}/$className.java"), JavaFileObject.Kind.SOURCE) { override fun getCharContent(ignoreEncodingErrors: Boolean): CharSequence { return newClass } }</ID>
    <ID>MaxLineLength:ContractStateModel.kt$ContractStateModel$val cashStates: ObservableList&lt;StateAndRef&lt;Cash.State&gt;&gt; = cashStatesDiff.fold(FXCollections.observableArrayList()) { list: MutableList&lt;StateAndRef&lt;Cash.State&gt;&gt;, (added, removed) -&gt; list.removeIf { it in removed } list.addAll(added) }.distinctBy { it.ref }</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$( originalState: StateAndRef&lt;OldState&gt;, newContractClass: Class&lt;out UpgradedContract&lt;OldState, NewState&gt;&gt; )</ID>
    <ID>MaxLineLength:ContractUpgradeFlow.kt$ContractUpgradeFlow.Initiate$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.CashV2.State$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Currency&gt;&gt;, newOwner: AbstractParty)</ID>
    <ID>MaxLineLength:ContractUpgradeFlowTest.kt$ContractUpgradeFlowTest.Companion$private val classMockNet = InternalMockNetwork(cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, DUMMY_CONTRACTS_CORDAPP, enclosedCordapp()))</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeFilteredTransaction : CoreTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, notary: Party, legacyContractAttachment: Attachment, upgradedContractClassName: ContractClassName, upgradedContractAttachment: Attachment, id: SecureHash, privacySalt: PrivacySalt, sigs: List&lt;TransactionSignature&gt;, networkParameters: NetworkParameters )</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$?:</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$ContractUpgradeLedgerTransaction(inputs, notary, legacyContractAttachment, upgradedContractClassName, upgradedContractAttachment, id, privacySalt, sigs, networkParameters)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$override</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction$return "ContractUpgradeLedgerTransaction(inputs=$inputs, notary=$notary, legacyContractAttachment=$legacyContractAttachment, upgradedContractAttachment=$upgradedContractAttachment, id=$id, privacySalt=$privacySalt, sigs=$sigs, networkParameters=$networkParameters, upgradedContract=$upgradedContract, references=$references, legacyContractClassName='$legacyContractClassName', outputs=$outputs)"</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction.Companion$return ContractUpgradeLedgerTransaction(inputs, notary, legacyContractAttachment, upgradedContractAttachment, id, privacySalt, sigs, networkParameters, upgradedContract)</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun buildFilteredTransaction(): ContractUpgradeFilteredTransaction</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$classLoader.loadClass(className).asSubclass(UpgradedContract::class.java).getDeclaredConstructor().newInstance() as UpgradedContract&lt;ContractState, ContractState&gt;</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$private</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val binaryInput: SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt; = resolveStateRefBinaryComponent(inputs[stateRef.index], services)!!</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$val upgradedContractClassName: ContractClassName by lazy { serializedComponents[UPGRADED_CONTRACT.ordinal].deserialize&lt;ContractClassName&gt;() }</ID>
    <ID>MaxLineLength:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction.Companion$@CordaInternal internal</ID>
    <ID>MaxLineLength:ContractsDSL.kt$inline</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt; -&gt; commands.requireSingleCommand(TestCommands::class.java) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$RequireSingleCommandTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt; -&gt; commands.requireSingleCommand&lt;TestCommands&gt;() }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signers: Collection&lt;PublicKey&gt;?, party: Collection&lt;Party&gt;? -&gt; commands.select(TestCommands::class.java, signers, party) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithMultipleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signers: Collection&lt;PublicKey&gt;?, party: Collection&lt;Party&gt;? -&gt; commands.select&lt;TestCommands&gt;(signers, party) }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signer: PublicKey?, party: AbstractParty? -&gt; commands.select(TestCommands::class.java, signer, party) }, "Interop version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$SelectWithSingleInputsTests.Companion$arrayOf&lt;Any&gt;({ commands: Collection&lt;CommandWithParties&lt;CommandData&gt;&gt;, signer: PublicKey?, party: AbstractParty? -&gt; commands.select&lt;TestCommands&gt;(signer, party) }, "Inline version")</ID>
    <ID>MaxLineLength:ContractsDSLTests.kt$val validCommandOne = CommandWithParties(listOf(megaCorp.publicKey, miniCorp.publicKey), listOf(megaCorp.party, miniCorp.party), TestCommands.CommandOne())</ID>
    <ID>MaxLineLength:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin : CRaSHPluginAuthenticationPlugin</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$// We don't allow the annotation for classes in attachments for now. The class will be on the main classpath if we have the CorDapp installed. // We also do not allow extension of KryoSerializable for annotated classes, or combination with @DefaultSerializer for custom serialisation. // TODO: Later we can support annotations on attachment classes and spin up a proxy via bytecode that we know is harmless. private fun checkForAnnotation(type: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$if (type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))) return null</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver$kotlin.jvm.internal.Lambda::class.java.isAssignableFrom(targetType)</ID>
    <ID>MaxLineLength:CordaClassResolver.kt$CordaClassResolver${ // If call path has disabled whitelisting (see [CordaKryo.register]), just return without checking. if (!whitelistEnabled) return null // If array, recurse on element type if (type.isArray) return checkClass(type.componentType) // Specialised enum entry, so just resolve the parent Enum type since cannot annotate the specialised entry. if (!type.isEnum &amp;&amp; Enum::class.java.isAssignableFrom(type)) return checkClass(type.superclass) // Allow primitives, abstracts and interfaces. Note that we can also create abstract Enum types, // but we don't want to whitelist those here. if (type.isPrimitive || type == Any::class.java || type == String::class.java || (!type.isEnum &amp;&amp; isAbstract(type.modifiers))) return null // It's safe to have the Class already, since Kryo loads it with initialisation off. // If we use a whitelist with blacklisting capabilities, whitelist.hasListed(type) may throw an IllegalStateException if input class is blacklisted. // Thus, blacklisting precedes annotation checking. if (!whitelist.hasListed(type) &amp;&amp; !checkForAnnotation(type)) { throw KryoException("Class ${Util.className(type)} is not annotated or on the whitelist, so cannot be used in serialization") } return null }</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$CordaSerializableHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$SubHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superclass java.util.HashSet of net.corda.serialization.internal.CordaClassResolverTests\$SubSubHashSet is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superinterface java.sql.Connection of net.corda.serialization.internal.CordaClassResolverTests\$ConnectionImpl is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$expectedEx.expectMessage("The superinterface java.sql.Connection of net.corda.serialization.internal.CordaClassResolverTests\$SubConnectionImpl is blacklisted, so it cannot be used in serialization.")</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private fun importJar(storage: AttachmentStorage, uploader: String = DEPLOYED_CORDAPP_UPLOADER)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private val allButBlacklistedContext: CheckpointSerializationContext = CheckpointSerializationContextImpl(this.javaClass.classLoader, AllButBlacklisted, emptyMap(), true, null)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$private val emptyWhitelistContext: CheckpointSerializationContext = CheckpointSerializationContextImpl(this.javaClass.classLoader, EmptyWhitelist, emptyMap(), true, null)</ID>
    <ID>MaxLineLength:CordaClassResolverTests.kt$CordaClassResolverTests$val classLoader = AttachmentsClassLoader(arrayOf(attachmentHash).map { storage.openAttachment(it)!! }, testNetworkParameters(), SecureHash.zeroHash, { attachmentTrustCalculator.calculate(it) })</ID>
    <ID>MaxLineLength:CordaClosureSerializer.kt$CordaClosureSerializer$const val ERROR_MESSAGE = "Unable to serialize Java Lambda expression, unless explicitly declared e.g., Runnable r = (Runnable &amp; Serializable) () -&gt; System.out.println(\"Hello world!\");"</ID>
    <ID>MaxLineLength:CordaFuture.kt$CordaFuture&lt;V&gt; : Future</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;ELEMENT&gt; CordaFuture&lt;out ELEMENT&gt;.mapError(transform: (Throwable) -&gt; Throwable): CordaFuture&lt;ELEMENT&gt;</ID>
    <ID>MaxLineLength:CordaFutureImpl.kt$ fun &lt;RESULT&gt; CordaFuture&lt;out RESULT&gt;.doOnError(accept: (Throwable) -&gt; Unit): CordaFuture&lt;RESULT&gt;</ID>
    <ID>MaxLineLength:CordaMigration.kt$CordaMigration$_servicesForResolution = MigrationServicesForResolution(identityService, attachmentsService, dbTransactions, cordaDB, cacheFactory)</ID>
    <ID>MaxLineLength:CordaModule.kt$AmountBeanDeserializerModifier$override</ID>
    <ID>MaxLineLength:CordaModule.kt$CordaModule${ super.setupModule(context) // For classes which are annotated with CordaSerializable we want to use the same set of properties as the Corda serilasation scheme. // To do that we use CordaSerializableClassIntrospector to first turn on field visibility for these classes (the Jackson default is // private fields are not included) and then we use CordaSerializableBeanSerializerModifier to remove any extra properties that Jackson // might pick up. context.setClassIntrospector(CordaSerializableClassIntrospector(context)) context.addBeanSerializerModifier(CordaSerializableBeanSerializerModifier()) context.addBeanDeserializerModifier(AmountBeanDeserializerModifier()) context.setMixInAnnotations(PartyAndCertificate::class.java, PartyAndCertificateMixin::class.java) context.setMixInAnnotations(NetworkHostAndPort::class.java, NetworkHostAndPortMixin::class.java) context.setMixInAnnotations(CordaX500Name::class.java, CordaX500NameMixin::class.java) context.setMixInAnnotations(Amount::class.java, AmountMixin::class.java) context.setMixInAnnotations(AbstractParty::class.java, AbstractPartyMixin::class.java) context.setMixInAnnotations(AnonymousParty::class.java, AnonymousPartyMixin::class.java) context.setMixInAnnotations(Party::class.java, PartyMixin::class.java) context.setMixInAnnotations(PublicKey::class.java, PublicKeyMixin::class.java) context.setMixInAnnotations(ByteSequence::class.java, ByteSequenceMixin::class.java) context.setMixInAnnotations(SecureHash.SHA256::class.java, SecureHashSHA256Mixin::class.java) context.setMixInAnnotations(SecureHash::class.java, SecureHashSHA256Mixin::class.java) context.setMixInAnnotations(SerializedBytes::class.java, SerializedBytesMixin::class.java) context.setMixInAnnotations(DigitalSignature.WithKey::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(DigitalSignatureWithCert::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(TransactionSignature::class.java, ByteSequenceWithPropertiesMixin::class.java) context.setMixInAnnotations(SignedTransaction::class.java, SignedTransactionMixin::class.java) context.setMixInAnnotations(WireTransaction::class.java, WireTransactionMixin::class.java) context.setMixInAnnotations(TransactionState::class.java, TransactionStateMixin::class.java) context.setMixInAnnotations(Command::class.java, CommandMixin::class.java) context.setMixInAnnotations(TimeWindow::class.java, TimeWindowMixin::class.java) context.setMixInAnnotations(PrivacySalt::class.java, PrivacySaltMixin::class.java) context.setMixInAnnotations(SignatureScheme::class.java, SignatureSchemeMixin::class.java) context.setMixInAnnotations(SignatureMetadata::class.java, SignatureMetadataMixin::class.java) context.setMixInAnnotations(PartialTree::class.java, PartialTreeMixin::class.java) context.setMixInAnnotations(NodeInfo::class.java, NodeInfoMixin::class.java) context.setMixInAnnotations(StateMachineRunId::class.java, StateMachineRunIdMixin::class.java) }</ID>
    <ID>MaxLineLength:CordaModule.kt$StxJson$val count = Booleans.countTrue(wire != null, filtered != null, notaryChangeWire != null, contractUpgradeWire != null, contractUpgradeFiltered != null)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$@Suppress("UNCHECKED_CAST") val connectionBag: ConcurrentBag&lt;ConcurrentBag.IConcurrentBagEntry&gt; = connectionBagField.get(pool) as ConcurrentBag&lt;ConcurrentBag.IConcurrentBagEntry&gt;</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$error("Was not expecting to find existing database transaction on current strand when setting database: ${Strand.currentStrand()}, $it")</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$is SchemaManagementException -&gt; throw HibernateSchemaChangeException("Incompatible schema change detected. Please run the node with database.initialiseSchema=true. Reason: ${e.message}", e)</ID>
    <ID>MaxLineLength:CordaPersistence.kt$CordaPersistence$val transaction = contextDatabase.currentOrNew(isolationLevel) // XXX: Does this code really support statement changing the contextDatabase?</ID>
    <ID>MaxLineLength:CordaRPCClientReconnectionTest.kt$CordaRPCClientReconnectionTest$val addresses = listOf(NetworkHostAndPort("localhost", portAllocator.nextPort()), NetworkHostAndPort("localhost", portAllocator.nextPort()))</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$node.services.startFlow(CashIssueFlow(100.POUNDS, OpaqueBytes.of(1), identity), InvocationContext.shell()).flatMap { it.resultFuture }.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCClientTest.kt$CordaRPCClientTest$node.services.startFlow(CashIssueFlow(2000.DOLLARS, OpaqueBytes.of(0), identity), InvocationContext.shell()).flatMap { it.resultFuture }.getOrThrow()</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$ @Deprecated("For automated upgrades, consider using the `gracefulShutdown` command in an SSH session instead.") fun CordaRPCOps.pendingFlowsCount(): DataFeed&lt;Int, Pair&lt;Int, Int&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ // TODO This operation should be restricted to just node admins. fun acceptNewNetworkParameters(parametersHash: SecureHash)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @CordaInternal @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalFindVerifiedTransaction(txnId: SecureHash): SignedTransaction?</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") @RPCReturnsObservables fun internalVerifiedTransactionsFeed(): DataFeed&lt;List&lt;SignedTransaction&gt;, SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ @Deprecated("This method is intended only for internal use and will be removed from the public API soon.") fun internalVerifiedTransactionsSnapshot(): List&lt;SignedTransaction&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$ fun terminate(drainPendingFlows: Boolean = false)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultQueryByWithPagingSpec(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByCriteria(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByWithPagingSpec(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$CordaRPCOps$fun &lt;T : ContractState&gt; vaultTrackByWithSorting(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$StateMachineInfo$return copy(id = id, flowLogicClassName = flowLogicClassName, initiator = initiator, progressTrackerStepAndUpdates = progressTrackerStepAndUpdates, invocationContext = invocationContext)</ID>
    <ID>MaxLineLength:CordaRPCOps.kt$sorting: Sort = Sort(emptySet())</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$assertThatCode { rpc.startFlow(::SoftLock, cash.ref, Duration.ofSeconds(1)).returnValue.getOrThrow() }.doesNotThrowAnyException()</ID>
    <ID>MaxLineLength:CordaRPCOpsImplTest.kt$CordaRPCOpsImplTest$val cash = rpc.startFlow(::CashIssueFlow, 10.DOLLARS, issuerRef, notary).returnValue.getOrThrow().stx.tx.outRefsOfType&lt;Cash.State&gt;().single()</ID>
    <ID>MaxLineLength:CordaSSHAuthInfo.kt$CordaSSHAuthInfo : AuthInfo</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest$mockNet = MockNetwork(MockNetworkParameters(threadPerNode = true, cordappsForAllNodes = listOf(FINANCE_CONTRACTS_CORDAPP, enclosedCordapp())))</ID>
    <ID>MaxLineLength:CordaServiceTest.kt$CordaServiceTest.CordaServiceThatRequiresThreadContextClassLoader$assertNotNull(Thread.currentThread().contextClassLoader, "thread context classloader should not be null during service initialisation")</ID>
    <ID>MaxLineLength:CordaUtils.kt$ private fun owns(packageName: String, fullClassName: String): Boolean</ID>
    <ID>MaxLineLength:CordaUtils.kt$AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:CordaViewModel.kt$CordaView : View</ID>
    <ID>MaxLineLength:CordaX500Name.kt$CordaX500Name$this(commonName = commonName, organisationUnit = null, organisation = organisation, locality = locality, state = null, country = country)</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info$Workflow : Info</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Contract$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Default$data</ID>
    <ID>MaxLineLength:Cordapp.kt$Cordapp.Info.Workflow$data</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$assertThat(allStates[0].state.constraint).isInstanceOfAny(HashAttachmentConstraint::class.java, SignatureAttachmentConstraint::class.java)</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val aliceQuery = restartedAlice.rpc.vaultQueryBy&lt;Cash.State&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED))</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val issueTx = alice.rpc.startFlow(::CashIssueFlow, 1000.DOLLARS, OpaqueBytes.of(1), defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val transferTx = alice.rpc.startFlow(::CashPaymentFlow, 1000.DOLLARS, bobParty, true, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val transferTxn = restartedAlice.rpc.startFlow(::CashPaymentFlow, 1000.DOLLARS, bobParty, true, defaultNotaryIdentity).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val vaultUpdatesBob = bob.rpc.vaultTrackByCriteria(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).updates</ID>
    <ID>MaxLineLength:CordappConstraintsTests.kt$CordappConstraintsTests$val vaultUpdatesBob = restartedBob.rpc.vaultTrackByCriteria(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).updates</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getBoolean(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getDouble(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getFloat(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getInt(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getLong(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getNumber(path: String)</ID>
    <ID>MaxLineLength:CordappContext.kt$CordappContext.EmptyCordappConfig$override fun getString(path: String)</ID>
    <ID>MaxLineLength:CordappResolverTest.kt$CordappResolverTest$@Test fun `when the same cordapp is registered for the same class multiple times, the resolver deduplicates and returns it as the current one`()</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$(additionalNodeInfoDir / "nodeInfo-41408E093F95EAD51F6892C34DEB65AE1A3569A4B0E5744769A1B485AF8E04B5").write(signedNodeInfo.serialize().bytes)</ID>
    <ID>MaxLineLength:CordappSmokeTest.kt$CordappSmokeTest$val nodeInfo = createNodeInfoWithSingleIdentity(CordaX500Name(organisation = "Bob Corp", locality = "Madrid", country = "ES"), dummyKeyPair, dummyKeyPair.public)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler : Acceptor</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$"The proposed upgrade ${proposal.modification.javaClass} is a trusted upgrade path" using (proposal.modification.name == authorisedUpgrade)</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$ContractUpgradeHandler$@Suspendable override</ID>
    <ID>MaxLineLength:CoreFlowHandlers.kt$FinalityHandler$logger.warnOnce("Insecure API to record finalised transaction was used by ${sender.counterparty} (${sender.getCounterpartyFlowInfo()})")</ID>
    <ID>MaxLineLength:CouldNotStartFlowException.kt$CouldNotStartFlowException : RPCException</ID>
    <ID>MaxLineLength:CrossCashTest.kt${ log.warn( "Divergence detected, the remote state doesn't match any of our possible predictions." + "\nPredicted state/queues:\n$previousState" + "\nActual gathered state:\n${CrossCashState(currentNodeVaults, mapOf())}" ) // TODO We should terminate here with an exception, we cannot carry on as we have an inconsistent model. We carry on currently because we always diverge due to notarisation failures return@LoadTest CrossCashState(currentNodeVaults, mapOf()) }</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @DeleteForDJVM @JvmStatic fun generateKeyPair(schemeCodeName: String): KeyPair</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun findSignatureScheme(schemeCodeName: String): SignatureScheme</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ @JvmStatic fun publicKeyOnCurve(signatureScheme: SignatureScheme, publicKey: PublicKey): Boolean</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$ECDSA_SECP256R1_SHA256, ECDSA_SECP256K1_SHA256 -&gt; deriveKeyPairECDSA(signatureScheme.algSpec as ECParameterSpec, privateKey, seed)</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPrivateKey, is BCSphincs256PrivateKey -&gt; true</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$is BCRSAPublicKey -&gt; key.modulus.bitLength() &gt;= 2048</ID>
    <ID>MaxLineLength:Crypto.kt$Crypto$val signableData = SignableData(originalSignedHash(txId, transactionSignature.partialMerkleTree), transactionSignature.signatureMetadata)</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoService$ fun createWrappingKey(alias: String, failIfExists: Boolean = true)</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoService$ fun generateWrappedKeyPair(masterKeyAlias: String, childKeyScheme: SignatureScheme = defaultWrappingSignatureScheme()): Pair&lt;PublicKey, WrappedPrivateKey&gt;</ID>
    <ID>MaxLineLength:CryptoService.kt$CryptoService$ fun getWrappingMode(): WrappingMode?</ID>
    <ID>MaxLineLength:CryptoServiceFactory.kt$CryptoServiceFactory.Companion$throw IllegalArgumentException("Currently only BouncyCastle is used as a crypto service. A valid signing certificate store is required.")</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun newSecureRandom(): SecureRandom</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @DeleteForDJVM @Throws(NoSuchAlgorithmException::class) fun secureRandomBytes(numOfBytes: Int): ByteArray</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun KeyPair.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ @Throws(InvalidKeyException::class, SignatureException::class) fun PublicKey.verify(signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun PublicKey.isFulfilledBy(otherKeys: Iterable&lt;PublicKey&gt;): Boolean</ID>
    <ID>MaxLineLength:CryptoUtils.kt$ fun computeNonce(privacySalt: PrivacySalt, groupIndex: Int, internalIndex: Int)</ID>
    <ID>MaxLineLength:CryptoUtils.kt$throw IllegalStateException("Verification of CompositeKey signatures currently not supported.")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val expectedAlgSet = setOf("RSA_SHA256", "ECDSA_SECP256K1_SHA256", "ECDSA_SECP256R1_SHA256", "EDDSA_ED25519_SHA512", "SPHINCS-256_SHA512", "COMPOSITE")</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger("50")))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(259).plus(BigInteger.ONE))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256K1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(ECDSA_SECP256R1_SHA256, BigInteger("2").pow(514).minus(BigInteger.TEN))</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest$val pubKeySpec = EdDSAPublicKeySpec((EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec).curve.getZero(GroupElement.Representation.P3), EDDSA_ED25519_SHA512.algSpec as EdDSANamedCurveSpec)</ID>
    <ID>MaxLineLength:CryptoUtilsTest.kt$CryptoUtilsTest${ val keyPairPositive = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("10")) assertEquals("DLBL3iHCp9uRReWhhCGfCsrxZZpfAm9h9GLbfN8ijqXTq", keyPairPositive.public.toStringShort()) val keyPairNegative = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("-10")) assertEquals("DLC5HXnYsJAFqmM9hgPj5G8whQ4TpyE9WMBssqCayLBwA2", keyPairNegative.public.toStringShort()) val keyPairZero = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("0")) assertEquals("DL4UVhGh4tqu1G86UVoGNaDDNCMsBtNHzE6BSZuNNJN7W2", keyPairZero.public.toStringShort()) val keyPairOne = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("1")) assertEquals("DL8EZUdHixovcCynKMQzrMWBnXQAcbVDHi6ArPphqwJVzq", keyPairOne.public.toStringShort()) val keyPairBiggerThan256bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger.TEN)) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bits.public.toStringShort()) // The underlying implementation uses the first 256 bytes of the entropy. Thus, 2^258-10 and 2^258-50 and 2^514-10 have the same impact. val keyPairBiggerThan256bitsV2 = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(258).minus(BigInteger("50"))) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan256bitsV2.public.toStringShort()) val keyPairBiggerThan512bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(514).minus(BigInteger.TEN)) assertEquals("DLB9K1UiBrWonn481z6NzkqoWHjMBXpfDeaet3wiwRNWSU", keyPairBiggerThan512bits.public.toStringShort()) // Try another big number. val keyPairBiggerThan258bits = Crypto.deriveKeyPairFromEntropy(EDDSA_ED25519_SHA512, BigInteger("2").pow(259).plus(BigInteger.ONE)) assertEquals("DL5tEFVMXMGrzwjfCAW34JjkhsRkPfFyJ38iEnmpB6L2Z9", keyPairBiggerThan258bits.public.toStringShort()) }</ID>
    <ID>MaxLineLength:CurrencyParameterSensitivitySerialiser.kt$CurrencyParameterSensitivitySerializer$override fun toProxy(obj: CurrencyParameterSensitivity)</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.CustomSerializerImp$abstract</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.CustomSerializerImp$override fun isSerializerFor(clazz: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CustomSerializer.kt$CustomSerializer.Proxy$override fun isSerializerFor(clazz: Class&lt;*&gt;): Boolean</ID>
    <ID>MaxLineLength:CustomSerializerRegistry.kt$CachingCustomSerializerRegistry$private val customSerializersCache: MutableMap&lt;CustomSerializerIdentifier, CustomSerializerLookupResult&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:CustomVaultQueryTest.kt$CustomVaultQueryTest$mockNet = MockNetwork(threadPerNode = true, cordappPackages = listOf("net.corda.finance", IOUFlow::class.packageName, javaClass.packageName_, "com.template"))</ID>
    <ID>MaxLineLength:DBCheckpointStorageTests.kt$DBCheckpointStorageTests$val checkpoint = Checkpoint.create(InvocationContext.shell(), FlowStart.Explicit, logic.javaClass, frozenLogic, ALICE, SubFlowVersion.CoreFlow(version), false) .getOrThrow()</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.Companion$PersistentNetworkParameters</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.Companion$fun createParametersMap(cacheFactory: NamedCacheFactory): AppendOnlyPersistentMap&lt;SecureHash, SignedDataWithCert&lt;NetworkParameters&gt;, PersistentNetworkParameters, String&gt;</ID>
    <ID>MaxLineLength:DBNetworkParametersStorage.kt$DBNetworkParametersStorage.PersistentNetworkParameters$val signWithCert = DigitalSignatureWithCert(X509CertificateFactory().generateCertificate(certificate.inputStream()), certChain, signature)</ID>
    <ID>MaxLineLength:DBRunnerExtension.kt$DBRunnerExtension : ExtensionBeforeAllCallbackAfterAllCallbackBeforeEachCallbackAfterEachCallback</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$cq.multiselect(from.get&lt;String&gt;(DBTransactionStorage.DBTransaction::stateMachineRunId.name), from.get&lt;String&gt;(DBTransactionStorage.DBTransaction::txId.name))</ID>
    <ID>MaxLineLength:DBTransactionMappingStorage.kt$DBTransactionMappingStorage$val flowIds = session.createQuery(cq).resultList.map { StateMachineTransactionMapping(StateMachineRunId(UUID.fromString(it[0] as String)), SecureHash.parse(it[1] as String)) }</ID>
    <ID>MaxLineLength:DBTransactionStorage.kt$DBTransactionStorage.TransactionStatus$UnexpectedStatusValueException : Exception</ID>
    <ID>MaxLineLength:DBTransactionStorageTests.kt$DBTransactionStorageTests$listOf(TransactionSignature(ByteArray(1), ALICE_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID)))</ID>
    <ID>MaxLineLength:DatabaseTransaction.kt$get() = if (_prohibitDatabaseAccess.get() == true) throw IllegalAccessException("Database access is disabled in this context.") else _contextTransaction.get()</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$DbMapDeadlockTest$it.setProperty("dataSource.url", "jdbc:h2:file:${temporaryFolder.root}/persistence;DB_CLOSE_ON_EXIT=FALSE;WRITE_DELAY=0;LOCK_TIMEOUT=10000")</ID>
    <ID>MaxLineLength:DbMapDeadlockTest.kt$LockDbSchemaV2 : MappedSchema</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$TopologicalSort</ID>
    <ID>MaxLineLength:DbTransactionsResolver.kt$DbTransactionsResolver$val (existingTxIds, downloadedTxs) = fetchRequiredTransactions(Collections.singleton(nextRequests.first())) // Fetch first item only</ID>
    <ID>MaxLineLength:DefaultKryoCustomizer.kt$DefaultKryoCustomizer$// Store a little schema of field names in the stream the first time a class is used which increases tolerance // for change to a class. setDefaultSerializer(CompatibleFieldSerializer::class.java) // Take the safest route here and allow subclasses to have fields named the same as super classes. fieldSerializerConfig.cachedFieldNameStrategy = FieldSerializer.CachedFieldNameStrategy.EXTENDED instantiatorStrategy = CustomInstantiatorStrategy() // Required for HashCheckingStream (de)serialization. // Note that return type should be specifically set to InputStream, otherwise it may not work, i.e. val aStream : InputStream = HashCheckingStream(...). addDefaultSerializer(InputStream::class.java, InputStreamSerializer) addDefaultSerializer(SerializeAsToken::class.java, SerializeAsTokenSerializer&lt;SerializeAsToken&gt;()) addDefaultSerializer(Logger::class.java, LoggerSerializer) addDefaultSerializer(X509Certificate::class.java, X509CertificateSerializer) // WARNING: reordering the registrations here will cause a change in the serialized form, since classes // with custom serializers get written as registration ids. This will break backwards-compatibility. // Please add any new registrations to the end. // TODO: re-organise registrations into logical groups before v1.0 register(Arrays.asList("").javaClass, ArraysAsListSerializer()) register(LazyMappedList::class.java, LazyMappedListSerializer) register(SignedTransaction::class.java, SignedTransactionSerializer) register(WireTransaction::class.java, WireTransactionSerializer) register(SerializedBytes::class.java, SerializedBytesSerializer) UnmodifiableCollectionsSerializer.registerSerializers(this) ImmutableListSerializer.registerSerializers(this) ImmutableSetSerializer.registerSerializers(this) ImmutableSortedSetSerializer.registerSerializers(this) ImmutableMapSerializer.registerSerializers(this) ImmutableMultimapSerializer.registerSerializers(this) // InputStream subclasses whitelisting, required for attachments. register(BufferedInputStream::class.java, InputStreamSerializer) register(Class.forName("sun.net.www.protocol.jar.JarURLConnection\$JarURLInputStream"), InputStreamSerializer) noReferencesWithin&lt;WireTransaction&gt;() register(PublicKey::class.java, publicKeySerializer) register(PrivateKey::class.java, PrivateKeySerializer) register(EdDSAPublicKey::class.java, publicKeySerializer) register(EdDSAPrivateKey::class.java, PrivateKeySerializer) register(CompositeKey::class.java, publicKeySerializer) // Using a custom serializer for compactness // Exceptions. We don't bother sending the stack traces as the client will fill in its own anyway. register(Array&lt;StackTraceElement&gt;::class, read = { _, _ -&gt; emptyArray() }, write = { _, _, _ -&gt; }) // This ensures a NonEmptySetSerializer is constructed with an initial value. register(NonEmptySet::class.java, NonEmptySetSerializer) register(BitSet::class.java, BitSetSerializer()) register(Class::class.java, ClassSerializer) register(FileInputStream::class.java, InputStreamSerializer) register(CertPath::class.java, CertPathSerializer) register(BCECPrivateKey::class.java, PrivateKeySerializer) register(BCECPublicKey::class.java, publicKeySerializer) register(BCRSAPrivateCrtKey::class.java, PrivateKeySerializer) register(BCRSAPublicKey::class.java, publicKeySerializer) register(BCSphincs256PrivateKey::class.java, PrivateKeySerializer) register(BCSphincs256PublicKey::class.java, publicKeySerializer) register(NotaryChangeWireTransaction::class.java, NotaryChangeWireTransactionSerializer) register(PartyAndCertificate::class.java, PartyAndCertificateSerializer) // Don't deserialize PrivacySalt via its default constructor. register(PrivacySalt::class.java, PrivacySaltSerializer) // Used by the remote verifier, and will possibly be removed in future. register(ContractAttachment::class.java, ContractAttachmentSerializer) register(java.lang.invoke.SerializedLambda::class.java) register(ClosureSerializer.Closure::class.java, CordaClosureBlacklistSerializer) register(ContractUpgradeWireTransaction::class.java, ContractUpgradeWireTransactionSerializer) register(ContractUpgradeFilteredTransaction::class.java, ContractUpgradeFilteredTransactionSerializer) for (whitelistProvider in serializationWhitelists) { val types = whitelistProvider.whitelist require(types.toSet().size == types.size) { val duplicates = types.toMutableList() types.toSet().forEach { duplicates -= it } "Cannot add duplicate classes to the whitelist ($duplicates)." } for (type in types) { ((kryo.classResolver as? CordaClassResolver)?.whitelist as? MutableClassWhitelist)?.add(type) } }</ID>
    <ID>MaxLineLength:DeliverSessionMessageTransition.kt$DeliverSessionMessageTransition$Action.SendExisting(initiatedSession.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID))</ID>
    <ID>MaxLineLength:DeserializeMapTests.kt$DeserializeMapTests$Assertions.assertThatThrownBy { TestSerializationOutput(VERBOSE, sf).serialize(c) } .isInstanceOf(IllegalArgumentException::class.java)</ID>
    <ID>MaxLineLength:DeserializeQueryableStateTest.kt$DeserializeQueryableStateTest$val clientContext = AMQP_RPC_CLIENT_CONTEXT.copy(whitelist = AllWhitelist, deserializationClassLoader = ClassLoaderWithoutTestState(ClassLoader.getSystemClassLoader()))</ID>
    <ID>MaxLineLength:DevCertificatesTest.kt$DevCertificatesTest$val oldNodeCaKeyStore = loadKeyStore(javaClass.classLoader.getResourceAsStream("regression-test/$OLD_NODE_DEV_KEYSTORE_FILE_NAME"), OLD_DEV_KEYSTORE_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$DEV_CA_KEY_STORE_PASS</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val p2pKeyStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "sslkeystore.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val p2pTrustStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "truststore.jks", DEV_CA_TRUST_STORE_PASS, DEV_CA_TRUST_STORE_PRIVATE_KEY_PASS)</ID>
    <ID>MaxLineLength:DevIdentityGenerator.kt$DevIdentityGenerator$val signingCertStore = FileBasedCertificateStoreSupplier(certificatesDirectory / "nodekeystore.jks", DEV_CA_KEY_STORE_PASS, DEV_CA_KEY_STORE_PASS)</ID>
    <ID>MaxLineLength:DigitalSignatureWithCert.kt$DigitalSignatureWithCert : DigitalSignature</ID>
    <ID>MaxLineLength:Disruption.kt$val shell = "for c in {1..$parallelism} ; do openssl enc -aes-128-cbc -in /dev/urandom -pass pass: -e &gt; /dev/null &amp; done &amp;&amp; JOBS=\$(jobs -p) &amp;&amp; (sleep $durationSeconds &amp;&amp; kill \$JOBS) &amp; wait"</ID>
    <ID>MaxLineLength:DockerContainerPusher.kt$DockerContainerPusher$override</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$@Deprecated("extraCordappPackagesToScan does not preserve the original CorDapp's versioning and metadata, which may lead to " + "misleading results in tests. Use withCordappsForAllNodes instead.") fun withExtraCordappPackagesToScan(extraCordappPackagesToScan: List&lt;String&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withCordappsForAllNodes(cordappsForAllNodes: Collection&lt;TestCordapp&gt;?): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withNotaryCustomOverrides(notaryCustomOverrides: Map&lt;String, Any?&gt;): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$DriverParameters$fun withWaitForAllNodesToFinish(waitForAllNodesToFinish: Boolean): DriverParameters</ID>
    <ID>MaxLineLength:Driver.kt$InProcess$ fun &lt;T&gt; startFlow(logic: FlowLogic&lt;T&gt;): CordaFuture&lt;T&gt;</ID>
    <ID>MaxLineLength:Driver.kt$JmxPolicy$@Deprecated("The default constructor does not turn on monitoring. Simply leave the jmxPolicy parameter unspecified if you wish to not " + "have monitoring turned on.")</ID>
    <ID>MaxLineLength:Driver.kt$PortAllocation.Incremental$@Deprecated("This has been superseded by net.corda.testing.driver.SharedMemoryIncremental.INSTANCE", ReplaceWith("SharedMemoryIncremental.INSTANCE"))</ID>
    <ID>MaxLineLength:Driver.kt$PortAllocation.Incremental$@Deprecated("This has been superseded by net.corda.testing.driver.SharedMemoryIncremental.INSTANCE", ReplaceWith("net.corda.testing.driver.DriverDSL.nextPort()"))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeConfiguration::rpcUsers.name to if (users.isEmpty()) defaultRpcUserList else users.map { it.toConfig().root().unwrapped() }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig + customOverrides, maximumHeapSize = spec.maximumHeapSize)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$NodeParameters(rpcUsers = spec.rpcUsers, verifierType = spec.verifierType, customOverrides = notaryConfig(nodeAddress, clusterAddress))</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$_notaries.map { notary -&gt; notary.map { handle -&gt; handle.nodeHandles } }.getOrThrow(notaryHandleTimeout).forEach { future -&gt; future.getOrThrow(notaryHandleTimeout) }</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$private</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val flowOverrideConfig = FlowOverrideConfig(parameters.flowOverrides.map { FlowOverride(it.key.canonicalName, it.value.canonicalName) })</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl$val jdbcUrl = "jdbc:h2:mem:persistence${inMemoryCounter.getAndIncrement()};DB_CLOSE_ON_EXIT=FALSE;LOCK_TIMEOUT=10000;WRITE_DELAY=100"</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$DriverDSLImpl.Companion$private operator fun Config.plus(property: Pair&lt;String, Any&gt;)</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$InternalDriverDSL$ fun &lt;A&gt; pollUntilNonNull(pollName: String, pollInterval: Duration = DEFAULT_POLL_INTERVAL, warnCount: Int = DEFAULT_WARN_COUNT, check: () -&gt; A?): CordaFuture&lt;A&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$InternalDriverDSL$ fun pollUntilTrue(pollName: String, pollInterval: Duration = DEFAULT_POLL_INTERVAL, warnCount: Int = DEFAULT_WARN_COUNT, check: () -&gt; Boolean): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:DriverDSLImpl.kt$fun DriverDSL.startNode(providedName: CordaX500Name, devMode: Boolean, parameters: NodeParameters = NodeParameters()): CordaFuture&lt;NodeHandle&gt;</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$newNode(CordaX500Name(commonName = "Regulator", organisation = "R3CEV", locality = "New York", country = "US"))().getOrThrow()</ID>
    <ID>MaxLineLength:DriverTests.kt$DriverTests$val logFile = (baseDirectory / NodeStartup.LOGS_DIRECTORY_NAME).list { it.filter { a -&gt; a.isRegularFile() &amp;&amp; a.fileName.toString().startsWith("node") }.findFirst().get() }</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$ @JvmStatic fun generateInitial(magicNumber: Int, notary: Party, owner: PartyAndReference, vararg otherOwners: PartyAndReference): TransactionBuilder</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID)</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$TransactionBuilder(notary).withItems(StateAndContract(state, PROGRAM_ID), Command(Commands.Create(), owners.map { it.party.owningKey }))</ID>
    <ID>MaxLineLength:DummyContract.kt$DummyContract.Companion$val items = arrayOf(StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID), Command(Commands.Create(), owners.first().party.owningKey), StateAndContract(SingleOwnerState(magicNumber, owners.first().party), PROGRAM_ID), Command(Commands.Create(), owners.first().party.owningKey))</ID>
    <ID>MaxLineLength:DummyDealStateSchemaV1.kt$DummyDealStateSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:DummyDealStateSchemaV1.kt$DummyDealStateSchemaV1.PersistentDummyDealState$@CollectionTable(name = "dummy_deal_states_parts", joinColumns = [(JoinColumn(name = "output_index", referencedColumnName = "output_index")), (JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"))])</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$"for reference ${issuer.reference} at issuer ${issuer.party} the amounts balance: ${inputAmount.quantity} - ${amountExitingLedger.quantity} != ${outputAmount.quantity}"</ID>
    <ID>MaxLineLength:DummyFungibleContract.kt$DummyFungibleContract$val exitCommand = tx.commands.select&lt;Commands.Exit&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:DummyIssueAndMove.kt$DummyIssueAndMove : FlowLogic</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV1.kt$DummyLinearStateSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV1.kt$DummyLinearStateSchemaV1.PersistentDummyLinearState$@Table(name = "dummy_linear_states", indexes = [Index(name = "external_id_idx", columnList = "external_id"), Index(name = "uuid_idx", columnList = "uuid")])</ID>
    <ID>MaxLineLength:DummyLinearStateSchemaV2.kt$DummyLinearStateSchemaV2.PersistentDummyLinearState$@CollectionTable(name = "dummy_linear_states_v2_parts", joinColumns = [(JoinColumn(name = "output_index", referencedColumnName = "output_index")), (JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"))])</ID>
    <ID>MaxLineLength:E2ETestKeyManagementService.kt$E2ETestKeyManagementService : SingletonSerializeAsTokenKeyManagementServiceInternal</ID>
    <ID>MaxLineLength:EdDSATests.kt$EdDSATests$assertNotEquals(testVectorEd25519ctx.signatureOutputHex, doSign(privateKey, testVectorEd25519ctx.messageToSignHex.hexToByteArray()).toHex().toLowerCase())</ID>
    <ID>MaxLineLength:EnumEvolutionSerializer.kt$EnumEvolutionSerializer$val converted = conversions[enumName] ?: throw AMQPNotSerializableException(type, "No rule to evolve enum constant $type::$enumName")</ID>
    <ID>MaxLineLength:EnumEvolvabilityTests.kt$EnumEvolvabilityTests$assertThatThrownBy { SerializationOutput(sf).serialize(C(RejectMultipleRenameFrom.A)) }.isInstanceOf(NotSerializableException::class.java) .hasToString("Unable to serialize/deserialize net.corda.serialization.internal.amqp.EnumEvolvabilityTests\$RejectMultipleRenameFrom: " + "There are multiple transformations from D, which is not allowed")</ID>
    <ID>MaxLineLength:ErrorCodeLoggingTests.kt$ErrorCodeLoggingTests$val linesWithErrorCode = logFile.useLines { lines -&gt; lines.filter { line -&gt; line.contains("[errorCode=") }.filter { line -&gt; line.contains("moreInformationAt=https://errors.corda.net/") }.toList() }</ID>
    <ID>MaxLineLength:ErrorCodeLoggingTests.kt$fun NodeHandle.logFile(): File</ID>
    <ID>MaxLineLength:ErrorFlowTransition.kt$ErrorFlowTransition$val (initiatedSessions, newSessions) = bufferErrorMessagesInInitiatingSessions(startingState.checkpoint.sessions, errorMessages)</ID>
    <ID>MaxLineLength:ErrorMessagesTests.kt$ErrorMessagesTests$@Ignore("Current behaviour allows for the serialization of objects with private members, this will be disallowed at some point in the future")</ID>
    <ID>MaxLineLength:Event.kt$Event.EnterSubFlow$data</ID>
    <ID>MaxLineLength:EventGenerator.kt$ErrorFlowsEventGenerator : EventGenerator</ID>
    <ID>MaxLineLength:EventGenerator.kt$ErrorFlowsEventGenerator$private</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$protected</ID>
    <ID>MaxLineLength:EventGenerator.kt$EventGenerator$protected val currencyMap: MutableMap&lt;Currency, Long&gt; = mutableMapOf(USD to 0L, GBP to 0L) // Used for estimation of how much money we have in general.</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests${ val resource = "EvolvabilityTests.evolutionWithPrimitives" val sf = testDefaultFactory() // Uncomment to recreate // File(URI("$localPath/$resource")).writeBytes(SerializationOutput(sf).serialize(ParameterizedContainer(Parameterized(10, setOf(20)))).bytes) val url = EvolvabilityTests::class.java.getResource(resource) val sc2 = url.readBytes() val deserialized = DeserializationInput(sf).deserialize(SerializedBytes&lt;ParameterizedContainer&gt;(sc2)) assertEquals(10, deserialized.parameterized?.a) }</ID>
    <ID>MaxLineLength:EvolvabilityTests.kt$EvolvabilityTests.Companion$private val DUMMY_NOTARY_PARTY = Party(DUMMY_NOTARY_NAME, Crypto.deriveKeyPairFromEntropy(Crypto.DEFAULT_SIGNATURE_SCHEME, BigInteger.valueOf(20)).public)</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$CompositeMessage$private</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$error != null &amp;&amp; level.isInRange(Level.FATAL, Level.WARN) -&gt; CompositeMessage("$formattedMessage [errorCode=${error.errorCode()}, moreInformationAt=${error.errorCodeLocationUrl()}]", format, parameters, throwable)</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$fun Throwable.errorCodeLocationUrl()</ID>
    <ID>MaxLineLength:ExceptionsErrorCodeFunctions.kt$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchAttachmentsFlow.FetchedAttachment$private</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchDataFlow$IllegalTransactionRequest : FlowException</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchNetworkParametersFlow$otherSide: FlowSession</ID>
    <ID>MaxLineLength:FetchDataFlow.kt$FetchTransactionsFlow : FetchDataFlow</ID>
    <ID>MaxLineLength:FiberUtils.kt$// TODO: This method uses a built-in Quasar function to make a map of all ThreadLocals. This is probably inefficient, but the only API readily available. fun &lt;V, T&gt; Fiber&lt;V&gt;.swappedOutThreadLocalValue(threadLocal: ThreadLocal&lt;T&gt;): T?</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, extraRecipients: Set&lt;Party&gt;) : this(transaction, extraRecipients, tracker(), emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$FinalityFlow$@Deprecated(DEPRECATION_MSG) constructor(transaction: SignedTransaction, progressTracker: ProgressTracker) : this(transaction, emptySet(), progressTracker, emptyList(), false)</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$private val statesToRecord: StatesToRecord = ONLY_RELEVANT</ID>
    <ID>MaxLineLength:FinalityFlow.kt$ReceiveFinalityFlow$return subFlow(object : ReceiveTransactionFlow(otherSideSession, checkSufficientSignatures = true, statesToRecord = statesToRecord) { override fun checkBeforeRecording(stx: SignedTransaction) { require(expectedTxId == null || expectedTxId == stx.id) { "We expected to receive transaction with ID $expectedTxId but instead got ${stx.id}. Transaction was" + "not recorded and nor its states sent to the vault." } } })</ID>
    <ID>MaxLineLength:FinanceJSONSupport.kt$CalendarDeserializer$StringArrayDeserializer.instance.deserialize(parser, context).fold(BusinessCalendar.EMPTY) { acc, name -&gt; acc + loadTestCalendar(name) }</ID>
    <ID>MaxLineLength:FinanceTypesTest.kt$FinanceTypesTest$val ret = BusinessCalendar.createGenericSchedule(startDate = LocalDate.of(2014, 11, 25), period = Frequency.Monthly, noOfAdditionalPeriods = 3)</ID>
    <ID>MaxLineLength:FinanceWorkflowsUtils.kt$val stream = UnknownCalendar::class.java.getResourceAsStream("/net/corda/finance/workflows/utils/${name}HolidayCalendar.txt") ?: throw UnknownCalendar(name)</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.Fixer$@Suspendable override</ID>
    <ID>MaxLineLength:FixingFlow.kt$FixingFlow.FixingRoleDecider$val counterparty = serviceHub.identityService.wellKnownPartyFromAnonymous(parties[1]) ?: throw IllegalStateException("Cannot resolve floater party")</ID>
    <ID>MaxLineLength:FlowCheckpointCordapp.kt$SendMessageFlow : FlowLogic</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val fullySignedTx: SignedTransaction = subFlow(CollectSignaturesFlow(twiceSignedTx, setOf(counterpartySession, regulatorSession), SIGS_GATHERING.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowCookbook.kt$InitiatorFlow$val notarisedTx1: SignedTransaction = subFlow(FinalityFlow(fullySignedTx, listOf(counterpartySession), FINALISATION.childProgressTracker()))</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(0, charlieNode.internals.checkpointStorage.checkpoints().size, "Checkpoints left after restored flow should have ended")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload + 1, secondFlow.getOrThrow().receivedPayload2, "Received payload does not match the expected second value on Node 2")</ID>
    <ID>MaxLineLength:FlowFrameworkPersistenceTests.kt$FlowFrameworkPersistenceTests$assertEquals(payload, secondFlow.getOrThrow().receivedPayload, "Received payload does not match the (restarted) first value on Node 2")</ID>
    <ID>MaxLineLength:FlowFrameworkTests.kt$FlowFrameworkTests$assertThat(receivedSessionMessages).hasSize(1)</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun &lt;R : Any&gt; receiveAll(receiveType: Class&lt;R&gt;, sessions: List&lt;FlowSession&gt;, maySkipCheckpoint: Boolean = false): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$ @Suspendable @JvmOverloads open fun receiveAllMap(sessions: Map&lt;FlowSession, Class&lt;out Any&gt;&gt;, maySkipCheckpoint: Boolean = false): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$?:</ID>
    <ID>MaxLineLength:FlowLogic.kt$FlowLogic$@Suspendable @JvmOverloads open</ID>
    <ID>MaxLineLength:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$if (ref !is FlowLogicRefImpl) throw IllegalFlowLogicException(ref.javaClass, "FlowLogicRef was not created via correct FlowLogicRefFactory interface")</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager$fun registerInitiatedCoreFlowFactory(initiatingFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;?, flowFactory: (FlowSession) -&gt; FlowLogic&lt;*&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$FlowManager$fun registerInitiatedCoreFlowFactory(initiatingFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: KClass&lt;out FlowLogic&lt;*&gt;&gt;?, flowFactory: InitiatedFlowFactory.Core&lt;FlowLogic&lt;*&gt;&gt;)</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$@Synchronized override</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$FlowWeightComparator : Comparator</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$log.warn("Multiple flows are registered for InitiatingFlow: $initiatingFlowClass, currently using: ${listOfFlowsForInitiator.first().initiatedFlowClass}")</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val equalWeightAsCurrentTip = toValidate.map { flowWeightComparator.compare(currentTip, it) to it }.filter { it.first == 0 }.map { it.second }</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager$val message = "Unable to determine which flow to use when responding to: ${currentTip.initiatingFlowClass.canonicalName}. ${equalWeightAsCurrentTip.map { it.initiatedFlowClass!!.canonicalName }} are all registered with equal weight."</ID>
    <ID>MaxLineLength:FlowManager.kt$NodeFlowManager.FlowWeightComparator$private open</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val mightDeadlockDrainingTarget = FlowStateMachineImpl.currentStateMachine()?.context?.origin.let { it is InvocationOrigin.Peer &amp;&amp; it.party == target.name }</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl$val networkMessage = serviceHub.networkService.createMessage(sessionTopic, serializeSessionMessage(message).bytes, deduplicationId, message.additionalHeaders(party))</ID>
    <ID>MaxLineLength:FlowMessaging.kt$FlowMessagingImpl${ // Handling Kryo and AMQP serialization problems. Unfortunately the two exception types do not share much of a common exception interface. if ((exception is KryoException || exception is NotSerializableException) &amp;&amp; message is ExistingSessionMessage &amp;&amp; message.payload is ErrorSessionMessage) { val error = message.payload.flowException val rewrappedError = FlowException(error?.message) message.copy(payload = message.payload.copy(flowException = rewrappedError)).serialize() } else { throw exception } }</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.SendAndReceive -&gt; "to send and receive messages from parties ${request.sessionToMessage.keys.partiesInvolved()}"</ID>
    <ID>MaxLineLength:FlowMonitor.kt$FlowMonitor$is FlowIORequest.Sleep -&gt; "to wake up from sleep ending at ${LocalDateTime.ofInstant(request.wakeUpAfter, ZoneId.systemDefault())}"</ID>
    <ID>MaxLineLength:FlowRetryTest.kt$FlowRetryTest$it.proxy.startFlow(::InitiatorFlow, numSessions, numIterations, nodeBHandle.nodeInfo.singleIdentity()).returnValue.getOrThrow()</ID>
    <ID>MaxLineLength:FlowSessionImpl.kt$FlowSessionImpl$@Suspendable override</ID>
    <ID>MaxLineLength:FlowStackSnapshot.kt$FlowStackSnapshotFactoryImpl$private</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;MultiplePersistingSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;PersistingNoSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$val a = startNode(rpcUsers = listOf(User(Constants.USER, Constants.PASSWORD, setOf(startFlow&lt;PersistingSideEffectFlow&gt;())))).get()</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$errorAndTerminate("Caught unrecoverable error from flow. Forcibly terminating the JVM, this might leave resources open, and most likely will.", t)</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl$require(continuation == FlowContinuation.ProcessEvents) { "Expected a continuation of type ${FlowContinuation.ProcessEvents}, found $continuation " }</ID>
    <ID>MaxLineLength:FlowStateMachineImpl.kt$FlowStateMachineImpl${ // This sets the Cordapp classloader on the contextClassLoader of the current thread. // Needed because in previous versions of the finance app we used Thread.contextClassLoader to resolve services defined in cordapps. Thread.currentThread().contextClassLoader = (serviceHub.cordappProvider as CordappProviderImpl).cordappLoader.appClassLoader val result = logic.call() suspend(FlowIORequest.WaitForSessionConfirmations, maySkipCheckpoint = true) Try.Success(result) }</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable fun &lt;R : Any&gt; FlowLogic&lt;*&gt;.receiveAll(receiveType: Class&lt;R&gt;, session: FlowSession, vararg sessions: FlowSession): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable fun FlowLogic&lt;*&gt;.receiveAll(session: Pair&lt;FlowSession, Class&lt;out Any&gt;&gt;, vararg sessions: Pair&lt;FlowSession, Class&lt;out Any&gt;&gt;): Map&lt;FlowSession, UntrustworthyData&lt;Any&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$ @Suspendable inline fun &lt;reified R : Any&gt; FlowLogic&lt;*&gt;.receiveAll(session: FlowSession, vararg sessions: FlowSession): List&lt;UntrustworthyData&lt;R&gt;&gt;</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$@Suspendable inline</ID>
    <ID>MaxLineLength:FlowTestsUtils.kt$return this.internals.registerInitiatedFlowFactory(initiatingFlowClass, initiatedFlowClass, InitiatedFlowFactory.Core(flowFactory), track)</ID>
    <ID>MaxLineLength:FlowsDrainingModeContentionTest.kt$FlowsDrainingModeContentionTest$val flow = nodeA.rpc.startFlow(::ProposeTransactionAndWaitForCommit, message, nodeARpcInfo, nodeB.nodeInfo.singleIdentity(), defaultNotaryIdentity)</ID>
    <ID>MaxLineLength:FlowsExecutionModeRpcTest.kt$FlowsExecutionModeRpcTest$val user = User("mark", "dadada", setOf(Permissions.invokeRpc("setFlowsDrainingModeEnabled"), Permissions.invokeRpc("isFlowsDrainingModeEnabled")))</ID>
    <ID>MaxLineLength:FlowsExecutionModeRpcTest.kt$FlowsExecutionModeTests$private</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$ForeignExchangeRemoteFlow$val ourKey = serviceHub.keyManagementService.filterMyKeys(ourInputState.flatMap { it.state.data.participants }.map { it.owningKey }).single()</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$private</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val eligibleStates = serviceHub.vaultService.tryLockFungibleStatesForSpending(lockId, fullCriteria, amountRequired.withoutIssuer(), Cash.State::class.java)</ID>
    <ID>MaxLineLength:FxTransactionBuildTutorial.kt$val ourParties = ourKeys.map { serviceHub.identityService.partyFromKey(it) ?: throw IllegalStateException("Unable to resolve party from key") }</ID>
    <ID>MaxLineLength:GenerateNodeInfoCli.kt$GenerateNodeInfoCli : NodeCliCommand</ID>
    <ID>MaxLineLength:GenerateRpcSslCertsCli.kt$GenerateRpcSslCertsCli : NodeCliCommand</ID>
    <ID>MaxLineLength:Generator.kt$Generator$fun &lt;B, C, D, E, R&gt; combine(other1: Generator&lt;B&gt;, other2: Generator&lt;C&gt;, other3: Generator&lt;D&gt;, other4: Generator&lt;E&gt;, function: (A, B, C, D, E) -&gt; R)</ID>
    <ID>MaxLineLength:Generator.kt$Generator$product&lt;R&gt;(other1.product(other2.product(other3.product(other4.product(pure({ e -&gt; { d -&gt; { c -&gt; { b -&gt; { a -&gt; function(a, b, c, d, e) } } } } }))))))</ID>
    <ID>MaxLineLength:GenericsTests.kt$GenericsTests.Companion$private val MINI_CORP_PARTY = Party(MINI_CORP_NAME, Crypto.deriveKeyPairFromEntropy(Crypto.DEFAULT_SIGNATURE_SCHEME, BigInteger.valueOf(20)).public)</ID>
    <ID>MaxLineLength:GuiUtilities.kt$// TODO: This is a temporary fix for the UI to show the correct issuer identity, this will break when we start randomizing keys. More work is needed here when the identity work is done. fun StateAndRef&lt;Cash.State&gt;.resolveIssuer(): ObservableValue&lt;Party?&gt;</ID>
    <ID>MaxLineLength:GuiUtilities.kt$fun PublicKey.toKnownParty()</ID>
    <ID>MaxLineLength:H2SecurityTests.kt$H2SecurityTests$startNode(customOverrides = mapOf(h2AddressKey to "${InetAddress.getLocalHost().hostAddress}:${getFreePort()}")).getOrThrow()</ID>
    <ID>MaxLineLength:HTTPNetworkRegistrationService.kt$HTTPNetworkRegistrationService$in TRANSIENT_ERROR_STATUS_CODES -&gt; throw ServiceUnavailableException("Could not connect with Doorman. Http response status code was ${conn.responseCode}.")</ID>
    <ID>MaxLineLength:HardRestartTest.kt$HardRestartTest$val rpc = tlRpc.get() ?: CordaRPCClient(a.rpcAddress).start(demoUser.username, demoUser.password).proxy.also { tlRpc.set(it) }</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaMaterializedBlobType : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$CordaWrapperBinaryType : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$MapBlobToPostgresByteA : AbstractSingleColumnStandardBasicType</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$private</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$private val sessionFactories = cacheFactory.buildNamed&lt;Set&lt;MappedSchema&gt;, SessionFactory&gt;(Caffeine.newBuilder(), "HibernateConfiguration_sessionFactories")</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration$val config = Configuration(metadataSources).setProperty("hibernate.connection.provider_class", NodeDatabaseConnectionProvider::class.java.name) .setProperty("hibernate.format_sql", "true") .setProperty("hibernate.hbm2ddl.auto", hbm2dll) .setProperty("javax.persistence.validation.mode", "none") .setProperty("hibernate.connection.isolation", databaseConfig.transactionIsolationLevel.jdbcValue.toString())</ID>
    <ID>MaxLineLength:HibernateConfiguration.kt$HibernateConfiguration.Companion$// register custom converters fun buildHibernateMetadata(metadataBuilder: MetadataBuilder, jdbcUrl:String, attributeConverters: Collection&lt;AttributeConverter&lt;*, *&gt;&gt;): Metadata</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$cashStates = vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, numStates, issuer.ref(1), rng = Random(0L)).states.toList()</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$criteriaQuery.where(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultCashStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$criteriaQuery.where(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$database = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$database = configureDatabase(dataSourceProps, DatabaseConfig(initialiseSchema = initialiseSchema), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService)</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$println("${it.stateRef} with owner ${cashState.owner.owningKey.toBase58String()} and participants ${cashState.participants.map { it.owningKey.toBase58String() }}")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$println("${vaultState.stateRef} : [${_dummyLinearStates.externalId} ${_dummyLinearStates.uuid}] : [${_vaultLinearStates.externalId} ${_vaultLinearStates.uuid}]")</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate = criteriaBuilder.and(andDummyLinearStatesPredicate1, criteriaBuilder.and(andDummyLinearStatesPredicate2, andDummyLinearStatesPredicate3))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate1 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;String&gt;("linearString"), "123"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andDummyLinearStatesPredicate3 = criteriaBuilder.and(criteriaBuilder.equal(dummyLinearStates.get&lt;Boolean&gt;("linearBoolean"), true))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val andLinearStatesPredicate1 = criteriaBuilder.and(criteriaBuilder.equal(vaultLinearStates.get&lt;String&gt;("externalId"), uniqueID456.externalId))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val cashStates = vaultFiller.fillWithSomeTestCash(100.DOLLARS, issuerServices, 2, issuer.ref(1), ALICE, Random(0L)).states</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate1 = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), vaultLinearStates.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinPredicate2 = criteriaBuilder.and(criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), dummyLinearStates.get&lt;PersistentStateRef&gt;("stateRef")))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val joinVaultStatesToCash = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), cashStatesSchema.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest$val schemaService = NodeSchemaService(extraSchemas = setOf(CashSchemaV1, SampleCashSchemaV1, SampleCashSchemaV2, SampleCashSchemaV3, DummyLinearStateSchemaV1, DummyLinearStateSchemaV2, DummyDealStateSchemaV1))</ID>
    <ID>MaxLineLength:HibernateConfigurationTest.kt$HibernateConfigurationTest.&lt;no name provided&gt;$override val vaultService = NodeVaultService(Clock.systemUTC(), keyManagementService, servicesForResolution, database, schemaService, cordappClassloader).apply { start() }</ID>
    <ID>MaxLineLength:HibernateInteractionTests.kt$HibernateInteractionTests$// AbstractPartyToX500NameAsStringConverter could cause circular flush of Hibernate session because it is invoked during flush, and a // cache miss was doing a flush. This also checks that loading during flush does actually work. @Test fun `issue some cash on a notary that exists only in the database to check cache loading works in our identity column converters during flush of vault update`()</ID>
    <ID>MaxLineLength:HibernateInteractionTests.kt$HibernateInteractionTests$@Test fun `when a cascade is in progress (because of nested entities), the node avoids to flush &amp; detach entities, since it's not allowed by Hibernate`()</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$abstract</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$AbstractQueryCriteriaParser&lt;AttachmentQueryCriteria, AttachmentsQueryCriteriaParser, AttachmentSort&gt;(), AttachmentsQueryCriteriaParser</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$private val criteriaQuery: CriteriaQuery&lt;NodeAttachmentService.DBAttachment&gt;</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$val joinDBAttachmentToContractClassNames = root.joinList&lt;NodeAttachmentService.DBAttachment, ContractClassName&gt;("contractClassNames")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.and(vaultStates.get&lt;String&gt;(VaultSchemaV1.VaultStates::contractStateClassName.name).`in`(contractStateTypes.plus(existingTypes))))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.and(vaultStates.get&lt;Vault.ConstraintInfo.Type&gt;(VaultSchemaV1.VaultStates::constraintType.name).`in`(criteria.constraintTypes.plus(existingTypes))))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.equal(vaultStates.get&lt;Vault.RelevancyStatus&gt;(VaultSchemaV1.VaultStates::relevancyStatus.name), criteria.relevancyStatus))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates.replace(predicateID, criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), criteria.status))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.and(vaultStates.get&lt;String&gt;(VaultSchemaV1.VaultStates::contractStateClassName.name).`in`(contractStateTypes))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.and(vaultStates.get&lt;Vault.ConstraintInfo.Type&gt;(VaultSchemaV1.VaultStates::constraintType.name).`in`(criteria.constraintTypes))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.equal(vaultStates.get&lt;Vault.RelevancyStatus&gt;(VaultSchemaV1.VaultStates::relevancyStatus.name), criteria.relevancyStatus)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$commonPredicates[predicateID] = criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), criteria.status)</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;IndirectStatePersistable&lt;*&gt;&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$elem</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$if (path is SingularAttributePath) //remove the same columns from different joins to match the single column in 'group by' only (from the last join) aggregateExpressions.removeAll { elem -&gt; if (elem is SingularAttributePath) elem.attribute.javaMember == path.attribute.javaMember else false }</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Enriching previous attribute [${VaultSchemaV1.VaultStates::constraintType.name}] values [$existingTypes] with [${criteria.constraintTypes}]")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Enriching previous attribute [${VaultSchemaV1.VaultStates::contractStateClassName.name}] values [$existingTypes] with [$contractStateTypes]")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Overriding previous attribute [${VaultSchemaV1.VaultStates::relevancyStatus.name}] value $existingStatus with ${criteria.status}")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$log.warn("Overriding previous attribute [${VaultSchemaV1.VaultStates::stateStatus.name}] value $existingStatus with ${criteria.status}")</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$orderCriteria.add(criteriaBuilder.asc(sortEntityRoot.get&lt;String&gt;(entityStateAttributeParent).get&lt;String&gt;(entityStateAttributeChild)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$orderCriteria.add(criteriaBuilder.desc(sortEntityRoot.get&lt;String&gt;(entityStateAttributeParent).get&lt;String&gt;(entityStateAttributeChild)))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$private</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$shiftLeft += columnNumberBeforeRemoval - aggregateExpressions.size</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$sorting.copy(columns = sorting.columns + Sort.SortColumn(SortAttribute.Standard(Sort.CommonStateAttribute.STATE_REF), Sort.Direction.ASC))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val existingTypes = (commonPredicates[predicateID]!!.expressions[0] as InPredicate&lt;*&gt;).values.map { (it as LiteralExpression).literal }.toSet()</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val externalIdJoin = criteriaBuilder.equal(vaultStates.get&lt;VaultSchemaV1.VaultStates&gt;("stateRef"), entityRoot.get&lt;VaultSchemaV1.StateToExternalId&gt;("compositeKey").get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val joinPredicate = criteriaBuilder.equal(vaultStates.get&lt;PersistentStateRef&gt;("stateRef"), entityRoot.get&lt;PersistentStateRef&gt;("stateRef"))</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val predicateConstraintData = criteriaBuilder.equal(vaultStates.get&lt;Vault.ConstraintInfo&gt;(VaultSchemaV1.VaultStates::constraintData.name), constraint.data())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val predicateConstraintType = criteriaBuilder.equal(vaultStates.get&lt;Vault.ConstraintInfo&gt;(VaultSchemaV1.VaultStates::constraintType.name), constraint.type())</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$val vaultStates: Root&lt;VaultSchemaV1.VaultStates&gt;</ID>
    <ID>MaxLineLength:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser${ @Suppress("UNCHECKED_CAST") column as Path&lt;Long?&gt;? val aggregateExpression = when (columnPredicate.type) { AggregateFunctionType.SUM -&gt; criteriaBuilder.sum(column) AggregateFunctionType.AVG -&gt; criteriaBuilder.avg(column) AggregateFunctionType.COUNT -&gt; criteriaBuilder.count(column) AggregateFunctionType.MAX -&gt; criteriaBuilder.max(column) AggregateFunctionType.MIN -&gt; criteriaBuilder.min(column) } //TODO investigate possibility to avoid producing redundant joins in SQL for multiple aggregate functions against the same table aggregateExpressions.add(aggregateExpression) // Some databases may not support aggregate expression in 'group by' clause e.g. 'group by sum(col)', // Hibernate Criteria Builder can't produce alias 'group by col_alias', and the only solution is to use a positional parameter 'group by 1' val orderByColumnPosition = aggregateExpressions.size var shiftLeft = 0 // add optional group by clauses expression.groupByColumns?.let { columns -&gt; val groupByExpressions = columns.map { _column -&gt; val path = root.get&lt;Any?&gt;(getColumnName(_column)) val columnNumberBeforeRemoval = aggregateExpressions.size if (path is SingularAttributePath) //remove the same columns from different joins to match the single column in 'group by' only (from the last join) aggregateExpressions.removeAll { elem -&gt; if (elem is SingularAttributePath) elem.attribute.javaMember == path.attribute.javaMember else false } shiftLeft += columnNumberBeforeRemoval - aggregateExpressions.size //record how many times a duplicated column was removed (from the previous 'parseAggregateFunction' run) aggregateExpressions.add(path) path } criteriaQuery.groupBy(groupByExpressions) } // optionally order by this aggregate function expression.orderBy?.let { val orderCriteria = when (expression.orderBy!!) { // when adding column position of 'group by' shift in case columns were removed Sort.Direction.ASC -&gt; criteriaBuilder.asc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft)) Sort.Direction.DESC -&gt; criteriaBuilder.desc(criteriaBuilder.literal&lt;Int&gt;(orderByColumnPosition - shiftLeft)) } criteriaQuery.orderBy(orderCriteria) } return aggregateExpression }</ID>
    <ID>MaxLineLength:HttpApi.kt$HttpApi.Companion$fun fromHostAndPort(hostAndPort: NetworkHostAndPort, base: String, protocol: String = "http", mapper: ObjectMapper = defaultMapper): HttpApi</ID>
    <ID>MaxLineLength:IRS.kt$FixedRatePaymentEvent$override val flow: Amount&lt;Currency&gt; get() = Amount(dayCountFactor.times(BigDecimal(notional.quantity)).times(rate.ratioUnit!!.value).toLong(), notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$override fun asCSV(): String</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$override fun toString(): String</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$rate: Rate</ID>
    <ID>MaxLineLength:IRS.kt$FloatingRatePaymentEvent$rate: Rate = this.rate</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("3M")), 1.5.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate, Tenor("9M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBOR", tradeDate.plusYears(1), Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$IRS$command(highStreetBank.owningKey, UniversalContract.Commands.Fix(listOf(net.corda.finance.contracts.Fix(FixOf("LIBORx", tradeDate, Tenor("3M")), 1.0.bd))))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap : Contract</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The effective date is before the termination date for the fixed leg" using (irs.fixedLeg.effectiveDate &lt; irs.fixedLeg.terminationDate)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The effective date is before the termination date for the floating leg" using (irs.floatingLeg.effectiveDate &lt; irs.floatingLeg.terminationDate)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fix payment has the same currency as the notional" using (newFixedRatePaymentEvent.flow.token == irs.floatingLeg.notional.token)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixed leg parties are constant" using (irs.fixedLeg.fixedRatePayer == prevIrs.fixedLeg.fixedRatePayer)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$"The fixed leg payment schedule is constant" using (irs.calculation.fixedLegPaymentSchedule == prevIrs.calculation.fixedLegPaymentSchedule)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$TransactionBuilder(notary) .addCommand(Command(Commands.Agree(), listOf(state.floatingLeg.floatingRatePayer.owningKey, state.fixedLeg.fixedRatePayer.owningKey)))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$private</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$tx.addCommand(Commands.Refix(fixing), listOf(irs.state.data.floatingLeg.floatingRatePayer.owningKey, irs.state.data.fixedLeg.fixedRatePayer.owningKey))</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val (oldFloatingRatePaymentEvent, newFixedRatePaymentEvent) = paymentDifferences.single().second // Ignore the date of the changed rate (we checked that earlier).</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap$val paymentDifferences = getFloatingLegPaymentsDifferences(prevIrs.calculation.floatingLegPaymentSchedule, irs.calculation.floatingLegPaymentSchedule)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Calculation$return floatingLegPaymentSchedule.filter { it.value.rate is ReferenceRate }.// TODO - a better way to determine what fixings remain to be fixed minBy { it.value.fixingDate.toEpochDay() }?.value?.fixingDate</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.Common$val valuationDateDescription: String</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$"PaymentRule=$paymentRule,PaymentDelay=$paymentDelay,PaymentCalendar=$paymentCalendar,InterestPeriodAdjustment=$interestPeriodAdjustment"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$"TerminationDateAdjustment=$terminationDateAdjustment,DayCountBasis=$dayCountBasisDay/$dayCountBasisYear,DayInMonth=$dayInMonth,"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.CommonLeg$return "Notional=$notional,PaymentFrequency=$paymentFrequency,EffectiveDate=$effectiveDate,EffectiveDateAdjustment:$effectiveDateAdjustment,TerminatationDate=$terminationDate," + "TerminationDateAdjustment=$terminationDateAdjustment,DayCountBasis=$dayCountBasisDay/$dayCountBasisYear,DayInMonth=$dayInMonth," + "PaymentRule=$paymentRule,PaymentDelay=$paymentDelay,PaymentCalendar=$paymentCalendar,InterestPeriodAdjustment=$interestPeriodAdjustment"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.FloatingLeg$"FixingPeriondOffset=$fixingPeriodOffset,ResetRule=$resetRule,FixingsPerPayment=$fixingsPerPayment,FixingCalendar=$fixingCalendar,"</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$InterestRateSwap().generateFix(ptx, StateAndRef(TransactionState(this, IRS_PROGRAM_ID, oldState.state.notary, constraint = AlwaysAcceptAttachmentConstraint), oldState.ref), fix)</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State$val instant = suggestInterestRateAnnouncementTimeWindow(index = nextFixingOf.name, source = floatingLeg.indexSource, date = nextFixingOf.forDay).fromTime!!</ID>
    <ID>MaxLineLength:IRS.kt$InterestRateSwap.State${ val nextFixingOf = nextFixingOf() ?: return null // This is perhaps not how we should determine the time point in the business day, but instead expect the schedule to detail some of these aspects val instant = suggestInterestRateAnnouncementTimeWindow(index = nextFixingOf.name, source = floatingLeg.indexSource, date = nextFixingOf.forDay).fromTime!! return ScheduledActivity(flowLogicRefFactory.create("net.corda.irs.flows.FixingFlow\$FixingRoleDecider", thisStateRef), instant) }</ID>
    <ID>MaxLineLength:IRS.kt$RatePaymentEvent$// TODO : Fix below (use daycount convention for division, not hardcoded 360 etc) val dayCountFactor: BigDecimal get() = (BigDecimal(days).divide(BigDecimal(360.0), 8, RoundingMode.HALF_UP)).setScale(4, RoundingMode.HALF_UP)</ID>
    <ID>MaxLineLength:IRSDemo.kt$Role.Trade -&gt; IRSDemoClientApi(NetworkHostAndPort("localhost", 10007)).runTrade(value, CordaX500Name.parse("O=Notary Service,L=Zurich,C=CH"))</ID>
    <ID>MaxLineLength:IRSDemoDockerTest.kt$IRSDemoDockerTest.Companion$DockerComposeRule.builder() .files(DockerComposeFiles.from( System.getProperty("CORDAPP_DOCKER_COMPOSE"), System.getProperty("WEB_DOCKER_COMPOSE"))) .waitingForService("web-a", HealthChecks.toRespondOverHttp(8080, { port -&gt; port.inFormat("http://\$HOST:\$EXTERNAL_PORT") }))</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest$val (controllerApi, nodeAApi, nodeBApi) = listOf(controller, nodeA, nodeB).zip(listOf(controllerAddr, nodeAAddr, nodeBAddr)).map { val mapper = JacksonSupport.createDefaultMapper(it.first.rpc) registerFinanceJSONMappers(mapper) registerIRSModule(mapper) HttpApi.fromHostAndPort(it.second, "api/irs", mapper = mapper) }</ID>
    <ID>MaxLineLength:IRSDemoTest.kt$IRSDemoTest.InterestRateSwapStateDeserializer$InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, linearId = linearId, oracle = oracle)</ID>
    <ID>MaxLineLength:IRSState.kt$IRSState$return TransactionBuilder(notary).withItems(StateAndContract(state, IRS_PROGRAM_ID), Command(OGTrade.Commands.Agree(), participants.map { it.owningKey }))</ID>
    <ID>MaxLineLength:IRSTests.kt$"(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"</ID>
    <ID>MaxLineLength:IRSTests.kt$( // TODO: this seems to fail quite dramatically //expression = "fixedLeg.notional * fixedLeg.fixedRate", // TODO: How I want it to look //expression = "( fixedLeg.notional * (fixedLeg.fixedRate)) - (floatingLeg.notional * (rateSchedule.get(context.getDate('currentDate'))))", // How it's ended up looking, which I think is now broken but it's a WIP. expression = Expression("( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) -" + "(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"), floatingLegPaymentSchedule = mutableMapOf(), fixedLegPaymentSchedule = mutableMapOf() )</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$( "fixedLeg.notional.quantity", "fixedLeg.fixedRate.ratioUnit", "fixedLeg.fixedRate.ratioUnit.value", "floatingLeg.notional.quantity", "fixedLeg.fixedRate", "currentBusinessDate", "calculation.floatingLegPaymentSchedule.get(currentBusinessDate)", "fixedLeg.notional.token.currencyCode", "fixedLeg.notional.quantity * 10", "fixedLeg.notional.quantity * fixedLeg.fixedRate.ratioUnit.value", "(fixedLeg.notional.token.currencyCode.equals('GBP')) ? 365 : 360 ", "(fixedLeg.notional.quantity * (fixedLeg.fixedRate.ratioUnit.value))" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate" // "calculation.floatingLegPaymentSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value", //"( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) - (floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))", // "( fixedLeg.notional * fixedLeg.fixedRate )" )</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedFirstResetValue = firstResetValue!!.copy(notional = Amount(firstResetValue.notional.quantity, Currency.getInstance("JPY")))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS = irs.copy(fixedLeg = irs.fixedLeg.copy(notional = Amount(irs.fixedLeg.notional.quantity, Currency.getInstance("JPY"))))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedIRS = irs.copy(fixedLeg = irs.fixedLeg.copy(notional = Amount(irs.floatingLeg.notional.quantity + 1, irs.floatingLeg.notional.token)))</ID>
    <ID>MaxLineLength:IRSTests.kt$IRSTests$val modifiedLatestResetValue = latestReset!!.value.copy(notional = Amount(latestReset.value.notional.quantity, Currency.getInstance("JPY")))</ID>
    <ID>MaxLineLength:IRSTests.kt$InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY)</ID>
    <ID>MaxLineLength:IRSTests.kt$dailyInterestAmount = Expression("(CashAmount * InterestRate ) / (fixedLeg.notional.currency.currencyCode.equals('GBP')) ? 365 : 360")</ID>
    <ID>MaxLineLength:IRSTests.kt$return InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY)</ID>
    <ID>MaxLineLength:IRSTests.kt${ // 10y swap, we pay 1.3% fixed 30/360 semi, rec 3m usd libor act/360 Q on 25m notional (mod foll/adj on both sides) // I did a mock up start date 10/03/2015 – 10/03/2025 so you have 5 cashflows on float side that have been preset the rest are unknown val fixedLeg = InterestRateSwap.FixedLeg( fixedRatePayer = MEGA_CORP, notional = 25000000.DOLLARS, paymentFrequency = Frequency.SemiAnnual, effectiveDate = LocalDate.of(2015, 3, 10), effectiveDateAdjustment = null, terminationDate = LocalDate.of(2025, 3, 10), terminationDateAdjustment = null, fixedRate = FixedRate(PercentageRatioUnit("1.3")), dayCountBasisDay = DayCountBasisDay.D30, dayCountBasisYear = DayCountBasisYear.Y360, rollConvention = DateRollConvention.ModifiedFollowing, dayInMonth = 10, paymentRule = PaymentRule.InArrears, paymentDelay = 0, paymentCalendar = BusinessCalendar.EMPTY, interestPeriodAdjustment = AccrualAdjustment.Adjusted ) val floatingLeg = InterestRateSwap.FloatingLeg( floatingRatePayer = MINI_CORP, notional = 25000000.DOLLARS, paymentFrequency = Frequency.Quarterly, effectiveDate = LocalDate.of(2015, 3, 10), effectiveDateAdjustment = null, terminationDate = LocalDate.of(2025, 3, 10), terminationDateAdjustment = null, dayCountBasisDay = DayCountBasisDay.DActual, dayCountBasisYear = DayCountBasisYear.Y360, rollConvention = DateRollConvention.ModifiedFollowing, fixingRollConvention = DateRollConvention.ModifiedFollowing, dayInMonth = 10, resetDayInMonth = 10, paymentRule = PaymentRule.InArrears, paymentDelay = 0, paymentCalendar = BusinessCalendar.EMPTY, interestPeriodAdjustment = AccrualAdjustment.Adjusted, fixingPeriodOffset = 2, resetRule = PaymentRule.InAdvance, fixingsPerPayment = Frequency.Quarterly, fixingCalendar = BusinessCalendar.EMPTY, index = "USD LIBOR", indexSource = "TEL3750", indexTenor = Tenor("3M") ) val calculation = InterestRateSwap.Calculation( // TODO: this seems to fail quite dramatically //expression = "fixedLeg.notional * fixedLeg.fixedRate", // TODO: How I want it to look //expression = "( fixedLeg.notional * (fixedLeg.fixedRate)) - (floatingLeg.notional * (rateSchedule.get(context.getDate('currentDate'))))", // How it's ended up looking, which I think is now broken but it's a WIP. expression = Expression("( fixedLeg.notional.pennies * (fixedLeg.fixedRate.ratioUnit.value)) -" + "(floatingLeg.notional.pennies * (calculation.fixingSchedule.get(context.getDate('currentDate')).rate.ratioUnit.value))"), floatingLegPaymentSchedule = mutableMapOf(), fixedLegPaymentSchedule = mutableMapOf() ) val common = InterestRateSwap.Common( baseCurrency = EUR, eligibleCurrency = EUR, eligibleCreditSupport = "Cash in an Eligible Currency", independentAmounts = Amount(0, EUR), threshold = Amount(0, EUR), minimumTransferAmount = Amount(250000 * 100, EUR), rounding = Amount(10000 * 100, EUR), valuationDateDescription = "Every Local Business Day", notificationTime = "2:00pm London", resolutionTime = "2:00pm London time on the first LocalBusiness Day following the date on which the notice is given ", interestRate = ReferenceRate("T3270", Tenor("6M"), "EONIA"), addressForTransfers = "", exposure = UnknownType(), localBusinessDay = loadTestCalendar("London"), tradeID = "trade2", hashLegalDocs = "put hash here", dailyInterestAmount = Expression("(CashAmount * InterestRate ) / (fixedLeg.notional.currency.currencyCode.equals('GBP')) ? 365 : 360") ) return InterestRateSwap.State(fixedLeg = fixedLeg, floatingLeg = floatingLeg, calculation = calculation, common = common, oracle = DUMMY_PARTY) }</ID>
    <ID>MaxLineLength:IRSTradeFlow.kt$IRSTradeFlow.Requester$val notary = serviceHub.networkMapCache.notaryIdentities.first() // TODO We should pass the notary as a parameter to the flow, not leave it to random choice.</ID>
    <ID>MaxLineLength:IRSUtils.kt$net.corda.irs.contract.IRSUtils.kt</ID>
    <ID>MaxLineLength:IRSUtils.kt$operator</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer$private</ID>
    <ID>MaxLineLength:IdenticonRenderer.kt$IdenticonRenderer$private val patchFlags = byteArrayOf(PATCH_SYMMETRIC, 0, 0, 0, PATCH_SYMMETRIC, 0, 0, 0, PATCH_SYMMETRIC, 0, 0, 0, 0, 0, 0, (PATCH_SYMMETRIC + PATCH_INVERTED).toByte())</ID>
    <ID>MaxLineLength:IdentityService.kt$IdentityService$ @Suspendable fun externalIdForPublicKey(publicKey: PublicKey): UUID?</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$Assert.assertThat(nameToHashResultSet.getString(1), `is`(anyOf(groupedByNameIdentities.getValue(it.name).map&lt;PartyAndCertificate, Matcher&lt;String&gt;?&gt; { identity -&gt; CoreMatchers.equalTo(identity.name.toString()) })))</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val hashToIdentityStatement = database.dataSource.connection.prepareStatement("SELECT ${PersistentIdentityService.PK_HASH_COLUMN_NAME} FROM ${PersistentIdentityService.HASH_TO_IDENTITY_TABLE_NAME} WHERE pk_hash=?")</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val hashToIdentityStatement = database.dataSource.connection.prepareStatement("SELECT ${PersistentIdentityService.PK_HASH_COLUMN_NAME} FROM ${PersistentIdentityService.HASH_TO_IDENTITY_TABLE_NAME} WHERE pk_hash=?") hashToIdentityStatement.setString(1, it.owningKey.toStringShort()) val hashToIdentityResultSet = hashToIdentityStatement.executeQuery() //check that there is a row for every "new" hash Assert.assertThat(hashToIdentityResultSet.next(), `is`(true)) //check that the pk_hash actually matches what we expect (kinda redundant, but deserializing the whole PartyAndCertificate feels like overkill) Assert.assertThat(hashToIdentityResultSet.getString(1), `is`(it.owningKey.toStringShort())) val nameToHashStatement = connection.prepareStatement("SELECT ${PersistentIdentityService.NAME_COLUMN_NAME} FROM ${PersistentIdentityService.NAME_TO_HASH_TABLE_NAME} WHERE pk_hash=?") nameToHashStatement.setString(1, it.owningKey.toStringShort()) val nameToHashResultSet = nameToHashStatement.executeQuery() //if there is no result for this key, this means its an identity that is not stored in the DB (IE, it's been seen after another identity has already been mapped to it) if (nameToHashResultSet.next()) { Assert.assertThat(nameToHashResultSet.getString(1), `is`(anyOf(groupedByNameIdentities.getValue(it.name).map&lt;PartyAndCertificate, Matcher&lt;String&gt;?&gt; { identity -&gt; CoreMatchers.equalTo(identity.name.toString()) }))) } else { logger.warn("did not find a PK_HASH for ${it.name}") listOfNamesWithoutPkHash.add(it.name) }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val nameToHashStatement = connection.prepareStatement("SELECT ${PersistentIdentityService.NAME_COLUMN_NAME} FROM ${PersistentIdentityService.NAME_TO_HASH_TABLE_NAME} WHERE pk_hash=?")</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val persistentIDs = certs.map { PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.hash.toString(), it.certPath.encoded) }</ID>
    <ID>MaxLineLength:IdentityServiceToStringShortMigrationTest.kt$IdentityServiceToStringShortMigrationTest$val persistentName = PersistentIdentityService.PersistentPartyToPublicKeyHash(name.toString(), certs.first().owningKey.hash.toString())</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Receive$// Store the received confidential identities in the identity service so we have a record of which well known identity they map to. serviceHub.identityService.verifyAndRegisterIdentity(identity)</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$confidentialIdentities .map { @Suppress("DEPRECATION") Pair(it, serviceHub.identityService.certificateFromKey(it.owningKey)) } // Filter down to confidential identities of our well known identity // TODO: Consider if this too restrictive - we perhaps should be checking the name on the signing certificate in the certificate path instead .filter { it.second?.name == ourIdentity.name }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$require(req.all { it in identityCertificates.keys }) { "${otherSideSession.counterparty} requested a confidential identity not part of transaction: ${tx.id}" }</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$throw IllegalStateException("Counterparty requested a confidential identity for which we do not have the certificate path: ${tx.id}")</ID>
    <ID>MaxLineLength:IdentitySyncFlow.kt$IdentitySyncFlow.Send$val requestedIdentities: List&lt;AbstractParty&gt; = otherSideSession.sendAndReceive&lt;List&lt;AbstractParty&gt;&gt;(identityCertificates.keys.toList()).unwrap { req -&gt; require(req.all { it in identityCertificates.keys }) { "${otherSideSession.counterparty} requested a confidential identity not part of transaction: ${tx.id}" } req }</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$assertNotNull(aliceNode.database.transaction { aliceNode.services.identityService.wellKnownPartyFromAnonymous(confidentialIdentity) })</ID>
    <ID>MaxLineLength:IdentitySyncFlowTests.kt$IdentitySyncFlowTests$val confidentialIdentCert = @Suppress("DEPRECATION") charlieNode.services.identityService.certificateFromKey(confidentialIdentity.owningKey)!!</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ // Cannot use @JvmOverloads in interface @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupAbstractPartyByWellKnownParty(serviceHub: ServiceHub, parties: Collection&lt;AbstractParty&gt;, ignoreUnrecognisedParties: Boolean): Map&lt;Party, List&lt;AbstractParty&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ @Throws(IllegalArgumentException::class) fun groupPublicKeysByWellKnownParty(serviceHub: ServiceHub, publicKeys: Collection&lt;PublicKey&gt;, ignoreUnrecognisedParties: Boolean): Map&lt;Party, List&lt;PublicKey&gt;&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$ fun &lt;T&gt; excludeHostNode(serviceHub: ServiceHub, map: Map&lt;Party, T&gt;): Map&lt;Party, T&gt;</ID>
    <ID>MaxLineLength:IdentityUtils.kt$(serviceHub.identityService.wellKnownPartyFromAnonymous(it) ?: if (ignoreUnrecognisedParties) return@mapNotNull null else throw IllegalArgumentException("Could not find Party for $it")) to it</ID>
    <ID>MaxLineLength:IdentityUtils.kt$groupAbstractPartyByWellKnownParty(serviceHub, publicKeys.map { AnonymousParty(it) }, ignoreUnrecognisedParties).mapValues { it.value.map { it.owningKey } }</ID>
    <ID>MaxLineLength:IdentityUtils.kt$val components = listOfNotNull(x500name.commonName, x500name.organisationUnit, x500name.organisation, x500name.locality, x500name.state, x500name.country)</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$log.warn("Certificate validation failed for ${identity.name} against trusted root ${trustAnchor.trustedCert.subjectX500Principal}.")</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$results += keyToPartyAndCerts[key]?.party ?: throw IllegalArgumentException("Could not find an entry in the database for the public key $key.")</ID>
    <ID>MaxLineLength:InMemoryIdentityService.kt$InMemoryIdentityService$throw NotImplementedError("This method is not implemented in the InMemoryIdentityService at it requires access to CordaPersistence.")</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$listOf("Org A", "Org B", "Org C") .map { getTestPartyAndCertificate(CordaX500Name(organisation = it, locality = "London", country = "GB"), generateKeyPair().public) }</ID>
    <ID>MaxLineLength:InMemoryIdentityServiceTests.kt$InMemoryIdentityServiceTests$val alicente = getTestPartyAndCertificate(CordaX500Name(organisation = "Alicente Worldwide", locality = "London", country = "GB"), generateKeyPair().public)</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$peersMapping[messagingService.myAddress.name] = messagingService.myAddress</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork$private val servicePeerAllocationStrategy: ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:InMemoryMessagingNetwork.kt$InMemoryMessagingNetwork.Companion$servicePeerAllocationStrategy: ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:InMemoryTransactionVerifierService.kt$InMemoryTransactionVerifierService : SingletonSerializeAsTokenTransactionVerifierServiceTransactionVerifierServiceInternalAutoCloseable</ID>
    <ID>MaxLineLength:InfrequentlyMutatedCacheTest.kt$InfrequentlyMutatedCacheTest$@Test fun `fourth get outside first transaction from empty cache with invalidate in other thread in the middle returns result of second loader`()</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration : RunAfterNodeInitialisationNodeStartupLogging</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$println("Node was started before with `--initial-registration`, but the registration was not completed.\nResuming registration.")</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistration$println("Successfully registered Corda node with compatibility zone, node identity keys and certificates are stored in '${conf.certificatesDirectory}', it is advised to backup the private keys and certificates.")</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli : CliWrapperBase</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$@Option(names = ["-p", "--network-root-truststore-password"], description = ["Network root trust store password obtained from network operator."], required = true)</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$return startup.initialiseAndRun(cmdLineOptions, InitialRegistration(cmdLineOptions.baseDirectory, networkRootTrustStorePath, networkRootTrustStorePassword, startup))</ID>
    <ID>MaxLineLength:InitialRegistrationCli.kt$InitialRegistrationCli$val networkRootTrustStorePath: Path = networkRootTrustStorePathParameter ?: cmdLineOptions.baseDirectory / "certificates" / "network-root-truststore.jks"</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$InstallShellExtensionsParser : CliWrapperBase</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$printWarning("Cannot install shell extension for bash major version earlier than $minSupportedBashVersion. Please upgrade your bash version. Aliases should still work.")</ID>
    <ID>MaxLineLength:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$println("Installation complete, ${parent.alias} is available in bash, but autocompletion was not installed because of an old version of bash.")</ID>
    <ID>MaxLineLength:InteractiveShellIntegrationTest.kt$InteractiveShellIntegrationTest$private</ID>
    <ID>MaxLineLength:InterestSwapRestAPI.kt$InterestRateSwapAPI</ID>
    <ID>MaxLineLength:InternalAccessTestHelpers.kt$fun &lt;T&gt; ifThrowsAppend(strToAppendFn: () -&gt; String, block: () -&gt; T): T</ID>
    <ID>MaxLineLength:InternalAccessTestHelpers.kt$fun Class&lt;out Any?&gt;.accessPropertyDescriptors(validateProperties: Boolean = true): Map&lt;String, PropertyDescriptor&gt;</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$ fun createNode(parameters: InternalMockNodeParameters = InternalMockNodeParameters(), nodeFactory: (MockNodeArgs) -&gt; MockNode): TestStartedNode</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$?:</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$fun createUnstartedNode(parameters: InternalMockNodeParameters = InternalMockNodeParameters(), nodeFactory: (MockNodeArgs) -&gt; MockNode): MockNode</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$private val serializationEnv = checkNotNull(setDriverSerialization()) { "Using more than one mock network simultaneously is not supported." }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = defaultParameters.servicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork$val node = nodeFactory(MockNodeArgs(config, this, id, parameters.entropyRoot, parameters.version, flowManager = parameters.flowManager))</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlowFactory(initiatingFlowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: Class&lt;T&gt;, factory: InitiatedFlowFactory&lt;T&gt;, track: Boolean): Observable&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$open</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode$require(cryptoService is BCCryptoService) { "MockNode supports BCCryptoService only, but it is ${cryptoService.javaClass.name}" }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode${ require(cryptoService is BCCryptoService) { "MockNode supports BCCryptoService only, but it is ${cryptoService.javaClass.name}" } counter = counter.add(BigInteger.ONE) // The StartedMockNode specifically uses EdDSA keys as they are fixed and stored in json files for some tests (e.g IRSSimulation). val keyPair = Crypto.deriveKeyPairFromEntropy(Crypto.EDDSA_ED25519_SHA512, counter) (cryptoService as BCCryptoService).importKey(alias, keyPair) return keyPair.public }</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$InternalMockNetwork.MockNode.TestStartedNodeImpl$override</ID>
    <ID>MaxLineLength:InternalMockNetwork.kt$TestStartedNode$fun &lt;T : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatingFlowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: Class&lt;T&gt;, track: Boolean = false): Observable&lt;T&gt;</ID>
    <ID>MaxLineLength:InternalMockNetworkConfigOverrides.kt$return NotaryConfig(validating = this.validating, extraConfig = this.extraConfig, serviceLegalName = this.serviceLegalName, className = this.className)</ID>
    <ID>MaxLineLength:InternalMockNetworkConfigOverrides.kt$this.flowTimeout?.also { fto -&gt; doReturn(FlowTimeoutConfiguration(fto.timeout, fto.maxRestartCount, fto.backoffBase)).whenever(config).flowTimeout }</ID>
    <ID>MaxLineLength:InternalMockNetworkIntegrationTests.kt$InternalMockNetworkIntegrationTests$assertEquals(0, startJavaProcess&lt;InternalMockNetworkIntegrationTests&gt;(emptyList(), extraJvmArguments = listOf("-javaagent:$quasar")).waitFor())</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient : SingletonSerializeAsTokenAutoCloseable</ID>
    <ID>MaxLineLength:InternalRPCMessagingClient.kt$InternalRPCMessagingClient$rpcServer = RPCServer(rpcOps, NODE_RPC_USER, NODE_RPC_USER, locator!!, securityManager, nodeName, rpcServerConfiguration, cacheFactory)</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$ fun cordappWithPackages(vararg packageNames: String): CustomCordapp</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * *Custom* CorDapp containing the contents of the `net.corda.testing.contracts` package, i.e. the dummy contracts. This is not a real CorDapp * in the way that [FINANCE_CONTRACTS_CORDAPP] and [FINANCE_WORKFLOWS_CORDAPP] are. */ @JvmField val DUMMY_CONTRACTS_CORDAPP: CustomCordapp = cordappWithPackages("net.corda.testing.contracts")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * Reference to the finance-contracts CorDapp in this repo. The metadata is taken directly from finance/contracts/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.contracts")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the flows as well. */ @JvmField val FINANCE_CONTRACTS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.contracts")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$/** * Reference to the finance-workflows CorDapp in this repo. The metadata is taken directly from finance/workflows/build.gradle, including the * fact that the jar is signed. If you need an unsigned jar then use `cordappWithPackages("net.corda.finance.flows")`. * * You will probably need to use [FINANCE_CORDAPPS] instead to get access to the contract classes as well. */ @JvmField val FINANCE_WORKFLOWS_CORDAPP: TestCordappImpl = findCordapp("net.corda.finance.workflows")</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun addressMustBeBoundFuture(executorService: ScheduledExecutorService, hostAndPort: NetworkHostAndPort, listenProcess: Process? = null): CordaFuture&lt;Unit&gt;</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$fun fakeAttachment(filePath1: String, content1: String, filePath2: String, content2: String, manifestAttributes: Map&lt;String, String&gt; = emptyMap()): ByteArray</ID>
    <ID>MaxLineLength:InternalTestUtils.kt$val persistence = createCordaPersistence(databaseConfig, wellKnownPartyFromX500Name, wellKnownPartyFromAnonymous, schemaService, hikariProperties, cacheFactory, null)</ID>
    <ID>MaxLineLength:InternalUtils.kt$ fun &lt;T, U&gt; List&lt;T&gt;.lazyMapped(transform: (T, Int) -&gt; U): List&lt;U&gt;</ID>
    <ID>MaxLineLength:InternalUtils.kt$// TODO: Currently the certificate revocation status is not handled here. Nowhere in the code the second parameter is used. Consider adding the support in the future. fun CertPath.validate(trustAnchor: TrustAnchor, checkRevocation: Boolean = false): PKIXCertPathValidatorResult</ID>
    <ID>MaxLineLength:InternalUtils.kt$?:</ID>
    <ID>MaxLineLength:InternalUtils.kt$val Class&lt;*&gt;.packageNameOrNull: String? // This intentionally does not go via `package` as that code path is slow and contended and just ends up doing this. get() { val name = this.name val i = name.lastIndexOf('.') return if (i != -1) { name.substring(0, i) } else { null } }</ID>
    <ID>MaxLineLength:InvocationContext.kt$Actor.Companion$@JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name): Actor</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext$@CordaSerializable data</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(origin: InvocationOrigin, trace: Trace = Trace.newInstance(), actor: Actor? = null, externalTrace: Trace? = null, impersonatedActor: Actor? = null)</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun peer(party: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null, impersonatedActor: Actor? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun rpc(actor: Actor, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null, impersonatedActor: Actor? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun scheduled(scheduledState: ScheduledStateRef, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun service(serviceClassName: String, owningLegalIdentity: CordaX500Name, trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:InvocationContext.kt$InvocationContext.Companion$ @DeleteForDJVM @JvmStatic fun shell(trace: Trace = Trace.newInstance(), externalTrace: Trace? = null): InvocationContext</ID>
    <ID>MaxLineLength:IrsDemoClientApi.kt$IRSDemoClientApi$val fileContents = IOUtils.toString(Thread.currentThread().contextClassLoader.getResourceAsStream("net/corda/irs/simulation/example.rates.txt"), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IrsDemoClientApi.kt$IRSDemoClientApi$val fileContents = IOUtils.toString(javaClass.classLoader.getResourceAsStream("net/corda/irs/web/simulation/example-irs-trade.json"), Charsets.UTF_8.name())</ID>
    <ID>MaxLineLength:IssueCash.kt$IssueCash$val roleArg = parser.accepts("role").withRequiredArg().ofType(Role::class.java).describedAs("[ISSUER|ISSUE_CASH_RPC|ISSUE_CASH_WEB]")</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$val linesWithDuplicateInsertionWarningsInA = nodeA.logFile().useLines { lines -&gt; lines.filter(String::containsDuplicateInsertWarning).toList() }</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$IssueCashLoggingTests$val linesWithDuplicateInsertionWarningsInB = nodeB.logFile().useLines { lines -&gt; lines.filter(String::containsDuplicateInsertWarning).toList() }</ID>
    <ID>MaxLineLength:IssueCashLoggingTests.kt$fun NodeHandle.logFile(): File</ID>
    <ID>MaxLineLength:IssuerModel.kt$IssuerModel$val currencyTypes = ChosenList(cashAppConfiguration.map { it?.issuableCurrencies?.observable() ?: FXCollections.emptyObservableList() }, "currencyTypes")</ID>
    <ID>MaxLineLength:IssuerModel.kt$IssuerModel$val supportedCurrencies = ChosenList(cashAppConfiguration.map { it?.supportedCurrencies?.observable() ?: FXCollections.singletonObservableList(defaultCurrency) }, "supportedCurrencies")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$mapper.wellKnownPartyFromX500Name(principal) ?: throw JsonParseException(parser, "Could not find a Party with name $principal")</ID>
    <ID>MaxLineLength:JacksonSupport.kt$JacksonSupport.PartyDeserializer$throw JsonParseException(parser, "No matching Party found, then tried to directly deserialise ${parser.text} as a PublicKey with no success", e)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$TransactionSignature(ByteArray(1), ALICE_PUBKEY, SignatureMetadata(1, Crypto.findSignatureScheme(ALICE_PUBKEY).schemeNumberID), partialMerkleTree)</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest$val wtxFields = wtxJson.assertHasOnlyFields("id", "notary", "inputs", "attachments", "outputs", "commands", "timeWindow", "references", "privacySalt", "networkParametersHash")</ID>
    <ID>MaxLineLength:JacksonSupportTest.kt$JacksonSupportTest${ val cert: X509Certificate = MINI_CORP.identity.certificate val json = mapper.valueToTree&lt;ObjectNode&gt;(cert) println(mapper.writeValueAsString(json)) assertThat(json["serialNumber"].bigIntegerValue()).isEqualTo(cert.serialNumber) assertThat(json["issuer"].valueAs&lt;X500Principal&gt;(mapper)).isEqualTo(cert.issuerX500Principal) assertThat(json["subject"].valueAs&lt;X500Principal&gt;(mapper)).isEqualTo(cert.subjectX500Principal) // cert.publicKey should be converted to a supported format (this is required because [Certificate] returns keys as SUN EC keys, not BC). assertThat(json["publicKey"].valueAs&lt;PublicKey&gt;(mapper)).isEqualTo(Crypto.toSupportedPublicKey(cert.publicKey)) assertThat(json["notAfter"].valueAs&lt;Date&gt;(mapper)).isEqualTo(cert.notAfter) assertThat(json["notBefore"].valueAs&lt;Date&gt;(mapper)).isEqualTo(cert.notBefore) assertThat(json["encoded"].binaryValue()).isEqualTo(cert.encoded) }</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$"platform version ${it.minimumPlatformVersion} (This node is running version ${versionInfo.platformVersion})."</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$?:</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$logger</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$override val appClassLoader: URLClassLoader = URLClassLoader(cordappJarPaths.stream().map { it.url }.toTypedArray(), javaClass.classLoader)</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$private val signerKeyFingerprintBlacklist: List&lt;SecureHash.SHA256&gt; = emptyList()</ID>
    <ID>MaxLineLength:JarScanningCordappLoader.kt$JarScanningCordappLoader$throw CordappInvalidVersionException("Target versionId attribute $attributeName not specified. Please specify a whole number starting from 1.")</ID>
    <ID>MaxLineLength:JarScanningCordappLoaderTest.kt$JarScanningCordappLoaderTest$assertThat(actualCordapp.serializationWhitelists.first().javaClass.name).isEqualTo("net.corda.serialization.internal.DefaultWhitelist")</ID>
    <ID>MaxLineLength:JarSignatureCollectorTest.kt$JarSignatureCollectorTest$// Signing with EC algorithm produces META-INF/*.EC file name not compatible with JAR File Spec however it's compatible with java.util.JarVerifier // and our JarSignatureCollector @Test fun `one signer with EC algorithm`()</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$executeProcess("keytool", "-genkeypair", "-keystore", storeName, "-storepass", storePassword, "-keyalg", keyalg, "-alias", alias, "-keypass", keyPassword, "-dname", name)</ID>
    <ID>MaxLineLength:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.generateKey(alias: String = "Test", storePassword: String = "secret!", name: String = CODE_SIGNER.toString(), keyalg: String = "RSA", keyPassword: String = storePassword, storeName: String = "_teststore") : PublicKey</ID>
    <ID>MaxLineLength:KMSUtils.kt$require(issuerRole == CertRole.LEGAL_IDENTITY) { "Confidential identities can only be issued from well known identities, provided issuer ${issuer.name} has role $issuerRole" }</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$// A code signing policy is currently under design. // The following interim key represents a self-signed certificate produced using the Java keytool and located in the gradle cordapp plugins resources key store: // https://github.com/corda/corda-gradle-plugins/blob/master/cordapp/src/main/resources/certificates/cordadevcodesign.jks const val DEV_CORDAPP_CODE_SIGNING_STR = "AA59D829F2CA8FDDF5ABEA40D815F937E3E54E572B65B93B5C216AE6594E7D6B"</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$setPrivateKey</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val DEV_PUB_KEY_HASHES: List&lt;SecureHash.SHA256&gt; get() = listOf(DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate).map { it.publicKey.hash.sha256() } + SecureHash.parse(DEV_CORDAPP_CODE_SIGNING_STR).sha256()</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val identityCert = X509Utilities.createCertificate(CertificateType.LEGAL_IDENTITY, nodeCaCertAndKeyPair.certificate, nodeCaCertAndKeyPair.keyPair, nodeCaCertAndKeyPair.certificate.subjectX500Principal, keyPair.public)</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:KeyStoreConfigHelpers.kt$val tlsCert = X509Utilities.createCertificate(CertificateType.TLS, devNodeCa.certificate, devNodeCa.keyPair, legalName.x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:KeyStoreUtilities.kt$return certificate as? X509Certificate ?: throw IllegalStateException("Certificate under alias \"$alias\" is not an X.509 certificate: $certificate")</ID>
    <ID>MaxLineLength:Kryo.kt$ContractUpgradeFilteredTransactionSerializer$val visibleComponents: Map&lt;Int, ContractUpgradeFilteredTransaction.FilteredComponent&gt; = uncheckedCast(kryo.readClassAndObject(input))</ID>
    <ID>MaxLineLength:Kryo.kt$ImmutableClassSerializer$throw KryoException("Hashcode mismatch for parameter types for ${klass.qualifiedName}: unsupported type evolution has happened.")</ID>
    <ID>MaxLineLength:Kryo.kt$ThrowableSerializer$private val delegate: Serializer&lt;Throwable&gt; = uncheckedCast(ReflectionSerializerFactory.makeSerializer(kryo, FieldSerializer::class.java, type))</ID>
    <ID>MaxLineLength:KryoCheckpointSerializer.kt$KryoCheckpointSerializer$context.encodingWhitelist.acceptEncoding(encoding) || throw KryoException(encodingNotPermittedFormat.format(encoding))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$assertThat(deserialisedList.checkpointSerialize(noReferencesContext)).isEqualTo(originalList.checkpointSerialize(noReferencesContext))</ID>
    <ID>MaxLineLength:KryoTests.kt$KryoTests$assertThat(listWithSameInstances.checkpointSerialize(noReferencesContext)).isEqualTo(listWithCopies.checkpointSerialize(noReferencesContext))</ID>
    <ID>MaxLineLength:LargeTransactionsTest.kt$LargeTransactionsTest$val (alice, _) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow()</ID>
    <ID>MaxLineLength:LazyStickyPool.kt$LazyStickyPool&lt;A : Any&gt;</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$/** Random data used to make the transaction hash unpredictable even if the contents can be predicted; needed to avoid some obscure attacks. */ val privacySalt: PrivacySalt</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$logger</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return inputs.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$return references.mapNotNull { if (clazz.isInstance(it.state.data)) uncheckedCast&lt;StateAndRef&lt;ContractState&gt;, StateAndRef&lt;T&gt;&gt;(it) else null }</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$throw UnsupportedOperationException("Cannot verify a LedgerTransaction created using deprecated constructors outside of flow context.")</ID>
    <ID>MaxLineLength:LedgerTransaction.kt$LedgerTransaction$val deserializedOutputs = deserialiseComponentGroup(componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:LedgerTransactionQueryTests.kt$LedgerTransactionQueryTests$return StateAndRef(TransactionState(dummyState, DummyContract.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), dummyStateRef)</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.MustHaveAtLeastTwoLettersRule$require(legalName.count { it.isLetter() } &gt;= 2) { "Illegal input legal name '$legalName'. Legal name must have at least two letters" }</ID>
    <ID>MaxLineLength:LegalNameValidator.kt$LegalNameValidator.Rule.UnicodeNormalizationRule$require(legalName == normalize(legalName)) { "Legal name must be normalized. Please use 'normalize' to normalize the legal name before validation." }</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateNameAttribute("The quick brown fox jumped over the lazy dog.1234567890", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("Legal Name\u2004With\u0009Unicode\u0020Whitespaces", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$LegalNameValidator.validateOrganization("The quick brown fox jumped over the lazy dog.1234567890", LegalNameValidator.Validation.FULL)</ID>
    <ID>MaxLineLength:LegalNameValidatorTest.kt$LegalNameValidatorTest$assertEquals("Legal Name With Unicode Whitespaces", LegalNameValidator.normalize("Legal Name\u2004With\u0009Unicode\u0020Whitespaces"))</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$ListsSerializationTest.Companion$val envelope = DeserializationInput(SerializerFactoryBuilder.build(context.whitelist, context.deserializationClassLoader)).getEnvelope(serBytes, context)</ID>
    <ID>MaxLineLength:ListsSerializationTest.kt$internal inline</ID>
    <ID>MaxLineLength:LoadTestConfiguration.kt$RemoteNode</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.CalculatedProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.ConstructorPairedProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.GetterSetterProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.PrivateConstructorPairedProperty$data</ID>
    <ID>MaxLineLength:LocalPropertyInformation.kt$LocalPropertyInformation.ReadOnlyProperty$data</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$is LocalTypeInformation.ACollection</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$is LocalTypeInformation.AMap</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private</ID>
    <ID>MaxLineLength:LocalSerializerFactory.kt$DefaultLocalSerializerFactory$private val serializersByActualAndDeclaredType: MutableMap&lt;ActualAndDeclaredType, AMQPSerializer&lt;Any&gt;&gt; = DefaultCacheProvider.createCache()</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.ACollection$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.AnArray$data</ID>
    <ID>MaxLineLength:LocalTypeInformation.kt$LocalTypeInformation.Singleton$data</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$!EnumSet::class.java.isAssignableFrom(type)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$Map::class.java.isAssignableFrom(type) -&gt; LocalTypeInformation.AMap(type, typeIdentifier, LocalTypeInformation.Unknown, LocalTypeInformation.Unknown)</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$private</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either annotate a constructor for this type with @ConstructorForDeserialization, or provide a custom serializer for it"</ID>
    <ID>MaxLineLength:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder$remedy = "Either ensure that the properties ${nonComposableProperties.keys} are serializable, or provide a custom serializer for this type"</ID>
    <ID>MaxLineLength:LocalTypeModel.kt$ConfigurableLocalTypeModel.BuilderLookup$override</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ Concrete(a: Integer[], b: double, c: List&lt;Integer[]&gt;, d: int): Abstract&lt;Integer&gt;, Super&lt;Integer[]&gt;, SuperSuper&lt;Integer[], Double&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ StringCollectionHolder(list: List&lt;String&gt;, map: Map&lt;String, String&gt;, array: List&lt;String&gt;[]): StringKeyedCollectionHolder&lt;String&gt;, CollectionHolder&lt;String, String&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ StringKeyedCollectionHolder&lt;Integer&gt;(list: List&lt;Integer&gt;, map: Map&lt;String, Integer&gt;, array: List&lt;Integer&gt;[]): CollectionHolder&lt;String, Integer&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ c [</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$ collectionHolder (optional): StringKeyedCollectionHolder&lt;Integer&gt;(list: List&lt;Integer&gt;, map: Map&lt;String, Integer&gt;, array: List&lt;Integer&gt;[]): CollectionHolder&lt;String, Integer&gt;</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$StringCollectionHolder : StringKeyedCollectionHolder</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$StringKeyedCollectionHolder&lt;T&gt; : CollectionHolder</ID>
    <ID>MaxLineLength:LocalTypeModelTests.kt$LocalTypeModelTests$private val modelWithoutOpacity = ConfigurableLocalTypeModel(WhitelistBasedTypeModelConfiguration(AllWhitelist, emptyCustomSerializerRegistry))</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, clientKeyPair.private, listOf(clientCACert, DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate), signingCertStore.entryPassword)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(clientTLSCert, clientCACert, DEV_INTERMEDIATE_CA.certificate, DEV_ROOT_CA.certificate), p2pSslConfig.keyStore.entryPassword)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val clientCACert = X509Utilities.createCertificate(CertificateType.INTERMEDIATE_CA, DEV_INTERMEDIATE_CA.certificate, DEV_INTERMEDIATE_CA.keyPair, legalName.x500Principal, clientKeyPair.public, nameConstraints = nameConstraints)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val clientTLSCert = X509Utilities.createCertificate(CertificateType.TLS, clientCACert, clientKeyPair, CordaX500Name("MiniCorp", "London", "GB").x500Principal, tlsKeyPair.public)</ID>
    <ID>MaxLineLength:MQSecurityAsNodeTest.kt$MQSecurityAsNodeTest$val nameConstraints = NameConstraints(arrayOf(GeneralSubtree(GeneralName(GeneralName.directoryName, legalName.toX500Name()))), arrayOf())</ID>
    <ID>MaxLineLength:MQSecurityTest.kt$MQSecurityTest$fun clientTo(target: NetworkHostAndPort, sslConfiguration: MutualSslConfiguration? = configureTestSSL(CordaX500Name("MegaCorp", "London", "GB"))): SimpleMQClient</ID>
    <ID>MaxLineLength:Main.kt$Main$// TODO : This could block the UI thread when number of views increase, maybe we can make this async and display a loading screen. // Stock Views. registerView&lt;Dashboard&gt;() registerView&lt;TransactionViewer&gt;() // CordApps Views. registerView&lt;CashViewer&gt;() // Tools. registerView&lt;Network&gt;() registerView&lt;Settings&gt;() // Default view to Dashboard. selectedView.set(find&lt;Dashboard&gt;())</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner : CordaCliWrapper</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--copy-cordapps"], description = ["Whether or not to copy the CorDapp JARs into the nodes' 'cordapps' directory. \${COMPLETION-CANDIDATES}"])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--max-message-size"], description = ["The maximum message size to use in the network-parameters, in bytes. Current default is $DEFAULT_MAX_MESSAGE_SIZE."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--max-transaction-size"], description = ["The maximum transaction size to use in the network-parameters, in bytes. Current default is $DEFAULT_MAX_TRANSACTION_SIZE."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--minimum-platform-version"], description = ["The minimum platform version to use in the network-parameters. Current default is $PLATFORM_VERSION."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--network-parameter-overrides", "-n"], description = ["Overrides the default network parameters with those in the given file."])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$@Option(names = ["--no-copy"], hidden = true, description = ["""DEPRECATED. Don't copy the CorDapp JARs into the nodes' "cordapps" directories."""])</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$if (networkParametersFile?.exists() != true) throw FileNotFoundException("Unable to find specified network parameters config file at $networkParametersFile")</ID>
    <ID>MaxLineLength:Main.kt$NetworkBootstrapperRunner$require(minimumPlatformVersion == null || minimumPlatformVersion ?: 0 &gt; 0) { "The --minimum-platform-version parameter must be at least 1" }</ID>
    <ID>MaxLineLength:Main.kt$Node$if (transactions.size == 1) listOf(genesisTx) else transactions.values.reversed().take(10).filter { !isAccepted(it) &amp;&amp; conflicts[it.data]!!.size == 1 }.shuffled(network.rng).take(3)</ID>
    <ID>MaxLineLength:Main.kt$Transaction$return "T(id=${id.toString().take(5)}, data=$data, parents=[${parents.map {it.toString().take(5) }}, chit=$chit, confidence=$confidence)"</ID>
    <ID>MaxLineLength:MapSerializer.kt$MapSerializer$private val typeNotation: TypeNotation = RestrictedType(AMQPTypeIdentifiers.nameForType(declaredType), null, emptyList(), "map", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$PoliteSchema : MappedSchema</ID>
    <ID>MaxLineLength:MappedSchemasCrossReferenceDetectionTests.kt$MappedSchemasCrossReferenceDetectionTests$TrickySchema : MappedSchema</ID>
    <ID>MaxLineLength:Measure.kt$measure(listOf(a, b, c, d), f.reflect()!!) { f(uncheckedCast(it[0]), uncheckedCast(it[1]), uncheckedCast(it[2]), uncheckedCast(it[3])) }</ID>
    <ID>MaxLineLength:Measure.kt$private</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$ComponentVisibilityException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$ @Throws(ComponentVisibilityException::class) fun checkAllComponentsVisible(componentGroupEnum: ComponentGroupEnum)</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$"Did not receive components for group ${componentGroupEnum.ordinal} and cannot verify they didn't exist in the original wire transaction"</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$val groupFullRoot = MerkleTree.getMerkleTree(group.components.mapIndexed { index, component -&gt; componentHash(group.nonces[index], component) }).hash</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$verificationCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction$visibilityCheck(group.groupIndex &lt; groupHashes.size) { "There is no matching component group hash for group ${group.groupIndex}" }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentGroups.add(FilteredComponentGroup(groupIndex, value, filteredComponentNonces[groupIndex]!!, createPartialMerkleTree(groupIndex)))</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentHashes[componentGroupIndex] = mutableListOf(wtx.availableComponentHashes[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$filteredComponentNonces[componentGroupIndex] = mutableListOf(wtx.availableComponentNonces[componentGroupIndex]!![internalIndex])</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$val filteredComponentHashes: MutableMap&lt;Int, MutableList&lt;SecureHash&gt;&gt; = hashMapOf() // Required for partial Merkle tree generation.</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion$wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransaction.Companion${ wtx.inputs.forEachIndexed { internalIndex, it -&gt; filter(it, INPUTS_GROUP.ordinal, internalIndex) } wtx.outputs.forEachIndexed { internalIndex, it -&gt; filter(it, OUTPUTS_GROUP.ordinal, internalIndex) } wtx.commands.forEachIndexed { internalIndex, it -&gt; filter(it, COMMANDS_GROUP.ordinal, internalIndex) } wtx.attachments.forEachIndexed { internalIndex, it -&gt; filter(it, ATTACHMENTS_GROUP.ordinal, internalIndex) } if (wtx.notary != null) filter(wtx.notary, NOTARY_GROUP.ordinal, 0) if (wtx.timeWindow != null) filter(wtx.timeWindow, TIMEWINDOW_GROUP.ordinal, 0) // Note that because [inputs] and [references] share the same type [StateRef], we use a wrapper for references [ReferenceStateRef], // when filtering. Thus, to filter-in all [references] based on type, one should use the wrapper type [ReferenceStateRef] and not [StateRef]. // Similar situation is for network parameters hash and attachments, one should use wrapper [NetworkParametersHash] and not [SecureHash]. wtx.references.forEachIndexed { internalIndex, it -&gt; filter(ReferenceStateRef(it), REFERENCES_GROUP.ordinal, internalIndex) } wtx.networkParametersHash?.let { filter(NetworkParametersHash(it), PARAMETERS_GROUP.ordinal, 0) } // It is highlighted that because there is no a signers property in TraversableTransaction, // one cannot specifically filter them in or out. // The above is very important to ensure someone won't filter out the signers component group if at least one // command is included in a FilteredTransaction. // It's sometimes possible that when we receive a WireTransaction for which there is a new or more unknown component groups, // we decide to filter and attach this field to a FilteredTransaction. // An example would be to redact certain contract state types, but otherwise leave a transaction alone, // including the unknown new components. wtx.componentGroups .filter { it.groupIndex &gt;= values().size } .forEach { componentGroup -&gt; componentGroup.components.forEachIndexed { internalIndex, component -&gt; filter(component, componentGroup.groupIndex, internalIndex) } } }</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$FilteredTransactionVerificationException : CordaException</ID>
    <ID>MaxLineLength:MerkleTransaction.kt$TraversableTransaction$override val outputs: List&lt;TransactionState&lt;ContractState&gt;&gt; = deserialiseComponentGroup(componentGroups, TransactionState::class, OUTPUTS_GROUP)</ID>
    <ID>MaxLineLength:MessageChainState.kt$MessageChainState$@BelongsToContract(MessageChainContract::class) data</ID>
    <ID>MaxLineLength:MessageSizeChecksInterceptor.kt$MessageSizeChecksInterceptor$logger</ID>
    <ID>MaxLineLength:MessageState.kt$MessageState$@BelongsToContract(MessageContract::class) data</ID>
    <ID>MaxLineLength:Messaging.kt$MessagingService$ fun createMessage(topic: String, data: ByteArray, deduplicationId: SenderDeduplicationId = SenderDeduplicationId(DeduplicationId.createRandom(newSecureRandom()), ourSenderUUID), additionalHeaders: Map&lt;String, String&gt; = emptyMap()): Message</ID>
    <ID>MaxLineLength:Messaging.kt$fun MessagingService.send(topicSession: String, payload: Any, to: MessageRecipients, deduplicationId: SenderDeduplicationId = SenderDeduplicationId(DeduplicationId.createRandom(newSecureRandom()), ourSenderUUID), additionalHeaders: Map&lt;String, String&gt; = emptyMap())</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$putLongProperty(org.apache.activemq.artemis.api.core.Message.HDR_SCHEDULED_DELIVERY_TIME, System.currentTimeMillis() + amqDelayMillis)</ID>
    <ID>MaxLineLength:MessagingExecutor.kt$MessagingExecutor$putStringProperty(org.apache.activemq.artemis.api.core.Message.HDR_DUPLICATE_DETECTION_ID, SimpleString(message.uniqueMessageId.toString))</ID>
    <ID>MaxLineLength:MetricInterceptor.kt$MetricInterceptor$@Suspendable override</ID>
    <ID>MaxLineLength:MigrationNamedCacheFactory.kt$MigrationNamedCacheFactory$private val nodeConfiguration: NodeConfiguration?</ID>
    <ID>MaxLineLength:MigrationServicesForResolution.kt$MigrationServicesForResolution$deserialiseComponentGroup(tx.componentGroups, TransactionState::class, ComponentGroupEnum.OUTPUTS_GROUP, forceDeserialize = true)</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$"${contractsClassName ?: states.map { it.contract }.distinct()}${minimumRequiredContractClassVersion?.let { ", minimum required contract class version $minimumRequiredContractClassVersion"}}. "</ID>
    <ID>MaxLineLength:MissingContractAttachments.kt$MissingContractAttachments$@JvmOverloads constructor(val states: List&lt;TransactionState&lt;ContractState&gt;&gt;, contractsClassName: String? = null, minimumRequiredContractClassVersion: Version? = null)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$@JvmOverloads fun importContractAttachment(contractClassNames: List&lt;ContractClassName&gt;, uploader: String, jar: InputStream, attachmentId: AttachmentId? = null, signers: List&lt;PublicKey&gt; = emptyList()): AttachmentId</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$ContractAttachment.create(baseAttachment, contractClassNames.first(), contractClassNames.toSet(), uploader, signers, version)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$ContractAttachmentMetadata</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$MockAttachment : AbstractAttachment</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$fun getAttachmentIdAndBytes(jar: InputStream): Pair&lt;AttachmentId, ByteArray&gt;</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$private</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val attachmentQueryCriteria = AttachmentQueryCriteria.AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf(contractClassName)), versionCondition = Builder.greaterThanOrEqual(minContractVersion), uploaderCondition = Builder.`in`(TRUSTED_UPLOADERS))</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val attachmentSort = AttachmentSort(listOf(AttachmentSort.AttachmentSortColumn(AttachmentSort.AttachmentSortAttribute.VERSION, Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val contractClassMetadata = ContractAttachmentMetadata(contractClassName, version, signers.isNotEmpty(), signers, uploader)</ID>
    <ID>MaxLineLength:MockAttachmentStorage.kt$MockAttachmentStorage$val version = try { Integer.parseInt(baseAttachment.openAsJAR().manifest?.mainAttributes?.getValue(Attributes.Name.IMPLEMENTATION_VERSION)) } catch (e: Exception) { DEFAULT_CORDAPP_VERSION }</ID>
    <ID>MaxLineLength:MockContractAttachment.kt$// A valid zip file with 1 entry. val simpleZip = byteArrayOf(80, 75, 3, 4, 20, 0, 8, 8, 8, 0, 15, 113, 79, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 47, 97, -2, -54, 0, 0, 75, 4, 0, 80, 75, 7, 8, 67, -66, -73, -24, 3, 0, 0, 0, 1, 0, 0, 0, 80, 75, 1, 2, 20, 0, 20, 0, 8, 8, 8, 0, 15, 113, 79, 78, 67, -66, -73, -24, 3, 0, 0, 0, 1, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 97, -2, -54, 0, 0, 80, 75, 5, 6, 0, 0, 0, 0, 1, 0, 1, 0, 52, 0, 0, 0, 55, 0, 0, 0, 0, 0)</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$return ContentSignerBuilder.build(signatureScheme, privateKey, Crypto.findProvider(signatureScheme.providerName), newSecureRandom())</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$val privateKey = cipher.unwrap(wrappedPrivateKey.keyMaterial, keyAlgorithmFromScheme(wrappedPrivateKey.signatureScheme), Cipher.PRIVATE_KEY) as PrivateKey</ID>
    <ID>MaxLineLength:MockCryptoService.kt$MockCryptoService$val wrappingKey = wrappingKeys[masterKeyAlias] ?: throw IllegalStateException("There is no master key under the alias: $masterKeyAlias")</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$ fun createPartyNode(legalName: CordaX500Name? = null): StartedMockNode</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetwork$val servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = defaultParameters.servicePeerAllocationStrategy</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withCordappsForAllNodes(cordappsForAllNodes: Collection&lt;TestCordapp&gt;): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withNetworkSendManuallyPumped(networkSendManuallyPumped: Boolean): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$fun withServicePeerAllocationStrategy(servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy): MockNetworkParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$return MockNetworkParameters(networkSendManuallyPumped, threadPerNode, servicePeerAllocationStrategy, notarySpecs, networkParameters, emptyList())</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNetworkParameters$val servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = InMemoryMessagingNetwork.ServicePeerAllocationStrategy.Random()</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun copy(forcedID: Int?, legalName: CordaX500Name?, entropyRoot: BigInteger, configOverrides: MockNodeConfigOverrides): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$MockNodeParameters$fun withAdditionalCordapps(additionalCordapps: Collection&lt;TestCordapp&gt;): MockNodeParameters</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatedFlowClass: Class&lt;F&gt;): Observable&lt;F&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;F : FlowLogic&lt;*&gt;&gt; registerInitiatedFlow(initiatingFlowClass: Class&lt;out FlowLogic&lt;*&gt;&gt;, initiatedFlowClass: Class&lt;F&gt;): Observable&lt;F&gt;</ID>
    <ID>MaxLineLength:MockNetwork.kt$StartedMockNode$ fun &lt;T&gt; startFlow(logic: FlowLogic&lt;T&gt;): CordaFuture&lt;T&gt;</ID>
    <ID>MaxLineLength:MockNetworkIntegrationTests.kt$MockNetworkIntegrationTests$assertEquals(0, startJavaProcess&lt;MockNetworkIntegrationTests&gt;(emptyList(), extraJvmArguments = listOf("-javaagent:$quasar")).waitFor())</ID>
    <ID>MaxLineLength:MockNetworkParametersService.kt$MockNetworkParametersStorage : NetworkParametersStorage</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$override</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService$private</ID>
    <ID>MaxLineLength:MockNodeMessagingService.kt$MockNodeMessagingService.InMemoryDeduplicationHandler$private inner</ID>
    <ID>MaxLineLength:MockPublicKeyToOwningIdentityCache.kt$MockPublicKeyToOwningIdentityCache : WritablePublicKeyToOwningIdentityCache</ID>
    <ID>MaxLineLength:MockServices.kt$MockAppServiceHubImpl&lt;out T : SerializeAsToken&gt; : AppServiceHubServiceHub</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that can't load CorDapp code, and which uses a default service identity. */ constructor(cordappPackages: Iterable&lt;String&gt;) : this(cordappPackages, CordaX500Name("TestIdentity", "", "GB"), makeTestIdentityService())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that can't load CorDapp code, which uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. */ @JvmOverloads constructor(cordappPackages: Iterable&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService()) : this(cordappPackages, TestIdentity(initialIdentityName), identityService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] that looks for app code in the given package names, uses the provided identity service * (you can get one from [makeTestIdentityService]) and represents the given identity. */ @JvmOverloads constructor(cordappPackages: Iterable&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService(), key: KeyPair, vararg moreKeys: KeyPair) : this(cordappPackages, TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses a default service * identity. */ constructor() : this(listOf(getCallerPackage(MockServices::class)!!), CordaX500Name("TestIdentity", "", "GB"), makeTestIdentityService())</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$/** * Create a mock [ServiceHub] which uses the package of the caller to find CorDapp code. It uses the provided identity service * (you can get one from [makeTestIdentityService]) and which represents the given identity. */ @JvmOverloads constructor(initialIdentityName: CordaX500Name, identityService: IdentityService = makeTestIdentityService(), key: KeyPair, vararg moreKeys: KeyPair) : this(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(cordappPackages: List&lt;String&gt;, firstIdentity: TestIdentity, networkParameters: NetworkParameters, vararg moreIdentities: TestIdentity) : this( cordappPackages, firstIdentity, makeTestIdentityService(*listOf(firstIdentity, *moreIdentities).map { it.identity }.toTypedArray()), networkParameters, firstIdentity.keyPair )</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(cordappPackages: List&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService, networkParameters: NetworkParameters) : this(cordappPackages, TestIdentity(initialIdentityName), identityService, networkParameters)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$constructor(cordappPackages: List&lt;String&gt;, initialIdentityName: CordaX500Name, identityService: IdentityService, networkParameters: NetworkParameters, key: KeyPair) : this(cordappPackages, TestIdentity(initialIdentityName, key), identityService, networkParameters)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$internal</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$private constructor(cordappLoader: CordappLoader, identityService: IdentityService, networkParameters: NetworkParameters, initialIdentity: TestIdentity, moreKeys: Array&lt;out KeyPair&gt;, keyManagementService: KeyManagementService) : this(cordappLoader, MockTransactionStorage(), identityService, networkParameters, initialIdentity, moreKeys, keyManagementService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$return NodeVaultService(clock, keyManagementService, servicesForResolution, database, schemaService, cordappLoader.appClassLoader).apply { start() }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, networkParameters, initialIdentity, moreKeys, keyManagementService)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices$this(cordappLoaderForPackages(cordappPackages), identityService, testNetworkParameters(modifiedTime = Instant.MIN), initialIdentity, moreKeys)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$ @JvmStatic @JvmOverloads fun makeTestDatabaseAndMockServices(cordappPackages: List&lt;String&gt;, identityService: IdentityService, initialIdentity: TestIdentity, networkParameters: NetworkParameters = testNetworkParameters(modifiedTime = Instant.MIN), vararg moreKeys: KeyPair): Pair&lt;CordaPersistence, MockServices&gt;</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys, keyManagementService, schemaService, persistence)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$makeMockMockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys.toSet(), keyManagementService, schemaService, database)</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$return object : MockServices(cordappLoader, identityService, networkParameters, initialIdentity, moreKeys.toTypedArray(), keyManagementService) { override var networkParametersService: NetworkParametersService = MockNetworkParametersStorage(networkParameters) override val vaultService: VaultService = makeVaultService(schemaService, persistence, cordappLoader) override fun recordTransactions(statesToRecord: StatesToRecord, txs: Iterable&lt;SignedTransaction&gt;) { ServiceHubInternal.recordTransactions( statesToRecord, txs as? Collection ?: txs.toList(), validatedTransactions as WritableTransactionStorage, mockStateMachineRecordedTransactionMappingStorage, vaultService as VaultServiceInternal, persistence ) } override fun jdbcSession(): Connection = persistence.createSession() override fun &lt;T : Any?&gt; withEntityManager(block: EntityManager.() -&gt; T): T { return block(contextTransaction.restrictedEntityManager) } override fun withEntityManager(block: Consumer&lt;EntityManager&gt;) { return block.accept(contextTransaction.restrictedEntityManager) } }</ID>
    <ID>MaxLineLength:MockServices.kt$MockServices.Companion$val database = configureDatabase(dataSourceProps, DatabaseConfig(), identityService::wellKnownPartyFromX500Name, identityService::wellKnownPartyFromAnonymous, schemaService, schemaService.internalSchemas())</ID>
    <ID>MaxLineLength:Network.kt$Network$node.getWorldMapLocation()?.coordinate?.project(mapPane.width, mapPane.height, 85.0511, -85.0511, -180.0, 180.0) ?: ScreenCoordinate(0.0, 0.0)</ID>
    <ID>MaxLineLength:Network.kt$Network$private val peerButtons = peerComponents.filtered { myIdentity.value !in it.nodeInfo.legalIdentitiesAndCerts.map { it.party } }.map { it.button }</ID>
    <ID>MaxLineLength:Network.kt$Network$val inputParties = it.inputs.sequence() .map { it as? PartiallyResolvedTransaction.InputResolution.Resolved } .filterNotNull() .map { it.stateAndRef.state.data }.getParties() val outputParties = it.transaction.coreTransaction.let { if (it is WireTransaction) it.outputStates.observable().getParties() // For ContractUpgradeWireTransaction and NotaryChangeWireTransaction the output parties are the same as input parties else inputParties } val signingParties = it.transaction.sigs.map { it.by.toKnownParty() } // Input parties fire a bullets to all output parties, and to the signing parties. !! This is a rough guess of how the message moves in the network. // TODO : Expose artemis queue to get real message information. inputParties.cross(outputParties) + inputParties.cross(signingParties)</ID>
    <ID>MaxLineLength:Network.kt$Network$val mapLabel = label(PartyNameFormatter.short.format(identities.first().name)) // We choose the first one for the name of the node on the map.</ID>
    <ID>MaxLineLength:Network.kt$Network${ // It has to be a copy if we want to have notary both in notaries list and in identity (if we are looking at that particular notary node). myIdentityPane.apply { center = node.renderButton(mapLabel) } myLabel = mapLabel }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.FirstRunOnly$println("Not copying CorDapp JARs as --copy-cordapps is set to FirstRunOnly, and it looks like this network has already been bootstrapped.")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$CopyCordapps.Yes$override fun copyTo(cordappJars: List&lt;Path&gt;, nodeDirs: List&lt;Path&gt;, networkAlreadyExists: Boolean, fromCordform: Boolean)</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$paths.filter { it.toString().endsWith(".jar") &amp;&amp; !it.isSameAs(bootstrapperJar) &amp;&amp; !jarsThatArentCordapps.contains(it.fileName.toString().toLowerCase()) }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$require(networkParameterOverrides.minimumPlatformVersion == null || networkParameterOverrides.minimumPlatformVersion &lt;= PLATFORM_VERSION) { "Minimum platform version cannot be greater than $PLATFORM_VERSION" }</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val configuration = ConfigFactory.parseString(extraConfigurations).resolve().getObject("networkParameterOverrides").toConfig().parseAsNetworkParametersConfiguration()</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val networkParametersOverrides = configuration.doOnErrors(::reportErrors).optional ?: throw IllegalStateException("Invalid configuration passed.")</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val newWhitelist = generateWhitelist(existingNetParams, readExcludeWhitelist(directory), unsignedJars.map(contractsJarConverter), readIncludeWhitelist(directory), signedJars.map(contractsJarConverter))</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapper$val signedJars = cordappJars.filter { isSigned(it) } // signed JARs are excluded by default, optionally include them in order to transition states from CZ whitelist to signature constraint</ID>
    <ID>MaxLineLength:NetworkBootstrapper.kt$NetworkBootstrapperWithOverridableParameters$fun bootstrap(directory: Path, copyCordapps: CopyCordapps, networkParameterOverrides: NetworkParametersOverrides = NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper)</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(eventHorizon = 7.days))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(maxMessageSize = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(maxTransactionSize = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(Paths.get(".").toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides(minimumPlatformVersion = 1))</ID>
    <ID>MaxLineLength:NetworkBootstrapperRunnerTests.kt$NetworkBootstrapperRunnerTests$verify(mockBootstrapper).bootstrap(tempDir.toPath().toAbsolutePath().normalize(), CopyCordapps.FirstRunOnly, NetworkParametersOverrides())</ID>
    <ID>MaxLineLength:NetworkHostAndPort.kt$NetworkHostAndPort.Companion$ @JvmStatic fun parse(str: String): NetworkHostAndPort</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer$val jerseyServlet = ServletHolder(ServletContainer(resourceConfig)).apply { initOrder = 0 } // Initialise at server start</ID>
    <ID>MaxLineLength:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$nodeInfoMap.filter { it.value.verified().legalIdentities.first().name == signedNodeInfo.verified().legalIdentities.first().name }</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertThat(nodeInfosDir.list().single().readObject&lt;SignedNodeInfo&gt;().verified().legalIdentities.first(), `is`( this.nodeInfo.legalIdentities.first()))</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest$assertThatThrownBy { alice.rpc.acceptNewNetworkParameters(nextHash) }.hasMessageContaining("Refused to accept parameters with hash")</ID>
    <ID>MaxLineLength:NetworkMapTest.kt$NetworkMapTest.Companion$nms.networkParameters = testNetworkParameters(it, modifiedTime = Instant.ofEpochMilli(random63BitValue()), epoch = 2)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$"""Node is using network parameters with hash $currentParametersHash but the network map is advertising ${networkMap.networkParameterHash}. To resolve this mismatch, and move to the current parameters, delete the $NETWORK_PARAMS_FILE_NAME file from the node's directory and restart. The node will shutdown now."""</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$// Add new node info to the network map cache, these could be new node info or modification of node info for existing nodes. networkMapCache.addNodes(retrievedNodeInfos)</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$To resolve this mismatch, and move to the current parameters, delete the </ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$logger.info("Fetched: ${hashesToFetch.size} using $threadsToUseForNetworkMapDownload Threads in ${System.currentTimeMillis() - networkMapDownloadStartTime}ms")</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val (update, signedNewNetParams) = requireNotNull(newNetworkParameters) { "Couldn't find parameters update for the hash: $parametersHash" }</ID>
    <ID>MaxLineLength:NetworkMapUpdater.kt$NetworkMapUpdater$val executorToUseForDownloadingNodeInfos = Executors.newFixedThreadPool(threadsToUseForNetworkMapDownload, NamedThreadFactory("NetworkMapUpdaterNodeInfoDownloadThread"))</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$Assert.assertThat(networkMapCache.allNodeHashes, IsIterableContainingInAnyOrder.containsInAnyOrder(signedNodeInfo1.raw.hash, signedNodeInfo2.raw.hash))</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertFalse(netParams.canAutoAccept(netParamsAutoAcceptable, setOf("whitelistedContractImplementations")), "not auto-acceptable if only AutoAcceptable params have changed but one has been added to the exclusion set")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertFalse(netParams.canAutoAccept(netParamsNotAutoAcceptable, emptySet()), "not auto-acceptable if non-AutoAcceptable param has changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertThat(networkMapCache.allNodeHashes).containsExactlyInAnyOrder(fileNodeInfoAndSigned1.signed.raw.hash, fileNodeInfoAndSigned2.signed.raw.hash)</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParamsAutoAcceptable, emptySet()), "auto-acceptable if only AutoAcceptable params have changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$assertTrue(netParams.canAutoAccept(netParamsAutoAcceptable, setOf("modifiedTime")), "auto-acceptable if only AutoAcceptable params have changed and excluded param has not changed")</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$private</ID>
    <ID>MaxLineLength:NetworkMapUpdaterTest.kt$NetworkMapUpdaterTest$val fileName1 = "${NodeInfoFilesCopier.NODE_INFO_FILE_NAME_PREFIX}${fileNodeInfoAndSigned1.nodeInfo.legalIdentities[0].name.serialize().hash}"</ID>
    <ID>MaxLineLength:NetworkParameterOverridesSpec.kt$fun Config.parseAsNetworkParametersConfiguration(options: Configuration.Validation.Options = Configuration.Validation.Options(strict = false)): Valid&lt;NetworkParametersOverrides&gt;</ID>
    <ID>MaxLineLength:NetworkParameters.kt$NetworkParameters</ID>
    <ID>MaxLineLength:NetworkParametersCopier.kt$NetworkParametersCopier$private val serialisedSignedNetParams: SerializedBytes&lt;SignedDataWithCert&lt;NetworkParameters&gt;&gt; = signingCertAndKeyPair.sign(networkParameters).serialize()</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader${ // TODO On one hand we have node starting without parameters and just accepting them by default, // on the other we have parameters update process - it needs to be unified. Say you start the node, you don't have matching parameters, // you get them from network map, but you have to run the approval step. if (signedParametersFromFile == null) { // Node joins for the first time. downloadParameters(advertisedParametersHash) } else if (signedParametersFromFile.raw.hash == advertisedParametersHash) { // Restarted with the same parameters. signedParametersFromFile } else { // Update case. readParametersUpdate(advertisedParametersHash, signedParametersFromFile.raw.hash) } }</ID>
    <ID>MaxLineLength:NetworkParametersReader.kt$NetworkParametersReader.Error$NetworkMapNotConfigured : Error</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$cordappsForAllNodes = listOf(DUMMY_CONTRACTS_CORDAPP, cordappForClasses(ResolveTransactionsFlowTest.TestFlow::class.java, ResolveTransactionsFlowTest.TestResponseFlow::class.java))</ID>
    <ID>MaxLineLength:NetworkParametersResolutionTest.kt$NetworkParametersResolutionTest$private</ID>
    <ID>MaxLineLength:NetworkParametersServiceInternal.kt$NetworkParametersStorage$ fun getEpochFromHash(hash: SecureHash): Int?</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$val alice = mockNet.createUnstartedNode(InternalMockNodeParameters(legalName = ALICE_NAME, forcedID = 100, version = MOCK_VERSION_INFO.copy(platformVersion = 1)))</ID>
    <ID>MaxLineLength:NetworkParametersTest.kt$NetworkParametersTest$val alice = mockNet.createUnstartedNode(InternalMockNodeParameters(legalName = ALICE_NAME, forcedID = 100, version = MOCK_VERSION_INFO.copy(platformVersion = 2)))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ | Please make sure the config is correct or that the correct certificate for the CRL issuer is added to the node's trust store.</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$certStore.query { setPrivateKey(SELF_SIGNED_PRIVATE_KEY, AliasPrivateKey(SELF_SIGNED_PRIVATE_KEY), listOf(NOT_YET_REGISTERED_MARKER_KEYS_AND_CERTS.ECDSAR1_CERT), certificateStore.entryPassword) }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logError</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$logProgress("Certificate signing request with the following information will be submitted to the Corda certificate signing server.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$onSuccess(nodeCaPublicKey, cryptoService.getSigner(nodeCaKeyAlias), nodeCaCertificates, tlsCrlIssuerCert?.subjectX500Principal?.toX500Name())</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$protected open fun onSuccess(publicKey: PublicKey, contentSigner: ContentSigner, certificates: List&lt;X509Certificate&gt;, tlsCrlCertificateIssuer: X500Name?)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$throw CertificateRequestException("Received certificate contains invalid cert role, expected '$certRole', got '$nodeCaCertRole'.")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$val request = X509Utilities.createCertificateSigningRequest(myLegalName.x500Principal, emailAddress, publicKey, contentSigner, certRole)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NetworkRegistrationHelper${ val nodeCACertificate = certificates.first() val nodeCaSubject = try { CordaX500Name.build(nodeCACertificate.subjectX500Principal) } catch (e: IllegalArgumentException) { throw CertificateRequestException("Received node CA cert has invalid subject name: ${e.message}") } if (nodeCaSubject != myLegalName) { throw CertificateRequestException("Subject of received node CA cert doesn't match with node legal name: $nodeCaSubject") } val nodeCaCertRole = try { CertRole.extract(nodeCACertificate) } catch (e: IllegalArgumentException) { throw CertificateRequestException("Unable to extract cert role from received node CA cert: ${e.message}") } if (certRole != nodeCaCertRole) { throw CertificateRequestException("Received certificate contains invalid cert role, expected '$certRole', got '$nodeCaCertRole'.") } // Validate returned certificate is for the correct public key. if (Crypto.toSupportedPublicKey(certificates.first().publicKey) != Crypto.toSupportedPublicKey(registeringPublicKey)) { throw CertificateRequestException("Received certificate contains incorrect public key, expected '$registeringPublicKey', got '${certificates.first().publicKey}'.") } // Validate certificate chain returned from the doorman with the root cert obtained via out-of-band process, to prevent MITM attack on doorman server. X509Utilities.validateCertificateChain(rootCert, certificates) logProgress("Certificate signing request approved, storing private key with the certificate chain.") }</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationConfiguration$cryptoService = CryptoServiceFactory.makeCryptoService(SupportedCryptoServices.BC_SIMPLE, config.myLegalName, config.signingCertificateStore)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$computeNextIdleDoormanConnectionPollInterval: (Duration?) -&gt; Duration? = FixedPeriodLimitedRetrialStrategy(10, Duration.ofMinutes(1))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$logger.warn("The node's trust store already exists. The following certificates will be overridden: ${this.aliases().asSequence()}")</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$override</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$private</ID>
    <ID>MaxLineLength:NetworkRegistrationHelper.kt$NodeRegistrationHelper$val validityWindow = X509Utilities.getCertificateValidityWindow(DEFAULT_VALIDITY_WINDOW.first, DEFAULT_VALIDITY_WINDOW.second, issuerCertificate)</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$CertRole.NODE_CA -&gt; NodeRegistrationHelper(NodeRegistrationConfiguration(config), certService, NodeRegistrationOption(config.certificatesDirectory / networkRootTrustStoreFileName, networkRootTrustStorePassword))</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$private</ID>
    <ID>MaxLineLength:NetworkRegistrationHelperTest.kt$NetworkRegistrationHelperTest$rootAndIntermediateCA: Pair&lt;CertificateAndKeyPair, CertificateAndKeyPair&gt; = createDevIntermediateCaCertPath()</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Issue -&gt; IssueAndPaymentRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), issueRef, partyBChoiceBox.value.party, selectNotary(), anonymous)</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$CashTransaction.Pay -&gt; PaymentRequest(Amount.fromDecimal(amount.value, currencyChoiceBox.value), partyBChoiceBox.value.party, anonymous = anonymous, notary = selectNotary())</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$issueRefLabel.visibleProperty().bind(transactionTypeCB.valueProperty().map { it == CashTransaction.Issue || it == CashTransaction.Exit })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$issuer.isNotNull.and(currencyChoiceBox.valueProperty().isNotNull).and(transactionTypeCB.valueProperty().booleanBinding(transactionTypeCB.valueProperty()) { it != CashTransaction.Issue })</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$val filteredCash = cash.filtered { it.token.issuer.party == issuer.value &amp;&amp; it.token.product == currencyChoiceBox.value } .map { it.withoutIssuer() }.sumOrNull()</ID>
    <ID>MaxLineLength:NewTransaction.kt$NewTransaction$val issuer = Bindings.createObjectBinding({ if (issuerChoiceBox.isVisible) issuerChoiceBox.value else myIdentity.value }, arrayOf(myIdentity, issuerChoiceBox.visibleProperty(), issuerChoiceBox.valueProperty()))</ID>
    <ID>MaxLineLength:Node.kt$Node$"To disable autodetect set detectPublicIp = false in the node.conf, or consider using messagingServerAddress and messagingServerExternal"</ID>
    <ID>MaxLineLength:Node.kt$Node$ArtemisRpcBroker.withSsl(configuration.p2pSslOptions, this.address, adminAddress, sslConfig!!, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell())</ID>
    <ID>MaxLineLength:Node.kt$Node$ArtemisRpcBroker.withoutSsl(configuration.p2pSslOptions, this.address, adminAddress, securityManager, MAX_RPC_MESSAGE_SIZE, jmxMonitoringHttpPort != null, rpcBrokerDirectory, shouldStartLocalShell())</ID>
    <ID>MaxLineLength:Node.kt$Node$System.setProperty("h2.allowedClasses", "org.h2.mvstore.db.MVTableEngine,org.locationtech.jts.geom.Geometry,org.h2.server.TcpServer")</ID>
    <ID>MaxLineLength:Node.kt$Node$internalRpcMessagingClient = InternalRPCMessagingClient(configuration.p2pSslOptions, it.admin, MAX_RPC_MESSAGE_SIZE, CordaX500Name.build(configuration.p2pSslOptions.keyStore.get()[X509Utilities.CORDA_CLIENT_TLS].subjectX500Principal), rpcServerConfiguration)</ID>
    <ID>MaxLineLength:Node.kt$Node$log.info("Detected public IP: ${foundPublicIP.hostAddress}. This will be used instead of the provided \"$host\" as the advertised address.")</ID>
    <ID>MaxLineLength:Node.kt$Node$log.info("Retrieved public IP from Network Map Service: $this. This will be used instead of the provided \"$host\" as the advertised address.")</ID>
    <ID>MaxLineLength:Node.kt$Node$override</ID>
    <ID>MaxLineLength:Node.kt$Node$registerScheme(AMQPClientSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()))</ID>
    <ID>MaxLineLength:Node.kt$Node$registerScheme(AMQPServerSerializationScheme(cordappLoader.cordapps, Caffeine.newBuilder().maximumSize(128).build&lt;SerializationFactoryCacheKey, SerializerFactory&gt;().asMap()))</ID>
    <ID>MaxLineLength:Node.kt$Node$return BridgeControlListener(configuration.p2pSslOptions, networkParameters.maxMessageSize, configuration.crlCheckSoftFail, artemisMessagingClientFactory)</ID>
    <ID>MaxLineLength:Node.kt$Node$rpcClientContext = if (configuration.shouldInitCrashShell()) AMQP_RPC_CLIENT_CONTEXT.withClassLoader(classloader) else null</ID>
    <ID>MaxLineLength:Node.kt$Node$throw CouldNotCreateDataSourceException("Database password is required for H2 server listening on ${InetAddress.getByName(effectiveH2Settings.address.host)}.")</ID>
    <ID>MaxLineLength:Node.kt$Node.Companion$println("You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.")</ID>
    <ID>MaxLineLength:Node.kt$Node.Companion${ // JDK 11: review naming convention and checking of 'minUpdateVersion' and 'distributionType` (OpenJDK, Oracle, Zulu, AdoptOpenJDK, Cornetto) return try { if (SystemUtils.IS_JAVA_11) return true else { val update = getJavaUpdateVersion(SystemUtils.JAVA_VERSION) // To filter out cases like 1.8.0_202-ea (SystemUtils.IS_JAVA_1_8 &amp;&amp; update &gt;= 171) } } catch (e: NumberFormatException) { // custom JDKs may not have the update version (e.g. 1.8.0-adoptopenjdk) false } }</ID>
    <ID>MaxLineLength:Node.kt$NodeWithInfo$val services: StartedNodeServices = object : StartedNodeServices, ServiceHubInternal by node.services, FlowStarter by node.flowStarter {}</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$/** * This caches contract attachment versions by contract class name. For each version, we support one signed and one unsigned attachment, since that is allowed. * * It is correctly invalidated as new attachments are uploaded. */ private val contractsCache = InfrequentlyMutatedCache&lt;ContractClassName, NavigableMap&lt;Version, AttachmentIds&gt;&gt;("NodeAttachmentService_contractAttachmentVersions", cacheFactory)</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$HashMismatchException : CordaRuntimeException</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("(Dev Mode) Multiple signed attachments ${signed.map { it.toString() }} for contract $contractClassName version '${it.key}'.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("Selecting attachment ${unsigned.first()} from duplicated, unsigned attachments ${unsigned.map { it.toString() }} for contract $contractClassName version '${it.key}'.")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$log.warn("Several versions based on whitelistedContractImplementations position are available: ${versions.toSet()}. $msg")</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$private</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$val versions = contractClassNames.mapNotNull { servicesForResolution.networkParameters.whitelistedContractImplementations[it]?.indexOf(attachmentId) } .filter { it &gt;= 0 }.map { it + 1 } // +1 as versions starts from 1 not 0</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService$weigher = Weigher&lt;SecureHash, Optional&lt;Pair&lt;Attachment, ByteArray&gt;&gt;&gt; { key, value -&gt; key.size + if (value.isPresent) value.get().second.size else 0 }</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$( @Id @Column(name = "att_id", nullable = false) var attId: String, @Column(name = "content", nullable = false) @Lob var content: ByteArray, @Column(name = "insertion_date", nullable = false, updatable = false) var insertionDate: Instant = Instant.now(), @Column(name = "uploader", nullable = true) var uploader: String? = null, @Column(name = "filename", updatable = false, nullable = true) var filename: String? = null, @ElementCollection @Column(name = "contract_class_name", nullable = false) @CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_contracts", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__ctr_class__attachments")) var contractClassNames: List&lt;ContractClassName&gt;? = null, @ElementCollection(targetClass = PublicKey::class, fetch = FetchType.EAGER) @Column(name = "signer", nullable = false) @CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_signers", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__signers__attachments")) var signers: List&lt;PublicKey&gt;? = null, // Assumption: only Contract Attachments are versioned, version unknown or value for other attachments other than Contract Attachment defaults to 1 @Column(name = "version", nullable = false) var version: Int = DEFAULT_CORDAPP_VERSION )</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$@CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_contracts", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__ctr_class__attachments"))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.DBAttachment$@CollectionTable(name = "${NODE_DATABASE_PREFIX}attachments_signers", joinColumns = [(JoinColumn(name = "att_id", referencedColumnName = "att_id"))], foreignKey = ForeignKey(name = "FK__signers__attachments"))</ID>
    <ID>MaxLineLength:NodeAttachmentService.kt$NodeAttachmentService.HashCheckingStream$private val stream: HashingInputStream = HashingInputStream(Hashing.sha256(), counter)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `The strict JAR verification function fails signed JARs with removed or extra files that are valid according to the usual jarsigner`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing a single public key`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$@Test fun `attachments can be queried by providing a intersection of signers using an EQUAL statement - EQUAL containing multiple public keys`()</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$assertThatThrownBy { attachment.read { storage.privilegedImportAttachment(it, untrustedUploader, null) } }.isInstanceOf(DuplicateAttachmentException::class.java)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$fun filenameSort(direction: Sort.Direction)</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$signedContractJarSameVersion.read { attachmentIdSameVersionLatest = devModeStorage.privilegedImportAttachment(it, "app", "contract-signed-same-version.jar") }</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$storage.queryAttachments(AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract")))).size</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val (signedContractJarSameVersion, _) = makeTestSignedContractJar(file.path,"com.example.MyContract", versionSeed = Random().nextInt())</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherContractJar = makeTestContractJar(file.path, listOf( "com.example.MyContract", "com.example.AnotherContract"), generateManifest = false, jarFileName = "another-sample.jar")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val anotherContractJar = makeTestContractJar(file.path, listOf( "com.example.MyContract", "com.example.AnotherContract"), true, generateManifest = false, jarFileName = "another-sample.jar")</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val attachments = storage.queryAttachments(AttachmentsQueryCriteria(contractClassNamesCondition = Builder.equal(listOf("com.example.MyContract"))))</ID>
    <ID>MaxLineLength:NodeAttachmentServiceTest.kt$NodeAttachmentServiceTest$val corruptAttachment = NodeAttachmentService.DBAttachment(attId = id.toString(), content = bytes, version = DEFAULT_CORDAPP_VERSION)</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$InProcessNode : Node</ID>
    <ID>MaxLineLength:NodeBasedTest.kt$InProcessNode$assertFalse(isInvalidJavaVersion(), "You are using a version of Java that is not supported (${SystemUtils.JAVA_VERSION}). Please upgrade to the latest version of Java 8.")</ID>
    <ID>MaxLineLength:NodeBuilder.kt$NodeBuilder.&lt;no name provided&gt;$future.completeExceptionally(IllegalStateException("Could not build image for: $nodeDir, reason: ${result?.errorDetail}"))</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Performs the node start-up tasks necessary to generate the nodeInfo file, saves it to disk, then exits."]</ID>
    <ID>MaxLineLength:NodeCmdLineOptions.kt$NodeCmdLineOptions$description = ["DEPRECATED. Starts initial node registration with Corda network to obtain certificate from the permissioning server."]</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$SecurityConfiguration.AuthService.DataSource$AuthDataSourceType.DB -&gt; require(users == null &amp;&amp; connection != null) { "Database-backed authentication must not specify a user list, and must configure a database" }</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$SecurityConfiguration.AuthService.DataSource$AuthDataSourceType.INMEMORY -&gt; require(users != null &amp;&amp; connection == null) { "In-memory authentication must specify a user list, and must not configure a database" }</ID>
    <ID>MaxLineLength:NodeConfiguration.kt$fun Config.parseAsNodeConfiguration(options: Configuration.Validation.Options = Configuration.Validation.Options(strict = true)): Valid&lt;NodeConfiguration&gt;</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$// TODO: There are two implications here: // 1. "signingCertificateStore" and "p2pKeyStore" have the same passwords. In the future we should re-visit this "rule" and see of they can be made different; // 2. The passwords for store and for keys in this store are the same, this is due to limitations of Artemis. override val signingCertificateStore = FileBasedCertificateStoreSupplier(signingCertificateStorePath, keyStorePassword, keyStorePassword)</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$logger</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$override</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$require(rpcSettings.address == null) { "Can't provide top-level rpcAddress and rpcSettings.address (they control the same property)." }</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$return listOf("cannot specify 'compatibilityZoneURL' when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl$return listOf("cannot specify 'networkServices' when 'devMode' is true, unless 'devModeOptions.allowCompatibilityZone' is also true")</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeConfigurationImpl.Defaults$val flowMonitorSuspensionLoggingThresholdMillis: Duration = NodeConfiguration.DEFAULT_FLOW_MONITOR_SUSPENSION_LOGGING_THRESHOLD_MILLIS</ID>
    <ID>MaxLineLength:NodeConfigurationImpl.kt$NodeRpcSettings.&lt;no name provided&gt;$return "address: $address, adminAddress: $adminAddress, standAloneBroker: $standAloneBroker, useSsl: $useSsl, sslConfig: $sslConfig"</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-DevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-empty.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertFalse(getConfig("test-config-noDevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to false))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(config.errors.asSequence().map(Configuration.Validation.Error::message).filter { it.contains("rpcSettings.adminAddress") }.toList()).isNotEmpty</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertThat(rawConfig.parseAsNodeConfiguration().errors.single())</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-DevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-empty.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$assertTrue(getConfig("test-config-noDevMode.conf", ConfigFactory.parseMap(mapOf("devMode" to true))).getBooleanCaseInsensitive("devMode"))</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$private</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$return testConfiguration.copy(tlsCertCrlDistPoint = tlsCertCrlDistPoint, tlsCertCrlIssuer = tlsCertCrlIssuer?.let { X500Principal(it) }, crlCheckSoftFail = crlCheckSoftFail)</ID>
    <ID>MaxLineLength:NodeConfigurationImplTest.kt$NodeConfigurationImplTest$val configValidationResult = configTlsCertCrlOptions(null, "C=US, L=New York, OU=Corda, O=R3 HoldCo LLC, CN=Corda Root CA").validate()</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection : Closeable</ID>
    <ID>MaxLineLength:NodeConnection.kt$NodeConnection$return runShellCommandGetOutput("sudo netstat -tlpn | grep ${remoteNode.rpcPort} | awk '{print $7}' | grep -oE '[0-9]+'").getResultOrThrow().replace("\n", "")</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$(cordappConfigDir / "${CordappController.FINANCE_WORKFLOWS_CORDAPP_FILENAME}.conf").writeText(config.nodeConfig.toFinanceConfText())</ID>
    <ID>MaxLineLength:NodeController.kt$NodeController$val nextPort = 1 + arrayOf(config.p2pAddress.port, config.rpcSettings.address.port, config.webAddress.port, config.h2port).max() as Int</ID>
    <ID>MaxLineLength:NodeFlowManagerTest.kt$NodeFlowManagerTest$val nodeFlowManager = NodeFlowManager(FlowOverrideConfig(listOf(FlowOverride(Init::class.qualifiedName!!, Resp::class.qualifiedName!!))))</ID>
    <ID>MaxLineLength:NodeInfo.kt$NodeInfoSigner$@Option(names = ["--address"], paramLabel = "host:port", description = ["Public address of node"], converter = [NetworkHostAndPortConverter::class])</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1$mappedTypes = listOf(PersistentNodeInfo::class.java, DBPartyAndCertificate::class.java, DBHostAndPort::class.java, NodePropertiesPersistentStore.DBNodeProperty::class.java)</ID>
    <ID>MaxLineLength:NodeInfoSchema.kt$NodeInfoSchemaV1.PersistentNodeInfo$(this.legalIdentitiesAndCerts.filter { it.isMain } + this.legalIdentitiesAndCerts.filter { !it.isMain }).map { it.toLegalIdentityAndCert() }</ID>
    <ID>MaxLineLength:NodeInstanceRequest.kt$NodeInstanceRequest$return "NodeInstanceRequest(nodeInstanceName='$nodeInstanceName', actualX500='$actualX500', expectedFqName='$expectedFqName') ${super.toString()}"</ID>
    <ID>MaxLineLength:NodeInterestRates.kt$NodeInterestRates.Oracle$knownFixes = parseFile(IOUtils.toString(this::class.java.classLoader.getResourceAsStream("net/corda/irs/simulation/example.rates.txt"), Charsets.UTF_8.name()))</ID>
    <ID>MaxLineLength:NodeInterestRatesTest.kt$NodeInterestRatesTest$assertFailsWith&lt;IllegalArgumentException&gt; { oracle.sign(ftx) }</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$setPrivateKey(X509Utilities.CORDA_CLIENT_CA, nodeCA.keyPair.private, listOf(badNodeCACert, badRoot), signingCertStore.entryPassword)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val badNodeCACert = X509Utilities.createCertificate(CertificateType.NODE_CA, badRoot, badRootKeyPair, ALICE_NAME.x500Principal, nodeCA.keyPair.public)</ID>
    <ID>MaxLineLength:NodeKeystoreCheckTest.kt$NodeKeystoreCheckTest$val p2pSslConfig = CertificateStoreStubs.P2P.withCertificatesDirectory(certificatesDirectory, keyStorePassword = keystorePassword, trustStorePassword = keystorePassword)</ID>
    <ID>MaxLineLength:NodeMonitorModel.kt$NodeMonitorModel${ rpc = CordaRPCClient(nodeHostAndPort).start(username, password, GracefulReconnect()) proxyObservable.value = rpc.proxy // Vault snapshot (force single page load with MAX_PAGE_SIZE) + updates val ( statesSnapshot, vaultUpdates ) = rpc.proxy.vaultTrackBy&lt;ContractState&gt;( QueryCriteria.VaultQueryCriteria(Vault.StateStatus.ALL), PageSpecification(DEFAULT_PAGE_NUM, MAX_PAGE_SIZE) ) val unconsumedStates = statesSnapshot.states.filterIndexed { index, _ -&gt; statesSnapshot.statesMetadata[index].status == Vault.StateStatus.UNCONSUMED }.toSet() val consumedStates = statesSnapshot.states.toSet() - unconsumedStates val initialVaultUpdate = Vault.Update(consumedStates, unconsumedStates, references = emptySet()) vaultUpdates.startWith(initialVaultUpdate).subscribe(vaultUpdatesSubject::onNext) // Transactions val (transactions, newTransactions) = @Suppress("DEPRECATION") rpc.proxy.internalVerifiedTransactionsFeed() newTransactions.startWith(transactions).subscribe(transactionsSubject::onNext) // SM -&gt; TX mapping val (smTxMappings, futureSmTxMappings) = rpc.proxy.stateMachineRecordedTransactionMappingFeed() futureSmTxMappings.startWith(smTxMappings).subscribe(stateMachineTransactionMappingSubject::onNext) // Parties on network val (parties, futurePartyUpdate) = rpc.proxy.networkMapFeed() futurePartyUpdate.startWith(parties.map(MapChange::Added)).subscribe(networkMapSubject::onNext) val stateMachines = rpc.proxy.stateMachinesSnapshot() notaryIdentities = rpc.proxy.notaryIdentities() // Extract the flow tracking stream // TODO is there a nicer way of doing this? Stream of streams in general results in code like this... // TODO `progressTrackingSubject` doesn't seem to be used anymore - should it be removed? val currentProgressTrackerUpdates = stateMachines.mapNotNull { stateMachine -&gt; ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachine) } val futureProgressTrackerUpdates = stateMachineUpdatesSubject.map { stateMachineUpdate -&gt; if (stateMachineUpdate is StateMachineUpdate.Added) { ProgressTrackingEvent.createStreamFromStateMachineInfo(stateMachineUpdate.stateMachineInfo) ?: Observable.empty&lt;ProgressTrackingEvent&gt;() } else { Observable.empty&lt;ProgressTrackingEvent&gt;() } } // We need to retry, because when flow errors, we unsubscribe from progressTrackingSubject. So we end up with stream of state machine updates and no progress trackers. futureProgressTrackerUpdates.startWith(currentProgressTrackerUpdates).flatMap { it }.retry().subscribe(progressTrackingSubject) }</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$name.startsWith("RPCSecurityManagerShiroCache_") -&gt; with(security?.authService?.options?.cache!!) { caffeine.maximumSize(maxEntries).expireAfterWrite(expireAfterSecs, TimeUnit.SECONDS) }</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$open</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:NodeNamedCache.kt$DefaultNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters</ID>
    <ID>MaxLineLength:NodeParameters.kt$NodeParameters$fun withFlowOverrides(flowOverrides: Map&lt;Class&lt;out FlowLogic&lt;*&gt;&gt;, Class&lt;out FlowLogic&lt;*&gt;&gt;&gt;): NodeParameters</ID>
    <ID>MaxLineLength:NodePropertiesPersistentStore.kt$FlowsDrainingModeOperationsImpl : FlowsDrainingModeOperations</ID>
    <ID>MaxLineLength:NodePropertiesPersistentStore.kt$NodePropertiesPersistentStore : NodePropertiesStore</ID>
    <ID>MaxLineLength:NodeSchedulerService.kt$NodeSchedulerService.FlowStartDeduplicationHandler$private inner</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$fun internalSchemas()</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$override val schemaOptions: Map&lt;MappedSchema, SchemaService.SchemaOptions&gt; = requiredSchemas + extraSchemas.associateBy({ it }, { SchemaOptions() })</ID>
    <ID>MaxLineLength:NodeSchemaService.kt$NodeSchemaService$return VaultSchemaV1.VaultFungibleStates(state.owner, state.amount.quantity, state.amount.token.issuer.party, state.amount.token.issuer.reference)</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$NodeSchemaServiceTest.TestSchema.Child$@JoinColumns(JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"), JoinColumn(name = "output_index", referencedColumnName = "output_index"))</ID>
    <ID>MaxLineLength:NodeSchemaServiceTest.kt$NodeSchemaServiceTest.TestSchema.Parent$@JoinColumns(JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id"), JoinColumn(name = "output_index", referencedColumnName = "output_index"))</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeCliCommand$abstract</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"""\____/ /_/ \__,_/\__,_/"""</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$"Your computer took over a second to resolve localhost due an incorrect configuration. Corda will work but start very slowly until this is fixed. "</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$Node.printWarning("This node is running in development mode! ${Emoji.developer} This is not safe for production deployment.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$fun initialiseAndRun(cmdLineOptions: SharedNodeCmdLineOptions, afterNodeInitialisation: RunAfterNodeInitialisation, requireCertificates: Boolean = false): Int</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (attempt { banJavaSerialisation(configuration) }.doOnFailure(Consumer { error -&gt; error.logAsUnexpected("Exception while configuring serialisation") }) !is Try.Success) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (attempt { preNetworkRegistration(configuration) }.doOnFailure(Consumer(::handleRegistrationError)) !is Try.Success) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$if (requireCertificates &amp;&amp; !canReadCertificatesDirectory(configuration.certificatesDirectory, configuration.devMode)) return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$logger.info("The Corda node is running in production mode. If this is a developer environment you can set 'devMode=true' in the node.conf file.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$nodeStartedMessage = "$nodeStartedMessage with additional Network Map keys ${conf.extraNetworkMapKeys.joinToString(prefix = "[", postfix = "]", separator = ", ")}"</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$printError("Unable to access certificates directory ${certDirectory}. This could be because the node has not been registered with the Identity Operator.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartup$val configuration = cmdLineOptions.parseConfiguration(rawConfig).doIfValid { logRawConfig(rawConfig) }.doOnErrors(::logConfigurationErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --clear-network-map-cache flag has been deprecated and will be removed in a future version. Use the clear-network-cache command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --initial-registration flag has been deprecated and will be removed in a future version. Use the initial-registration command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --just-generate-node-info flag has been deprecated and will be removed in a future version. Use the generate-node-info command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$Node.printWarning("The --just-generate-rpc-ssl-settings flag has been deprecated and will be removed in a future version. Use the generate-rpc-ssl-settings command instead.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$override fun additionalSubCommands()</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$println("Node was started before in `initial-registration` mode, but the registration was not completed.\nResuming registration.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupCli$requireNotNull(cmdLineOptions.networkRootTrustStorePassword) { "Network root trust store password must be provided in registration mode using --network-root-truststore-password." }</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is Errors.NativeIoException &amp;&amp; error.message?.contains("Address already in use") == true -&gt; error.logAsExpected("One of the ports required by the Corda node is already in use.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is Errors.NativeIoException &amp;&amp; error.message?.contains("Can't assign requested address") == true -&gt; error.logAsExpected("Exception during node startup. Check that addresses in node config resolve correctly.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is UnresolvedAddressException -&gt; error.logAsExpected("Exception during node startup. Check that addresses in node config resolve correctly.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is java.nio.file.AccessDeniedException -&gt; error.logAsExpected("Exception during node startup. Corda started with insufficient privileges to access ${error.file}")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error is java.nio.file.NoSuchFileException -&gt; error.logAsExpected("Exception during node startup. Corda cannot find file ${error.file}")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging$error.isOpenJdkKnownIssue() -&gt; error.logAsExpected("Exception during node startup - ${error.message}. This is a known OpenJDK issue on some Linux distributions, please use OpenJDK from zulu.org or Oracle JDK.")</ID>
    <ID>MaxLineLength:NodeStartup.kt$NodeStartupLogging.Companion$val startupErrors = setOf(MultipleCordappsForFlowException::class, CheckpointIncompatibleException::class, AddressBindingException::class, NetworkParametersReader::class, DatabaseIncompatibleException::class)</ID>
    <ID>MaxLineLength:NodeStatePersistenceTests.kt$NodeStatePersistenceTests$val nodeHandle = startNode(providedName = nodeName, rpcUsers = listOf(user), customOverrides = mapOf("devMode" to "false")).getOrThrow()</ID>
    <ID>MaxLineLength:NodeTabView.kt$NodeTabView$CityDatabase.cityMap.values.map { it.countryCode }.toSet().map { it to Image(resources["/net/corda/demobench/flags/$it.png"]) }.toMap()</ID>
    <ID>MaxLineLength:NodeTerminalView.kt$NodeTerminalView${ // TODO: Remove this special case once Rick's serialisation work means we can deserialise states that weren't on our own classpath. }</ID>
    <ID>MaxLineLength:NodeTestUtils.kt$ fun testActor(owningLegalIdentity: CordaX500Name = CordaX500Name("Test Company Inc.", "London", "GB"))</ID>
    <ID>MaxLineLength:NodeTestUtils.kt$ fun testContext(owningLegalIdentity: CordaX500Name = CordaX500Name("Test Company Inc.", "London", "GB"))</ID>
    <ID>MaxLineLength:NodeUnloadHandlerTests.kt$NodeUnloadHandlerTests$assertTrue("Timed out waiting for AbstractNode to invoke the test service shutdown callback", shutdownLatch.await(30, TimeUnit.SECONDS))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$ @Throws(VaultQueryException::class) override fun &lt;T : ContractState&gt; _trackBy(criteria: QueryCriteria, paging: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$ private fun &lt;T: ContractState&gt; hasBeenSeen(update: Vault.Update&lt;T&gt;, snapshotStatesRefs: Set&lt;StateRef&gt;, snapshotConsumedStatesRefs: Set&lt;StateRef&gt;): Boolean</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Returns only output states that can be deserialised successfully. fun WireTransaction.deserializableOutputStates(): Map&lt;Int, TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$// Returns only reference states that can be deserialised successfully. fun LedgerTransaction.deserializableRefStates(): Map&lt;Int, StateAndRef&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) override</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$Vault.Page(states = statesAndRefs, statesMetadata = statesMeta, stateTypes = criteriaParser.stateTypes, totalStatesAvailable = totalStates, otherResults = otherResults)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$fun execute(configure: Root&lt;*&gt;.(CriteriaUpdate&lt;*&gt;, Array&lt;Predicate&gt;) -&gt; Any?)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageNumber &lt; DEFAULT_PAGE_NUM) throw VaultQueryException("Page specification: invalid page number ${paging.pageNumber} [page numbers start from $DEFAULT_PAGE_NUM]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageSize &lt; 1) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [minimum is 1]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$if (paging.pageSize &gt; MAX_PAGE_SIZE) throw VaultQueryException("Page specification: invalid page size ${paging.pageSize} [maximum is $MAX_PAGE_SIZE]")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$isRelevant(value.data, keyManagementService.filterMyKeys(outputs.values.flatMap { it.data.participants.map { it.owningKey } }).toSet())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.trace { "Removing $consumedStateRefs consumed contract states and adding $producedStateRefs produced contract states to the database." }</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.warn("There are unknown contract state types in the vault, which will prevent these states from being used. The relevant CorDapps must be loaded for these states to be used. The types not on the classpath are ${unknownTypes.joinToString(", ", "[", "]")}.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$log.warn("trackBy is called with an already existing, open DB transaction. As a result, there might be states missing from both the snapshot and observable, included in the returned data feed, because of race conditions.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$private</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(lockId))</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$throw VaultQueryException("There are ${results.size} results, which exceeds the limit of $DEFAULT_PAGE_SIZE for queries that do not specify paging. In order to retrieve these results, provide a `PageSpecification(pageNumber, pageSize)` to the method invoked.")</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val criteriaParser = HibernateQueryCriteriaParser(contractStateType, contractStateTypeMappings, criteriaBuilder, criteriaQuery, queryRootVaultStates)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val lockUpdateTime = criteriaBuilder.equal(get&lt;Instant&gt;(VaultSchemaV1.VaultStates::lockUpdateTime.name), softLockTimestamp)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val results = _queryBy(criteria.and(countCriteria), PageSpecification(), Sort(emptyList()), contractStateType, true) // only skip pagination checks for total results count query</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val stateStatusPredication = criteriaBuilder.equal(get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultStates::stateStatus.name), Vault.StateStatus.UNCONSUMED)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService$val txIdPredicate = criteriaBuilder.equal(vaultStates.get&lt;Vault.StateStatus&gt;(VaultSchemaV1.VaultTxnNote::txId.name), txnId.toString())</ID>
    <ID>MaxLineLength:NodeVaultService.kt$NodeVaultService.InnerState$// For use during publishing only. val updatesPublisher: rx.Observer&lt;Vault.Update&lt;ContractState&gt;&gt; get() = _updatesPublisher.bufferUntilDatabaseCommit().tee(_rawUpdatesPublisher)</ID>
    <ID>MaxLineLength:NodeVaultService.kt$private</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$(services.validatedTransactions as WritableTransactionStorage).addTransaction(SignedTransaction(changeNotaryTx, listOf(NullKeys.NULL_SIGNATURE)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$TransactionState(Cash.State(amount `issued by` issuer.ref(depositRef), identity.party), Cash.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(UniqueDummyFungibleContract.State(10.DOLLARS `issued by` DUMMY_CASH_ISSUER, megaCorp.party), UNIQUE_DUMMY_FUNGIBLE_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$addOutputState(UniqueDummyLinearContract.State(listOf(megaCorp.party), "Dummy linear id"), UNIQUE_DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer).isNotEqualTo(spendableStatesUSD[1].state.data.amount.token.issuer)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$assertThat(spendableStatesUSD[0].state.data.amount.token.issuer.reference).isNotEqualTo(spendableStatesUSD[1].state.data.amount.token.issuer.reference)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$cash.generateIssue(issuance, Amount(howMuch.quantity, Issued(DUMMY_CASH_ISSUER, howMuch.token)), services.myInfo.singleIdentity(), dummyNotary.party)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val changeNotaryTx = NotaryChangeTransactionBuilder(listOf(initialCashState.ref), issueStx.notary!!, newNotary, services.networkParametersService.currentHash).build()</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId1 = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId1)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaByLockId2 = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(softLockId2)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId)))</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val expectedNotaryChangeUpdate = Vault.Update(setOf(initialCashState), setOf(cashStateWithNewNotary), null, Vault.UpdateType.NOTARY_CHANGE)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val thirdPartyIdentity = thirdPartyServices.keyManagementService.freshKeyAndCert(thirdPartyServices.myInfo.singleIdentityAndCert(), false)</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates1 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$val unlockedStates2 = vaultService.queryBy&lt;Cash.State&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_ONLY))).states</ID>
    <ID>MaxLineLength:NodeVaultServiceTest.kt$NodeVaultServiceTest$vaultService.queryBy(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(relevancyStatus = Vault.RelevancyStatus.ALL), PageSpecification(1)).totalStatesAvailable</ID>
    <ID>MaxLineLength:NonInvalidatingCache.kt$NonInvalidatingWeightBasedCache.Companion$private</ID>
    <ID>MaxLineLength:NonInvalidatingUnboundCache.kt$NonInvalidatingUnboundCache$constructor(name: String, cacheFactory: NamedCacheFactory, loadFunction: (K) -&gt; V, removalListener: RemovalListener&lt;K, V&gt; = RemovalListener { _, _, _ -&gt; }, keysToPreload: () -&gt; Iterable&lt;K&gt; = { emptyList() }) : this(buildCache(name, cacheFactory, loadFunction, removalListener, keysToPreload))</ID>
    <ID>MaxLineLength:NonInvalidatingUnboundCache.kt$NonInvalidatingUnboundCache.Companion$private</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow : NotaryServiceFlow</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$?:</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$is FilteredTransaction -&gt; TransactionParts(tx.id, tx.inputs, tx.timeWindow, tx.notary, tx.references, networkParametersHash = tx.networkParametersHash)</ID>
    <ID>MaxLineLength:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$is NotaryChangeWireTransaction</ID>
    <ID>MaxLineLength:NonValidatingNotaryServiceTests.kt$NonValidatingNotaryServiceTests.&lt;no name provided&gt;$val alteredMessage = InMemoryMessage(message.topic, OpaqueBytes(alteredMessageData.serialize().bytes), message.uniqueMessageId)</ID>
    <ID>MaxLineLength:Notarise.kt$NotaryDemoClientApi$rpc.startFlow(::RPCStartableNotaryFlowClient, it).returnValue.toCompletableFuture().thenApply { it.map { it.by.toStringShort() } }</ID>
    <ID>MaxLineLength:NotaryChangeFlow.kt$NotaryChangeFlow$val signableData = SignableData(tx.id, SignatureMetadata(serviceHub.myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$assertTrue { originalLinkedStates.size == notaryChangeLinkedStates.size &amp;&amp; originalLinkedStates.containsAll(notaryChangeLinkedStates) }</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$NotaryChangeTests$private</ID>
    <ID>MaxLineLength:NotaryChangeTests.kt$fun issueMultiPartyState(nodeA: StartedMockNode, nodeB: StartedMockNode, notaryNode: StartedMockNode, notaryIdentity: Party): StateAndRef&lt;DummyContract.MultiOwnerState&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$ @CordaInternal internal fun resolveOutputComponent( services: ServicesForResolution, stateRef: StateRef, @Suppress("UNUSED_PARAMETER") params: NetworkParameters ): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;</ID>
    <ID>MaxLineLength:NotaryChangeTransactions.kt$NotaryChangeWireTransaction$@Deprecated("Required only for backwards compatibility purposes. This type of transaction should not be constructed outside Corda code.", ReplaceWith("NotaryChangeTransactionBuilder"), DeprecationLevel.WARNING)</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$"To find out if any of the conflicting transactions have been generated by this node you can use the hashLookup Corda shell command."</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.Conflict$override</ID>
    <ID>MaxLineLength:NotaryError.kt$NotaryError.WrongNotary$@Deprecated("Deprecated since platform version 4. This object is no longer used, [TransactionInvalid] will be reported in case of notary mismatch")</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$"Notary $notaryParty is not on the network parameter whitelist. A non-whitelisted notary can only be used for notary change transactions"</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$?:</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client$val notarisationRequest = NotarisationRequest(stx.inputs.map { it.copy(txhash = SecureHash.parse(it.txhash.toString())) }, stx.id)</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$@Suspendable override</ID>
    <ID>MaxLineLength:NotaryFlow.kt$NotaryFlow.Client.NotarySendTransactionFlow$private</ID>
    <ID>MaxLineLength:NotaryFlow.kt$net.corda.core.flows.NotaryFlow.kt</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$ private fun validateNotaryType(myNotaryIdentity: PartyAndCertificate?, services: ServiceHubInternal)</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$+</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$?:</ID>
    <ID>MaxLineLength:NotaryLoader.kt$NotaryLoader$throw IllegalStateException("There is a discrepancy in the configured notary type and the one advertised in the network parameters - shutting down. " + "Configured as validating: ${configuredAsValidatingNotary}. Advertised as validating: ${validatingNotaryInNetworkMapCache}")</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$"The notary specified on the transaction: [$notary] does not match the notary service's identity: [${service.notaryIdentityKey}] "</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$@Suspendable private</ID>
    <ID>MaxLineLength:NotaryServiceFlow.kt$NotaryServiceFlow$abstract</ID>
    <ID>MaxLineLength:NotaryServiceTests.kt$NotaryServiceTests.Companion$val signableData = SignableData(tx.id, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(myKey).schemeNumberID))</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$ @Test fun `can perform notary change on a de-listed notary`()</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$notarySpecs = listOf(MockNetworkNotarySpec(oldNotaryName, validating = isValidating), MockNetworkNotarySpec(newNotaryName, validating = isValidating))</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests$private</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ // Issue a state using the old notary. It is currently whitelisted. val stateFakeNotary = issueStateOnOldNotary(oldNotary) // Remove old notary from the whitelist val parameters = aliceNode.services.networkParameters val newParameters = removeOldNotary(parameters) mockNet.nodes.forEach { (it.networkParametersStorage as MockNetworkParametersStorage).setCurrentParametersUnverified(newParameters) } // Re-point the state to the remaining whitelisted notary. The transaction itself should be considered valid, even though the old notary is not whitelisted. val futureChange = aliceNode.services.startFlow(NotaryChangeFlow(stateFakeNotary, newNotary)).resultFuture mockNet.runNetwork() val newSTate = futureChange.getOrThrow() // Create a valid transaction consuming the re-pointed state. val validTxBuilder = TransactionBuilder(newNotary) .addInputState(newSTate) .addCommand(dummyCommand(alice.owningKey)) val validStx = aliceNode.services.signInitialTransaction(validTxBuilder) // The transaction verifies. validStx.verify(aliceNode.services, false) // Notarisation should succeed. val future = runNotaryClient(validStx) future.getOrThrow() }</ID>
    <ID>MaxLineLength:NotaryWhitelistTests.kt$NotaryWhitelistTests${ Assume.assumeTrue(isValidating) // Skip the test for non-validating notaries val fakeNotaryKeyPair = generateKeyPair() val fakeNotaryParty = Party(DUMMY_NOTARY_NAME.copy(organisation = "Fake notary"), fakeNotaryKeyPair.public) // Issue a state using an unlisted notary. This transaction should not verify when checked by counterparties. val stateFakeNotary = issueStateWithFakeNotary(fakeNotaryParty, fakeNotaryKeyPair) // Re-point the state to the whitelisted notary. The transaction itself should be considered valid, even though the old notary is not whitelisted. val notaryChangeLtx = changeNotary(stateFakeNotary, fakeNotaryParty, fakeNotaryKeyPair) // Create a valid transaction consuming the re-pointed state. val inputStateValidNotary = notaryChangeLtx.outRef&lt;DummyContract.State&gt;(0) val validTxBuilder = TransactionBuilder(oldNotary) .addInputState(inputStateValidNotary) .addCommand(dummyCommand(alice.owningKey)) val validStx = aliceNode.services.signInitialTransaction(validTxBuilder) // The transaction itself verifies, as no resolution is done here. validStx.verify(aliceNode.services, false) val future = runNotaryClient(validStx) // The notary should reject this transaction – the issue transaction in the dependencies should not verify. val ex = assertFailsWith(NotaryException::class) { future.getOrThrow() } assert(ex.error is NotaryError.TransactionInvalid) assertEquals(validStx.id, ex.txId) }</ID>
    <ID>MaxLineLength:OGStub.kt$BimmAnalysisUtils$fun computeMargin(combinedRatesProvider: ImmutableRatesProvider?, normalizer: PortfolioNormalizer, calculatorTotal: RwamBimmNotProductClassesCalculator, first: CurrencyParameterSensitivities, second: MultiCurrencyAmount): Triple&lt;Double, Double, Double&gt;</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val marketData = ImmutableMarketData.builder(VAL_DATE).addValueMap(quotesCcp1).addValueMap(quotesCcp2).addTimeSeriesMap(fixings).build()</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val marketDataConfig = MarketDataConfig.builder().add(CURVE_GROUP_NAME_CCP1, curveGroupDefinitionCcp1).add(CURVE_GROUP_NAME_CCP2, curveGroupDefinitionCcp2).build()</ID>
    <ID>MaxLineLength:OGSwapPricingCcpExample.kt$SwapPricingCcpExample$val tradeInfo = TradeInfo.builder().id(StandardId.of("example", "1")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 3m").counterparty(ctptyId).settlementDate(LocalDate.of(2014, 9, 12)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$PeriodicSchedule.builder() .startDate(LocalDate.of(2014, 9, 12)) .endDate(LocalDate.of(2016, 6, 12)) .stubConvention(StubConvention.SHORT_INITIAL) .frequency(Frequency.P6M)</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "10")).addAttribute(TradeAttributeType.DESCRIPTION, "Zero-coupon fixed vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "11")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding fixed vs fed funds").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 2, 5)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "12")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding fed funds vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "13")).addAttribute(TradeAttributeType.DESCRIPTION, "Compounding libor 6m vs libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 8, 27)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "15")).addAttribute(TradeAttributeType.DESCRIPTION, "USD fixed vs GBP Libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "16")).addAttribute(TradeAttributeType.DESCRIPTION, "USD fixed vs GBP Libor 3m (notional exchange)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "2")).addAttribute(TradeAttributeType.DESCRIPTION, "Libor 3m + spread vs Libor 6m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "7")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 3m (1m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "8")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 6m (interpolated 3m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(payLeg, receiveLeg)).info(TradeInfo.builder().id(StandardId.of("example", "9")).addAttribute(TradeAttributeType.DESCRIPTION, "Fixed vs Libor 6m (interpolated 4m short initial stub)").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 9, 12)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$return SwapTrade.builder().product(Swap.of(receiveLeg, payLeg)).info(TradeInfo.builder().id(StandardId.of("example", "14")).addAttribute(TradeAttributeType.DESCRIPTION, "GBP Libor 3m vs USD Libor 3m").counterparty(StandardId.of("example", "A")).settlementDate(LocalDate.of(2014, 1, 24)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.GBP, 61600000.0)).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.builder().currency(Currency.USD).amount(ValueSchedule.of(100000000.0)).initialExchange(true).finalExchange(true).build()).calculation(FixedRateCalculation.of(0.03, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.USD, 100000000.0)).calculation(FixedRateCalculation.of(0.03, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 2, 5)).endDate(LocalDate.of(2014, 4, 7)).frequency(Frequency.TERM).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.00123, DayCounts.ACT_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 8, 27)).endDate(LocalDate.of(2024, 8, 27)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_6M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 6, 12)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_6M).initialStub(IborRateStubCalculation.ofIborInterpolatedRate(IborIndices.USD_LIBOR_3M, IborIndices.USD_LIBOR_6M)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_6M).initialStub(IborRateStubCalculation.ofIborInterpolatedRate(IborIndices.USD_LIBOR_3M, IborIndices.USD_LIBOR_6M)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2020, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val payLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.PAY).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2021, 9, 12)).frequency(Frequency.P12M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.015, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.builder().currency(Currency.GBP).amount(ValueSchedule.of(61600000.0)).initialExchange(true).finalExchange(true).build()).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.GBLO)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.GBP, 61600000.0)).calculation(IborRateCalculation.of(IborIndices.GBP_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 1, 24)).endDate(LocalDate.of(2021, 1, 24)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(NotionalSchedule.of(Currency.USD, 100000000.0)).calculation(IborRateCalculation.builder().index(IborIndices.USD_LIBOR_3M).spread(ValueSchedule.of(0.0091)).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 2, 5)).endDate(LocalDate.of(2014, 4, 7)).frequency(Frequency.TERM).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).stubConvention(StubConvention.SHORT_INITIAL).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(OvernightRateCalculation.of(OvernightIndices.USD_FED_FUND)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 8, 27)).endDate(LocalDate.of(2024, 8, 27)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 6, 12)).stubConvention(StubConvention.SHORT_INITIAL).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.01, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2016, 7, 12)).stubConvention(StubConvention.SHORT_INITIAL).frequency(Frequency.P6M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P6M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(FixedRateCalculation.of(0.01, DayCounts.THIRTY_U_360)).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2020, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.P3M).paymentDateOffset(DaysAdjustment.NONE).build()).notionalSchedule(notional).calculation(OvernightRateCalculation.builder().index(OvernightIndices.USD_FED_FUND).accrualMethod(OvernightAccrualMethod.AVERAGED).build()).build()</ID>
    <ID>MaxLineLength:OGSwapPricingExample.kt$SwapPricingExample$val receiveLeg = RateCalculationSwapLeg.builder().payReceive(PayReceive.RECEIVE).accrualSchedule(PeriodicSchedule.builder().startDate(LocalDate.of(2014, 9, 12)).endDate(LocalDate.of(2021, 9, 12)).frequency(Frequency.P3M).businessDayAdjustment(BusinessDayAdjustment.of(MODIFIED_FOLLOWING, HolidayCalendarIds.USNY)).build()).paymentSchedule(PaymentSchedule.builder().paymentFrequency(Frequency.TERM).paymentDateOffset(DaysAdjustment.NONE).compoundingMethod(CompoundingMethod.STRAIGHT).build()).notionalSchedule(notional).calculation(IborRateCalculation.of(IborIndices.USD_LIBOR_3M)).build()</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$AbstractObjectSerializer$override</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$ComposableObjectSerializer$override</ID>
    <ID>MaxLineLength:ObjectSerializer.kt$EvolutionObjectSerializer$override</ID>
    <ID>MaxLineLength:Obligation.kt$ fun &lt;P : Any&gt; extractAmountsDue(product: Obligation.Terms&lt;P&gt;, states: Iterable&lt;Obligation.State&lt;P&gt;&gt;): Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$"amount in settle command ${command.value.amount} matches settled total $totalAmountSettled" using (command.value.amount == totalAmountSettled)</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val exitCommand = tx.commands.select&lt;Commands.Exit&lt;P&gt;&gt;(parties = null, signers = exitKeys).singleOrNull { it.value.amount.token == key }</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val inputAmount = inputs.sumObligationsOrNull&lt;P&gt;() ?: throw IllegalArgumentException("there is at least one obligation input for this group")</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val inputAmount: Amount&lt;Issued&lt;Terms&lt;P&gt;&gt;&gt; = inputs.sumObligationsOrNull() ?: throw IllegalArgumentException("there is at least one obligation input for this group")</ID>
    <ID>MaxLineLength:Obligation.kt$Obligation$val involvedParties: Set&lt;PublicKey&gt; = groupInputs.map { it.beneficiary.owningKey }.union(groupInputs.map { it.obligor.owningKey }).toSet()</ID>
    <ID>MaxLineLength:Obligation.kt$infix fun &lt;T : Any&gt; Obligation.State&lt;T&gt;.between(parties: Pair&lt;AbstractParty, AbstractParty&gt;)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ObligationUtils.generatePaymentNetting(this, obligationAliceToBob.state.data.amount.token, DUMMY_NOTARY, obligationAliceToBob, obligationBobToAlice)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ObligationUtils.generatePaymentNetting(this, obligationAliceToBobState.amount.token, DUMMY_NOTARY, obligationAliceToBob, obligationBobToAlice)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$ObligationUtils.generateSettle(this, listOf(obligationTx.outRef&lt;Obligation.State&lt;Currency&gt;&gt;(0)), listOf(cashTx.outRef(0)), Cash.Commands.Move(), DUMMY_NOTARY)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$assertNotEquals(oneKDollarsFromMiniToMega.bilateralNetState, oneKDollarsFromMiniToMega.copy(template = megaCorpPoundSettlement).bilateralNetState)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(CHARLIE.owningKey, Obligation.Commands.Exit(Amount(200.DOLLARS.quantity, inState.amount.token.copy(product = megaCorpDollarSettlement))))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$command(CHARLIE.owningKey, Obligation.Commands.Exit(Amount(200.POUNDS.quantity, inState.amount.token.copy(product = megaCorpPoundSettlement))))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$fiveKDollarsFromMegaToMega.copy(template = megaCorpDollarSettlement.copy(acceptableContracts = NonEmptySet.of(SecureHash.randomSHA256()))).bilateralNetState</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$fiveKDollarsFromMegaToMega.copy(template = megaCorpDollarSettlement.copy(acceptableIssuedProducts = miniCorpIssuer)).bilateralNetState</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's defaulted $1,000,000 obligation to Bob", (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB) at futureTestTime).copy(lifecycle = Lifecycle.DEFAULTED))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's defaulted $1,000,000 obligation to Bob", (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB) at pastTestTime).copy(lifecycle = Lifecycle.DEFAULTED))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "Alice's defaulted $1,000,000 obligation to Bob", (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB)).copy(lifecycle = Lifecycle.DEFAULTED))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "MegaCorp's $1,000,000 obligation to Alice", oneMillionDollars.OBLIGATION between Pair(MEGA_CORP, ALICE))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, "MegaCorp's $1,000,000 obligation to Bob", oneMillionDollars.OBLIGATION between Pair(MEGA_CORP, BOB))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, inState.copy(template = inState.template.copy(acceptableIssuedProducts = megaIssuedDollars), quantity = inState.quantity - 200.DOLLARS.quantity))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$output(Obligation.PROGRAM_ID, inState.copy(template = inState.template.copy(acceptableIssuedProducts = megaIssuedPounds), quantity = inState.quantity - 200.POUNDS.quantity))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$private val ledgerServices get() = MockServices(listOf("net.corda.finance.contracts.asset", "net.corda.testing.contracts"), MEGA_CORP.name, identityService)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val defaultedObligation: Obligation.State&lt;Currency&gt; = (oneMillionDollars.OBLIGATION between Pair(ALICE, BOB)).copy(lifecycle = Lifecycle.DEFAULTED)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val expected: Map&lt;Pair&lt;AbstractParty, AbstractParty&gt;, Amount&lt;Obligation.Terms&lt;Currency&gt;&gt;&gt; = mapOf(Pair(Pair(MEGA_CORP, MINI_CORP), Amount(amount.quantity, amount.token.product)))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationAliceToBob = getStateAndRef((2000000.DOLLARS `issued by` defaultIssuer).OBLIGATION between Pair(ALICE, BOB), Obligation.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationBobToAlice = getStateAndRef((2000000.DOLLARS `issued by` defaultIssuer).OBLIGATION between Pair(BOB, ALICE), Obligation.PROGRAM_ID)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val obligationDef = Obligation.Terms(NonEmptySet.of(commodityContractBytes.sha256() as SecureHash), NonEmptySet.of(defaultFcoj), TEST_TX_TIME)</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests$val pounds = Obligation.State(Lifecycle.NORMAL, MINI_CORP, megaCorpPoundSettlement, 658.POUNDS.quantity, AnonymousParty(BOB_PUBKEY))</ID>
    <ID>MaxLineLength:ObligationTests.kt$ObligationTests.&lt;no name provided&gt;$override fun loadState(stateRef: StateRef): TransactionState&lt;*&gt;</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$"all obligation states are in the normal state" using (statesAndRefs.all { it.state.data.lifecycle == Obligation.Lifecycle.NORMAL })</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addCommand(Obligation.Commands.Settle(Amount((obligationTotal - obligationRemaining).quantity, issuanceDef)), obligationIssuer.owningKey)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(Obligation.State(Obligation.Lifecycle.NORMAL, obligationIssuer, template, obligationRemaining.quantity, obligationOwner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObligationUtils.kt$ObligationUtils$tx.addOutputState(assetState.withNewOwnerAndAmount(assetState.amount - change, assetState.owner), Obligation.PROGRAM_ID, notary)</ID>
    <ID>MaxLineLength:ObservableFold.kt$ fun &lt;A, K&gt; Observable&lt;A&gt;.recordAsAssociation(toKey: (A) -&gt; K, merge: (K, oldValue: A, newValue: A) -&gt; A = { _, _, newValue -&gt; newValue }): ObservableMap&lt;K, A&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ @Suppress("UNCHECKED_CAST") fun &lt;A&gt; Collection&lt;ObservableValue&lt;out A&gt;&gt;.sequence(): ObservableList&lt;A&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt$ @Suppress("UNCHECKED_CAST") fun &lt;K : Any, A : Any, B&gt; ObservableList&lt;out A&gt;.associateByAggregation(toKey: (A) -&gt; K, assemble: (K, A) -&gt; B): ObservableMap&lt;K, ObservableList&lt;B&gt;&gt;</ID>
    <ID>MaxLineLength:ObservableUtilities.kt${ //TODO This is a tactical work round for an issue with SAM conversion (https://youtrack.jetbrains.com/issue/ALL-1552) so that the M10 explorer works. return uncheckedCast(uncheckedCast&lt;Any, ObservableList&lt;A?&gt;&gt;(this).filtered { t -&gt; t != null }) }</ID>
    <ID>MaxLineLength:ObserverNodeTransactionTests.kt$ObserverNodeTransactionTests.StartMessageChainFlow$val txBuilder = TransactionBuilder(notary).withItems(StateAndContract(messageState, MESSAGE_CHAIN_CONTRACT_PROGRAM_ID), txCommand)</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$deriveState: (TransactionState&lt;S&gt;, Amount&lt;Issued&lt;T&gt;&gt;, AbstractParty) -&gt; TransactionState&lt;S&gt;</ID>
    <ID>MaxLineLength:OnLedgerAsset.kt$OnLedgerAsset.Companion$generateMoveCommand: () -&gt; CommandData</ID>
    <ID>MaxLineLength:OpenGammaCordaUtils.kt$ fun InitialMarginTriple.toCordaCompatible()</ID>
    <ID>MaxLineLength:OpenGammaCordaUtils.kt$return MultiCurrencyAmount.of(this.amounts.map { CurrencyAmount.of(Currency.of(it.currency.code).serialize().deserialize(), twoDecimalPlaces((it.amount))) })</ID>
    <ID>MaxLineLength:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$TransactionBuilder(DUMMY_NOTARY) .withItems(TransactionState(1000.DOLLARS.CASH issuedBy dummyCashIssuer.party ownedBy alice.party, Cash.PROGRAM_ID, DUMMY_NOTARY))</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.rpc.hasCancelledDrainingShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted { successful = true }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.rpc.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted(nodeA::stop)</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.waitForShutdown().doOnError(Throwable::printStackTrace).doAfterTerminate { successful = false }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$nodeA.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted { successful = true }.doAfterTerminate(latch::countDown).subscribe()</ID>
    <ID>MaxLineLength:P2PFlowsDrainingModeTest.kt$P2PFlowsDrainingModeTest$val nodeA = startNode(providedName = ALICE_NAME, rpcUsers = users).getOrThrow() var successful = false val latch = CountDownLatch(1) // This would not be needed, as `terminate(true)` sets draining mode anyway, but it's here to ensure that it removes the persistent value anyway. nodeA.rpc.setFlowsDrainingModeEnabled(true) nodeA.rpc.waitForShutdown().doOnError(Throwable::printStackTrace).doOnError { successful = false }.doOnCompleted(nodeA::stop).doOnCompleted { val nodeARestarted = startNode(providedName = ALICE_NAME, rpcUsers = users).getOrThrow() successful = !nodeARestarted.rpc.isFlowsDrainingModeEnabled() }.doAfterTerminate(latch::countDown).subscribe() nodeA.rpc.terminate(true) latch.await() assertThat(successful).isTrue()</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$private</ID>
    <ID>MaxLineLength:P2PMessageDeduplicator.kt$P2PMessageDeduplicator$val senderHash: String? = if (receivedSenderUUID != null &amp;&amp; receivedSenderSeqNo != null) senderHash(SenderKey(receivedSenderUUID, msg.peer, msg.isSessionInit)) else null</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$ fun start(myIdentity: PublicKey, serviceIdentity: PublicKey?, maxMessageSize: Int, advertisedAddress: NetworkHostAndPort = serverAddress)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$log.trace { "Received message from: ${message.address} user: $user topic: $topic id: $uniqueMessageId senderUUID: $receivedSenderUUID senderSeqNo: $receivedSenderSeqNo isSessionInit: $isSessionInit" }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$override</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$return ArtemisReceivedMessage(topic, CordaX500Name.parse(user), platformVersion, uniqueMessageId, receivedSenderUUID, receivedSenderSeqNo, isSessionInit, message)</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val createNewSession = { sessionFactory!!.createSession(ArtemisMessagingComponent.NODE_P2P_USER, ArtemisMessagingComponent.NODE_P2P_USER, false, true, true, false, ActiveMQClient.DEFAULT_ACK_BATCH_SIZE) }</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient$val receivedSenderSeqNo = if (message.containsProperty(P2PMessagingHeaders.senderSeqNo)) message.getLongProperty(P2PMessagingHeaders.senderSeqNo) else null</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingClient.MessageDeduplicationHandler$private inner</ID>
    <ID>MaxLineLength:P2PMessagingClient.kt$P2PMessagingConsumer$logger.warn("Node is currently in draining mode, new flows will not be processed! Flows in flight: ${metricsRegistry.gauges["Flows.InFlight"]?.value}")</ID>
    <ID>MaxLineLength:PartialMerkleTree.kt$PartialMerkleTree.Companion$ fun rootAndUsedHashes(node: PartialTree, usedHashes: MutableList&lt;SecureHash&gt;): SecureHash</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$assertFailsWith&lt;MerkleTreeException&gt; { PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("20"), SecureHash.sha256("1"), SecureHash.sha256("5"))) }</ID>
    <ID>MaxLineLength:PartialMerkleTreeTest.kt$PartialMerkleTreeTest$val pmt = PartialMerkleTree.build(merkleTree, listOf&lt;SecureHash&gt;(SecureHash.sha256("1"), SecureHash.sha256("5"), SecureHash.sha256("0"), SecureHash.sha256("19")))</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$require(role?.isIdentity ?: false) { "Party certificate ${certificate.subjectDN} does not have a well known or confidential identity role. Found: $role" }</ID>
    <ID>MaxLineLength:PartyAndCertificate.kt$PartyAndCertificate$throw CertPathValidatorException("The issuing certificate for $certificateString has role $parentRole, expected one of ${role.validParents}")</ID>
    <ID>MaxLineLength:Perceivable.kt$@Suppress("UNUSED_PARAMETER") start: Perceivable&lt;Instant&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$@Suppress("UNUSED_PARAMETER") start: String</ID>
    <ID>MaxLineLength:Perceivable.kt$Interest$val interest: Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$PerceivableComparison&lt;T&gt; : Perceivable</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: BigDecimal /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: Perceivable&lt;Instant&gt;, @Suppress("UNUSED_PARAMETER") end: Perceivable&lt;Instant&gt;): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: BigDecimal /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: String, @Suppress("UNUSED_PARAMETER") end: String): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: Perceivable&lt;BigDecimal&gt; /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: Perceivable&lt;Instant&gt;, @Suppress("UNUSED_PARAMETER") end: Perceivable&lt;Instant&gt;): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:Perceivable.kt$fun interest(@Suppress("UNUSED_PARAMETER") amount: BigDecimal, @Suppress("UNUSED_PARAMETER") dayCountConvention: String, @Suppress("UNUSED_PARAMETER") interest: Perceivable&lt;BigDecimal&gt; /* todo - appropriate type */, @Suppress("UNUSED_PARAMETER") start: String, @Suppress("UNUSED_PARAMETER") end: String): Perceivable&lt;BigDecimal&gt;</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable : CordaMigration</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTable.kt$PersistentIdentityMigrationNewTable$throw PersistentIdentitiesMigrationException("Cannot migrate persistent identities as liquibase failed to provide a suitable database connection")</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$session.save(PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.hash.toString(), it.certPath.encoded))</ID>
    <ID>MaxLineLength:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$val identityService = makeTestIdentityService(PersistentIdentityMigrationNewTableTest.dummyNotary.identity, BOB_IDENTITY, ALICE_IDENTITY)</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$listOf("Organisation A", "Organisation B", "Organisation C") .map { getTestPartyAndCertificate(CordaX500Name(organisation = it, locality = "London", country = "GB"), generateKeyPair().public) }</ID>
    <ID>MaxLineLength:PersistentIdentityServiceTests.kt$PersistentIdentityServiceTests$val alicente = getTestPartyAndCertificate(CordaX500Name(organisation = "Alicente Worldwide", locality = "London", country = "GB"), generateKeyPair().public)</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap$ExplicitRemoval&lt;K, V, E, EK&gt; : RemovalListener</ID>
    <ID>MaxLineLength:PersistentMap.kt$PersistentMap.NotReallyMutableEntry$private</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT DISTINCT l FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.name = :name"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.addresses a WHERE a.host = :host AND a.port = :port"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.name = :name"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$"SELECT n FROM ${NodeInfoSchemaV1.PersistentNodeInfo::class.java.name} n JOIN n.legalIdentitiesAndCerts l WHERE l.owningKeyHash = :owningKeyHash"</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$val info = findByIdentityKey(session, nodeInfo.legalIdentitiesAndCerts.first().owningKey).singleOrNull { it.serial == nodeInfo.serial }</ID>
    <ID>MaxLineLength:PersistentNetworkMapCache.kt$PersistentNetworkMapCache$val newNodes = mutableListOf&lt;NodeInfo&gt;() val updatedNodes = mutableListOf&lt;Pair&lt;NodeInfo, NodeInfo&gt;&gt;() nodes.map { it to getNodesByLegalIdentityKey(it.legalIdentities.first().owningKey).firstOrNull() } .forEach { (node, previousNode) -&gt; when { previousNode == null -&gt; { logger.info("No previous node found for ${node.legalIdentities.first().name}") if (verifyAndRegisterIdentities(node)) { newNodes.add(node) } } previousNode.serial &gt; node.serial -&gt; { logger.info("Discarding older nodeInfo for ${node.legalIdentities.first().name}") } previousNode != node -&gt; { logger.info("Previous node was found for ${node.legalIdentities.first().name} as: $previousNode") // TODO We should be adding any new identities as well if (verifyIdentities(node)) { updatedNodes.add(node to previousNode) } } else -&gt; logger.info("Previous node was identical to incoming one - doing nothing") } } /** * This algorithm protects against database failure (eg. attempt to persist a nodeInfo entry larger than permissible by the * database X500Name) without sacrificing performance incurred by attempting to flush nodeInfo's individually. * Upon database transaction failure, the list of new nodeInfo's is split in half, and then each half is persisted independently. * This continues recursively until all valid nodeInfo's are persisted, and failed ones reported as warnings. */ recursivelyUpdateNodes(newNodes.map { nodeInfo -&gt; Pair(nodeInfo, MapChange.Added(nodeInfo)) } + updatedNodes.map { (nodeInfo, previousNodeInfo) -&gt; Pair(nodeInfo, MapChange.Modified(nodeInfo, previousNodeInfo)) })</ID>
    <ID>MaxLineLength:PersistentNetworkMapCacheTest.kt$PersistentNetworkMapCacheTest$private val charlieNetMapCache = PersistentNetworkMapCache(TestingNamedCacheFactory(), database, InMemoryIdentityService(trustRoot = DEV_ROOT_CA.certificate))</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$private</ID>
    <ID>MaxLineLength:PersistentScheduledFlowRepository.kt$PersistentScheduledFlowRepository$return Pair(StateRef(SecureHash.parse(txId), index), ScheduledStateRef(StateRef(SecureHash.parse(txId), index), scheduledStateRecord.scheduledAt))</ID>
    <ID>MaxLineLength:PersistentStateServiceTests.kt$PersistentStateServiceTests$persistentStateService.persist(setOf(StateAndRef(TransactionState(TestState(), DummyContract.PROGRAM_ID, MEGA_CORP, constraint = AlwaysAcceptAttachmentConstraint), StateRef(SecureHash.sha256("dummy"), 0))))</ID>
    <ID>MaxLineLength:PersistentTypes.kt$IndirectStatePersistable&lt;T : DirectStatePersistable&gt; : StatePersistable</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator$annotations.any { annotation -&gt; annotation.toString().startsWith("@javax.persistence.") &amp;&amp; annotation !is javax.persistence.Transient }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ field -&gt; field.type.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(field.type.enclosingClass) &amp;&amp; hasJpaAnnotation(field.declaredAnnotations) &amp;&amp; field.type.enclosingClass != schema.javaClass }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator${ method -&gt; method.returnType.enclosingClass != null &amp;&amp; MappedSchema::class.java.isAssignableFrom(method.returnType.enclosingClass) &amp;&amp; method.returnType.enclosingClass != schema.javaClass &amp;&amp; hasJpaAnnotation(method.declaredAnnotations) }</ID>
    <ID>MaxLineLength:PersistentTypes.kt$MappedSchemaValidator.SchemaCrossReferenceReport$"MappedSchema '${schema.substringAfterLast(".")}' entity '$entity' field '$fieldOrMethod' is of type '$fieldOrMethodType' "</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider : UniquenessProviderSingletonSerializeAsToken</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$commitOne(request.states, request.txId, request.callerIdentity, request.requestSignature, request.timeWindow, request.references)</ID>
    <ID>MaxLineLength:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$private</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$ @POST @Path("{party}/portfolio/valuations/calculate") @Produces(MediaType.APPLICATION_JSON) fun startPortfolioCalculations(params: ValuationCreationParams = ValuationCreationParams(LocalDate.of(2016, 6, 6)), @PathParam("party") partyName: String): Response</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$counterparties = counterParties.flatMap { it.legalIdentitiesAndCerts.map { ApiParty(it.owningKey.toBase58String(), it.name) } }</ID>
    <ID>MaxLineLength:PortfolioApi.kt$PortfolioApi$val history = AggregatedHistoryView(state.valuation!!.trades, notional.toDouble(), LocalDate.now(), state.valuation!!.margin.first, mtm)</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$"floatingRatePayer" to (floatingRatePayer.nameOrNull()?.organisation ?: floatingRatePayer.owningKey.toBase58String())</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$InitialMarginView</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val processedSensitivities = valuation.totalSensivities.sensitivities.map { it.marketDataName to it.parameterMetadata.map { it.label }.zip(it.sensitivity.toList()).toMap() }.toMap()</ID>
    <ID>MaxLineLength:PortfolioApiUtils.kt$PortfolioApiUtils$val yieldCurveCurrenciesValues = marketData.filter { !it.key.contains("/") }.map { it -&gt; Triple(it.key.split("-")[0], it.key.split("-", limit = 2)[1], it.value) }</ID>
    <ID>MaxLineLength:PortfolioState.kt$PortfolioState$return TransactionBuilder(notary).withItems(StateAndContract(copy(), PORTFOLIO_SWAP_PROGRAM_ID), Command(PortfolioSwap.Commands.Agree(), participants.map { it.owningKey }))</ID>
    <ID>MaxLineLength:PrintingInterceptor.kt$PrintingInterceptor$val transitionRecord = TransitionDiagnosticRecord(Instant.now(), fiber.id, previousState, nextState, event, transition, continuation)</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker$log.warnOnce("Found ProgressTracker Step(s) with the same label: ${labels.groupBy { it }.filter { it.value.size &gt; 1 }.map { it.key }}")</ID>
    <ID>MaxLineLength:ProgressTracker.kt$ProgressTracker.Step$private fun definitionLocation(): String</ID>
    <ID>MaxLineLength:Properties.kt$DelegatedProperty$private abstract</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Configuration.Validation.Error&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$override fun valueIn(configuration: Config): List&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$return delegate.schema?.let { schema -&gt; valueDescription(valueIn(configuration).asSequence().map { element -&gt; valueDescription(element, serialiseValue) }.map { it as ConfigObject }.map(ConfigObject::toConfig).map { schema.describe(it, serialiseValue) }.toList(), serialiseValue) } ?: valueDescription(valueIn(configuration), serialiseValue)</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalListProperty$val errors = list.asSequence().map { configObject(key to ConfigValueFactory.fromAnyRef(it)) }.mapIndexed { index, value -&gt; delegate.validate(value.toConfig(), options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }.fold(emptyList&lt;Configuration.Validation.Error&gt;()) { one, other -&gt; one + other }.toSet()</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$override fun &lt;M&gt; mapValid(mappedTypeName: String, convert: (MAPPED) -&gt; Valid&lt;M&gt;): Configuration.Property.Definition.Standard&lt;M&gt;</ID>
    <ID>MaxLineLength:Properties.kt$FunctionalProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$ListMappingProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$errors += valueIn(target).asSequence().map { element -&gt; element as ConfigObject }.map(ConfigObject::toConfig).mapIndexed { index, targetConfig -&gt; schema.validate(targetConfig, options).errors.map { error -&gt; error.withContainingPath(*error.containingPath(index).toTypedArray()) } }.fold(emptyList&lt;Configuration.Validation.Error&gt;()) { one, other -&gt; one + other }.toSet()</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Validated&lt;MAPPED, Configuration.Validation.Error&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$ListProperty$val elementsDescription = valueIn(configuration).asSequence().map { it as ConfigObject }.map(ConfigObject::toConfig).map { delegate.schema.describe(it, serialiseValue) }.toList()</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$internal</ID>
    <ID>MaxLineLength:Properties.kt$LongProperty$return invalid(ConfigException.WrongType(target.origin(), key, Long::class.javaObjectType.simpleName, Double::class.javaObjectType.simpleName).toValidationError(key, typeName))</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue)</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$override fun withDefaultValue(defaultValue: TYPE): Configuration.Property.Definition&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$private</ID>
    <ID>MaxLineLength:Properties.kt$OptionalDelegatedProperty$val missingValueError = errors.asSequence().filterIsInstance&lt;Configuration.Validation.Error.MissingValue&gt;().filter { it.pathAsString == key }.singleOrNull()</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$override fun describe(configuration: Config, serialiseValue: (Any?) -&gt; ConfigValue): ConfigValue?</ID>
    <ID>MaxLineLength:Properties.kt$OptionalPropertyWithDefault$private</ID>
    <ID>MaxLineLength:Properties.kt$RequiredDelegatedProperty$private abstract</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$errors += nestedSchema.validate(nestedConfig, options).errors.map { error -&gt; error.withContainingPathPrefix(*key.split(".").toTypedArray()) }</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$internal open</ID>
    <ID>MaxLineLength:Properties.kt$StandardProperty$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Properties.kt$private val expectedExceptionTypes = setOf(ConfigException.Missing::class, ConfigException.WrongType::class, ConfigException.BadValue::class, ConfigException.BadPath::class, ConfigException.Parse::class)</ID>
    <ID>MaxLineLength:PropertyTest.kt$PropertyTest$val property = Configuration.Property.Definition.long(key).map(::AtomicLong).list().map { list -&gt; list.map(AtomicLong::get).max() }.optional()</ID>
    <ID>MaxLineLength:PropertyValidationTest.kt$PropertyValidationTest$return invalid(Configuration.Validation.Error.BadValue.of("Value must be of format \"host(String):port(Int &gt; 0)\" e.g., \"127.0.0.1:8080\""))</ID>
    <ID>MaxLineLength:ProviderMap.kt$// This registration is needed for reading back EdDSA key from java keystore. // TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider. Security.addProvider(it)</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(BasicHSMKeyManagementService.PersistentKey::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PublicKeyToOwningIdentityCacheImpl.kt$PublicKeyToOwningIdentityCacheImpl$criteriaBuilder.equal(queryRoot.get&lt;String&gt;(PersistentIdentityService.PersistentPublicKeyHashToCertificate::publicKeyHash.name), key.toStringShort())</ID>
    <ID>MaxLineLength:PushedNode.kt$PushedNode$return NodeInstanceRequest(configFile, baseDirectory, copiedNodeConfig, copiedNodeDir, nodeConfig, localImageId, remoteImageName, nodeInstanceName, actualX500, expectedFqName)</ID>
    <ID>MaxLineLength:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$val instrumentClassMethods = clazz.methods.filter { it.name == "instrumentClass" } // TODO this is very brittle, we want to match on a specific instrumentClass() function. We could use the function signature, but that may change between versions anyway. Why is this function overloaded?? instrumentClassMethods[0].insertBefore( "$hookClassName.${::recordScannedClass.name}(className);" )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$AndComposition : AttachmentQueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria$OrComposition : AttachmentQueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(uploaderCondition: ColumnPredicate&lt;String&gt;?, filenameCondition: ColumnPredicate&lt;String&gt;?) : this(uploaderCondition, filenameCondition, null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withContractClassNames(contractClassNamesPredicate: ColumnPredicate&lt;List&lt;ContractClassName&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withSigners(signersPredicate: ColumnPredicate&lt;List&lt;PublicKey&gt;&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$fun withUploadDate(uploadDatePredicate: ColumnPredicate&lt;Instant&gt;): AttachmentsQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$AttachmentQueryCriteria.AttachmentsQueryCriteria$uploadDateCondition: ColumnPredicate&lt;Instant&gt;? = null</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$AndVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$GenericQueryCriteria.ChainableQueryCriteria$OrVisitor&lt;Q : GenericQueryCriteria&lt;Q, P&gt;, in P : BaseQueryCriteriaParser&lt;Q, P, S&gt;, in S : BaseSort&gt; : GenericQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$@CordaSerializable sealed</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$AndComposition : QueryCriteriaAndVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria$OrComposition : QueryCriteriaOrVisitor</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleAssetQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleAssetQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.FungibleStateQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): FungibleStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.LinearStateQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): LinearStateQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultCustomQueryCriteria$fun withRelevancyStatus(relevancyStatus: Vault.RelevancyStatus): VaultCustomQueryCriteria&lt;L&gt;</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$( status: Vault.StateStatus = Vault.StateStatus.UNCONSUMED, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;? = null, stateRefs: List&lt;StateRef&gt;? = null, notary: List&lt;AbstractParty&gt;? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: Vault.RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt; = emptySet(), constraints: Set&lt;Vault.ConstraintInfo&gt; = emptySet(), participants: List&lt;AbstractParty&gt;? = null, externalIds: List&lt;UUID&gt; = emptyList() )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 2) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?) : this(status, contractStateTypes, participants = null)</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 4) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?, notary: List&lt;AbstractParty&gt;?) : this( status, contractStateTypes, stateRefs, notary, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$@DeprecatedConstructorForDeserialization(version = 5) constructor(status: Vault.StateStatus, contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;?, stateRefs: List&lt;StateRef&gt;?, notary: List&lt;AbstractParty&gt;?, softLockingCondition: SoftLockingCondition?) : this( status, contractStateTypes, stateRefs, notary, softLockingCondition, participants = null )</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withConstraintTypes(constraintTypes: Set&lt;Vault.ConstraintInfo.Type&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withContractStateTypes(contractStateTypes: Set&lt;Class&lt;out ContractState&gt;&gt;): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteria.kt$QueryCriteria.VaultQueryCriteria$fun withSoftLockingCondition(softLockingCondition: SoftLockingCondition): VaultQueryCriteria</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;Any, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; `in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.avg(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.max(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.min(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads @Deprecated("Does not support fields from a MappedSuperclass. Use equivalent on a FieldInfo.") fun &lt;R&gt; Field.sum(groupByColumns: List&lt;Field&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.`in`(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$@JvmStatic @JvmOverloads fun &lt;R : Comparable&lt;R&gt;&gt; FieldInfo.notIn(collection: Collection&lt;R&gt;, exactMatch: Boolean = true)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.comparePredicate(operator: BinaryComparisonOperator, value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.greaterThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R : Comparable&lt;R&gt;&gt; KProperty1&lt;O, R?&gt;.lessThanOrEqual(value: R)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;O, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;O, R&gt; KProperty1&lt;O, R?&gt;.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.functionPredicate(predicate: ColumnPredicate&lt;R&gt;, groupByColumns: List&lt;Column&lt;Any, R&gt;&gt;? = null, orderBy: Sort.Direction? = null)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$fun &lt;R&gt; FieldInfo.predicate(predicate: ColumnPredicate&lt;R&gt;)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.AVG), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MAX), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.MIN), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Builder$functionPredicate(ColumnPredicate.AggregateFunction(AggregateFunctionType.SUM), groupByColumns?.map { Column&lt;Any, R&gt;(it) }, orderBy)</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$Column.Companion$when (property) { // This is to ensure that, for a JPA Entity, a field declared in a MappedSuperclass will not cause Hibernate to reject a query referencing it. // TODO remove the cast and access the owner properly after it will be exposed as Kotlin's public API (https://youtrack.jetbrains.com/issue/KT-24170). is CallableReference -&gt; ((property as CallableReference).owner as KClass&lt;*&gt;).javaObjectType else -&gt; property.javaGetter!!.declaringClass }</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$BinaryLogical&lt;O&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:QueryCriteriaUtils.kt$CriteriaExpression$ColumnPredicateExpression&lt;O, C&gt; : CriteriaExpression</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient$FailedToDeserializeReply : RuntimeException</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val id = message.invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$RPCApi.ServerToClient.Companion$val observableId = message.invocationId(OBSERVABLE_ID_FIELD_NAME, OBSERVABLE_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot parse invocation id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$private</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun ClientMessage.invocationId(valueProperty: String, timestampProperty: String): InvocationId?</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun ClientMessage.sessionId(valueProperty: String, timestampProperty: String): SessionId?</ID>
    <ID>MaxLineLength:RPCApi.kt$private fun Trace.mapToExternal(message: ClientMessage)</ID>
    <ID>MaxLineLength:RPCApi.kt$return invocationId(RPC_ID_FIELD_NAME, RPC_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot extract reply id from client message.")</ID>
    <ID>MaxLineLength:RPCApi.kt$return sessionId(RPC_SESSION_ID_FIELD_NAME, RPC_SESSION_ID_TIMESTAMP_FIELD_NAME) ?: throw IllegalStateException("Cannot extract the session id from client message.")</ID>
    <ID>MaxLineLength:RPCClientProxyHandler.kt$RPCClientProxyHandler$throw UnsupportedOperationException("Method $calledMethod was added in RPC protocol version $sinceVersion but the server is running $serverProtocolVersion")</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL$val artemisConfig = createRpcServerArtemisConfig(maxFileSize, maxBufferedBytesPerClient, driverDSL.driverDirectory / serverName, hostAndPort)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RPCDriverDSL.Companion$fun createRpcServerArtemisConfig(maxFileSize: Int, maxBufferedBytesPerClient: Long, baseDirectory: Path, hostAndPort: NetworkHostAndPort): Configuration</ID>
    <ID>MaxLineLength:RPCDriver.kt$RandomRpcUser.Companion$private inline fun &lt;reified T&gt; HashMap&lt;Class&lt;*&gt;, Generator&lt;*&gt;&gt;.add(generator: Generator&lt;T&gt;)</ID>
    <ID>MaxLineLength:RPCDriver.kt$RandomRpcUser.Companion$val handle = RPCClient&lt;RPCOps&gt;(hostAndPort, null, serializationContext = AMQP_RPC_CLIENT_CONTEXT).start(rpcClass, username, password)</ID>
    <ID>MaxLineLength:RPCDriver.kt$SingleUserSecurityManager$override</ID>
    <ID>MaxLineLength:RPCDriver.kt$SingleUserSecurityManager$override fun validateUserAndRole(user: String?, password: String?, roles: MutableSet&lt;Role&gt;?, checkType: CheckType?)</ID>
    <ID>MaxLineLength:RPCHighThroughputObservableTests.kt$RPCHighThroughputObservableTests$val proxy = testProxy() // This tests that the observations are transmitted correctly, also check that server side doesn't try to serialize the whole lot // till client consumed some of the output produced. val observations = proxy.makeObservable() val observationsList = observations.take(4).toBlocking().toIterable().toList() assertEquals(listOf(1, 2, 3, 4), observationsList)</ID>
    <ID>MaxLineLength:RPCOpsWithContext.kt$fun makeRPCOps(getCordaRPCOps: (username: String, credential: String) -&gt; InternalCordaRPCOps, username: String, credential: String): InternalCordaRPCOps</ID>
    <ID>MaxLineLength:RPCOpsWithContext.kt$return Proxy.newProxyInstance(InternalCordaRPCOps::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java)) { _, method, args -&gt; try { method.invoke(cordaRPCOps, *(args ?: arrayOf())) } catch (e: InvocationTargetException) { // Unpack exception. throw e.targetException } } as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:RPCSecurityManagerWithAdditionalUser.kt$RPCSecurityManagerWithAdditionalUser : RPCSecurityManager</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$( ops: RPCOps, rpcServerUsername: String, rpcServerPassword: String, serverLocator: ServerLocator, securityManager: RPCSecurityManager, nodeLegalName: CordaX500Name, rpcConfiguration: RPCServerConfiguration, cacheFactory: NamedCacheFactory )</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$/** * The method name -&gt; InvocationTarget used for servicing the actual call. * NB: The key in this map can either be: * - FQN of the method including interface name for all the interfaces except `CordaRPCOps`; * - For `CordaRPCOps` interface this will be just plain method name. This is done to maintain wire compatibility with previous versions. */ private val methodTable: Map&lt;String, InvocationTarget&gt;</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$consumerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$private</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$producerSession = sessionFactory!!.createSession(rpcServerUsername, rpcServerPassword, false, true, true, false, DEFAULT_ACK_BATCH_SIZE)</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$require(notificationType == CoreNotificationType.BINDING_ADDED.name){"Message contained notification type of $notificationType instead of expected ${CoreNotificationType.BINDING_ADDED.name}"}</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$require(notificationType == CoreNotificationType.BINDING_REMOVED.name){"Message contained notification type of $notificationType instead of expected ${CoreNotificationType.BINDING_REMOVED.name}"}</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$return cacheFactory.buildNamed(Caffeine.newBuilder().removalListener(onObservableRemove).executor(SameThreadExecutor.getExecutor()), "RPCServer_observableSubscription")</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val targetLegalIdentity = message.getStringProperty(RPCApi.RPC_TARGET_LEGAL_IDENTITY)?.let(CordaX500Name.Companion::parse) ?: nodeLegalName</ID>
    <ID>MaxLineLength:RPCServer.kt$RPCServer$val validatedUser = message.getStringProperty(Message.HDR_VALIDATED_USER) ?: throw IllegalArgumentException("Missing validated user from the Artemis message")</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$"Threads have leaked. New threads created: $newThreads (total before: ${threadsBefore.size}, total after: ${threadsAfter.size})"</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val client = startRpcClient&lt;ServerOps&gt;(listOf(NetworkHostAndPort("localhost", 12345), serverAddress, NetworkHostAndPort("localhost", 54321))).getOrThrow()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val client = startRpcClient&lt;ServerOps&gt;(listOf(server1.broker.hostAndPort!!, server2.broker.hostAndPort!!, server3.broker.hostAndPort!!)).getOrThrow()</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val clientConfiguration = CordaRPCClientConfiguration.DEFAULT.copy(connectionRetryInterval = 1.seconds, maxReconnectAttempts = 5)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val clientConfiguration = CordaRPCClientConfiguration.DEFAULT.copy(connectionRetryInterval = 500.millis, maxReconnectAttempts = 1)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection1 = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RPCStabilityTests.kt$RPCStabilityTests$val connection2 = RPCClient&lt;RPCOps&gt;(server.broker.hostAndPort!!).start(RPCOps::class.java, rpcTestUser.username, rpcTestUser.password)</ID>
    <ID>MaxLineLength:RaftNotaryServiceTests.kt$RaftNotaryServiceTests$val builder = DummyContract.generateInitial(Random().nextInt(), defaultNotaryIdentity, bankA.services.myInfo.singleIdentity().ref(0)) .setTimeWindow(bankA.services.clock.instant(), 30.seconds)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLog.kt$RaftTransactionCommitLog$private</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommand = RaftTransactionCommitLog.Commands.CommitTransaction(states, txId, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommandFirst = RaftTransactionCommitLog.Commands.CommitTransaction(states, txIdFirst, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val commitCommandSecond = RaftTransactionCommitLog.Commands.CommitTransaction(states, txIdSecond, requestingPartyName.toString(), requestSignature)</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1)))</ID>
    <ID>MaxLineLength:RaftTransactionCommitLogTests.kt$RaftTransactionCommitLogTests$val stateMachineFactory = { RaftTransactionCommitLog(database, Clock.systemUTC(), { RaftUniquenessProvider.createMap(TestingNamedCacheFactory()) }) }</ID>
    <ID>MaxLineLength:RatesFixFlow.kt$RatesFixFlow$override val progressTracker: ProgressTracker = RatesFixFlow.tracker(fixOf.name)</ID>
    <ID>MaxLineLength:ReactiveArtemisConsumer.kt$MultiplexingReactiveArtemisConsumer$private</ID>
    <ID>MaxLineLength:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$fun multiplex(createSession: () -&gt; ClientSession, queueName: String, filter: String? = null, vararg queueNames: String): ReactiveArtemisConsumer</ID>
    <ID>MaxLineLength:ReceiveFinalityFlowTest.kt$ReceiveFinalityFlowTest$var bob = mockNet.createNode(InternalMockNodeParameters(legalName = BOB_NAME, additionalCordapps = listOf(FINANCE_WORKFLOWS_CORDAPP)))</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveStateAndRefFlow&lt;out T : ContractState&gt; : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow : FlowLogic</ID>
    <ID>MaxLineLength:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$private val statesToRecord: StatesToRecord = StatesToRecord.NONE</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$output(ExampleContract::class.java.typeName, "UPDATED REF DATA", "REF DATA".output&lt;ExampleState&gt;().copy(data = "NEW STUFF!"))</ID>
    <ID>MaxLineLength:ReferenceInputStateTests.kt$ReferenceStateTests$val stateAndRef = StateAndRef(TransactionState(state, CONTRACT_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), StateRef(SecureHash.zeroHash, 0))</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(2, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(3, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$assertEquals(4, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size)</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests$val useRefTx = nodes[1].services.startFlow(WithReferencedStatesFlow { UseRefState(nodeOneIdentity, newRefState.state.data.linearId) }) .resultFuture</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // Now let's find the specific reference state on nodes[1]. val refStateLinearId = newRefState.state.data.linearId val query = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedState.states.single()) println(theReferencedState.statesMetadata.single()) // nodes[0] should also have the same state. val nodeZeroQuery = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(nodeZeroQuery) assertEquals(newRefState, theReferencedStateOnNodeZero.states.single()) // nodes[0] sends the tx that created the reference state to nodes[1]. nodes[0].services.startFlow(Initiator(newRefState)).resultFuture.getOrThrow() // Query again. val theReferencedStateAgain = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedStateAgain.states.single()) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). val allRefStates = nodes[1].services.vaultService.queryBy&lt;LinearState&gt;() // nodes[1] should have two states. The newly created output and the reference state created by nodes[0]. assertEquals(2, allRefStates.states.size) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" in a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // 3. Update the reference state but don't share the update. val updatedRefTx = nodes[0].services.startFlow(UpdateRefState(newRefState)).resultFuture.getOrThrow() // 4. Now report the transactions that created the two reference states to a third party. nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newRefTx)).resultFuture.getOrThrow() nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), updatedRefTx)).resultFuture.getOrThrow() // Check that there are two linear states in the vault (note that one is consumed) assertEquals(2, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) // 5. Report the transaction that uses the consumed reference state nodes[0].services.startFlow(ReportTransactionFlow(nodes[2].info.legalIdentities.first(), newTx)).resultFuture.getOrThrow() // There should be 3 linear states in the vault assertEquals(3, nodes[2].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests${ // 1. Create a state to be used as a reference state. Don't share it. val newRefTx = nodes[0].services.startFlow(CreateRefState()).resultFuture.getOrThrow() val newRefState = newRefTx.tx.outRefsOfType&lt;RefState.State&gt;().single() // 2. Use the "newRefState" in a transaction involving another party (nodes[1]) which creates a new state. They should store the new state and the reference state. val newTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(newTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have two states. The newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(2, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;().states.size) // Now let's find the specific reference state on nodes[1]. val refStateLinearId = newRefState.state.data.linearId val query = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(query) // There should be one result - the reference state. assertEquals(newRefState, theReferencedState.states.single()) // The reference state should not be consumed. assertEquals(Vault.StateStatus.UNCONSUMED, theReferencedState.statesMetadata.single().status) // nodes[0] should also have the same state. val nodeZeroQuery = QueryCriteria.LinearStateQueryCriteria(linearId = listOf(refStateLinearId)) val theReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(nodeZeroQuery) assertEquals(newRefState, theReferencedStateOnNodeZero.states.single()) assertEquals(Vault.StateStatus.UNCONSUMED, theReferencedStateOnNodeZero.statesMetadata.single().status) // 3. Update the reference state but don't share the update. nodes[0].services.startFlow(UpdateRefState(newRefState)).resultFuture.getOrThrow() // 4. Use the evolved state as a reference state. val updatedTx = nodes[0].services.startFlow(UseRefState(nodes[1].info.legalIdentities.first(), newRefState.state.data.linearId)) .resultFuture.getOrThrow() // Wait until node 1 stores the new tx. nodes[1].services.validatedTransactions.trackTransaction(updatedTx.id).getOrThrow() // Check that nodes[1] has finished recording the transaction (and updating the vault.. hopefully!). // nodes[1] should have four states. The originals, plus the newly created output of type "Regular.State" and the reference state created by nodes[0]. assertEquals(4, nodes[1].services.vaultService.queryBy&lt;LinearState&gt;(QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.ALL)).states.size) // Now let's find the original reference state on nodes[1]. val updatedQuery = QueryCriteria.VaultQueryCriteria(stateRefs = listOf(newRefState.ref), status = Vault.StateStatus.ALL) val theOriginalReferencedState = nodes[1].services.vaultService.queryBy&lt;RefState.State&gt;(updatedQuery) // There should be one result - the original reference state. assertEquals(newRefState, theOriginalReferencedState.states.single()) // The reference state should be consumed. assertEquals(Vault.StateStatus.CONSUMED, theOriginalReferencedState.statesMetadata.single().status) // nodes[0] should also have the same state. val theOriginalReferencedStateOnNodeZero = nodes[0].services.vaultService.queryBy&lt;RefState.State&gt;(updatedQuery) assertEquals(newRefState, theOriginalReferencedStateOnNodeZero.states.single()) assertEquals(Vault.StateStatus.CONSUMED, theOriginalReferencedStateOnNodeZero.statesMetadata.single().status) }</ID>
    <ID>MaxLineLength:ReferencedStatesFlowTests.kt$ReferencedStatesFlowTests.RefState.State$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.AnArray$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.AnInterface$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.Parameterised$data</ID>
    <ID>MaxLineLength:RemoteTypeInformation.kt$RemoteTypeInformation.Unparameterised$data</ID>
    <ID>MaxLineLength:RequiresDb.kt$RequiresSql</ID>
    <ID>MaxLineLength:ResolveTransactionsFlow.kt$ResolveTransactionsFlow$val counterpartyPlatformVersion = checkNotNull(serviceHub.networkMapCache.getNodeByLegalIdentity(otherSide.counterparty)?.platformVersion) { "Couldn't retrieve party's ${otherSide.counterparty} platform version from NetworkMapCache" }</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$private</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest$val notaryTx = NotaryChangeTransactionBuilder(inputs, notary, newNotary, notaryNode.services.networkParametersService.defaultHash).build()</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestFlow$@InitiatingFlow open</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestNoRightsVendingFlow$@InitiatingFlow private</ID>
    <ID>MaxLineLength:ResolveTransactionsFlowTest.kt$ResolveTransactionsFlowTest.TestResponseResolveNoRightsFlow$otherSideSession.sendAndReceive&lt;Any&gt;(FetchDataFlow.Request.Data(NonEmptySet.of(noRightsTx.inputs.first().txhash), FetchDataFlow.DataType.TRANSACTION))</ID>
    <ID>MaxLineLength:RetryFlowMockTest.kt$RetryFlowMockTest${ val messagesSent = Collections.synchronizedList(mutableListOf&lt;Message&gt;()) val partyB = nodeB.info.legalIdentities.first() nodeA.setMessagingServiceSpy(object : MessagingServiceSpy() { override fun send(message: Message, target: MessageRecipients, sequenceKey: Any) { messagesSent.add(message) messagingService.send(message, target) } }) val count = 10000 // Lots of iterations so the flow keeps going long enough nodeA.startFlow(KeepSendingFlow(count, partyB)) eventually(duration = Duration.ofSeconds(30), waitBetween = Duration.ofMillis(100)) { assertTrue(messagesSent.isNotEmpty()) assertNotNull(messagesSent.first().senderUUID) } nodeA = mockNet.restartNode(nodeA) // This is a bit racy because restarting the node actually starts it, so we need to make sure there's enough iterations we get here with flow still going. nodeA.setMessagingServiceSpy(object : MessagingServiceSpy() { override fun send(message: Message, target: MessageRecipients, sequenceKey: Any) { messagesSent.add(message) messagingService.send(message, target) } }) // Now short circuit the iterations so the flow finishes soon. KeepSendingFlow.count.set(count - 2) eventually(duration = Duration.ofSeconds(30), waitBetween = Duration.ofMillis(100)) { assertTrue(nodeA.smm.allStateMachines.isEmpty()) } assertNull(messagesSent.last().senderUUID) }</ID>
    <ID>MaxLineLength:RigorousMock.kt$ParticipantDefaultAnswer$"Please specify what should happen when '${invocation.method}' is called, or don't call it. Args: ${Arrays.toString(invocation.arguments)}"</ID>
    <ID>MaxLineLength:RigorousMock.kt$RigorousMockDefaultAnswer$return if (Modifier.isAbstract(invocation.method.modifiers)) ParticipantDefaultAnswer.answerImpl(invocation) else invocation.callRealMethod()</ID>
    <ID>MaxLineLength:RigorousMock.kt$SpectatorDefaultAnswer.MethodInfo$private fun newSpectator(invocation: InvocationOnMock)</ID>
    <ID>MaxLineLength:RigorousMockTest.kt$RigorousMockTest$assertSame&lt;Any&gt;(UndefinedMockBehaviorException::class.java, catchThrowable { m.kotlinDefaultFun() }.javaClass)</ID>
    <ID>MaxLineLength:RolesAdderOnLogin.kt$RolesAdderOnLogin$internal</ID>
    <ID>MaxLineLength:RoundTripObservableSerializerTests.kt$RoundTripObservableSerializerTests$serializationContext</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$internal</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$journalBufferSize_AIO = maxMessageSize</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$journalBufferSize_NIO = maxMessageSize</ID>
    <ID>MaxLineLength:RpcBrokerConfiguration.kt$RpcBrokerConfiguration$return Role(name, send, consume, createDurableQueue, deleteDurableQueue, createNonDurableQueue, deleteNonDurableQueue, manage, browse, createDurableQueue || createNonDurableQueue, deleteDurableQueue || deleteNonDurableQueue)</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { devModeNode.throwExceptionFromFlow() }</ID>
    <ID>MaxLineLength:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest$assertThatThrownBy { scenario(ALICE_NAME, BOB_NAME,true) }</ID>
    <ID>MaxLineLength:RpcExceptions.kt$OutdatedNetworkParameterHashException.Companion$private const val TEMPLATE = "Refused to accept parameters with hash %s because network map advertises update with hash %s. Please check newest version"</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$bankAReconnectingRpc .vaultQueryByWithPagingSpec(Cash.State::class.java, QueryCriteria.VaultQueryCriteria(status = Vault.StateStatus.CONSUMED), PageSpecification(1, 10000))</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$fun startBankA(address: NetworkHostAndPort)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$fun startProxy(addressPair: AddressPair)</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$numReconnects++ // We only expect to see a single reconnectOnError in the stack trace. Otherwise we're in danger of stack overflow recursion maxStackOccurrences.set(max(maxStackOccurrences.get(), currentStackTrace().count { it.methodName == "reconnectOnError" })) Unit</ID>
    <ID>MaxLineLength:RpcReconnectTests.kt$RpcReconnectTests$val criteria = QueryCriteria.VaultCustomQueryCriteria(builder { CashSchemaV1.PersistentCashState::pennies.equal(amount.toLong() * 100) }, status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:SSLHelper.kt$val trustManagers = trustManagerFactory.trustManagers.filterIsInstance(X509ExtendedTrustManager::class.java).map { LoggingTrustManagerWrapper(it) }.toTypedArray()</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$trustManagerFactory.init(initialiseTrustStoreAndEnableCrlChecking(CertificateStore.fromFile(trustStore.path, trustStore.storePassword, trustStore.entryPassword, false), false))</ID>
    <ID>MaxLineLength:SSLHelperTest.kt$SSLHelperTest$val sslHandler = createClientSslHelper(NetworkHostAndPort("localhost", 1234), setOf(legalName), keyManagerFactory, trustManagerFactory)</ID>
    <ID>MaxLineLength:SampleCashSchemaV1.kt$SampleCashSchemaV1 : MappedSchema</ID>
    <ID>MaxLineLength:SampleCashSchemaV1.kt$SampleCashSchemaV1.PersistentCashState$@Table(name = "contract_cash_states_v1", indexes = [Index(name = "ccy_code_idx1", columnList = "ccy_code"), Index(name = "pennies_idx1", columnList = "pennies")])</ID>
    <ID>MaxLineLength:SampleCashSchemaV2.kt$SampleCashSchemaV2.PersistentCashState$@CollectionTable(name = "cash_states_v2_participants", joinColumns = [JoinColumn(name = "output_index", referencedColumnName = "output_index"), JoinColumn(name = "transaction_id", referencedColumnName = "transaction_id")])</ID>
    <ID>MaxLineLength:ScheduledActivityObserver.kt$ScheduledActivityObserver</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val (alice, bob) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow()</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val N = 23 val rpcUser = User("admin", "admin", setOf("ALL")) val (alice, bob) = listOf(ALICE_NAME, BOB_NAME).map { startNode(providedName = it, rpcUsers = listOf(rpcUser)) }.transpose().getOrThrow() val aliceClient = CordaRPCClient(alice.rpcAddress).start(rpcUser.username, rpcUser.password) val bobClient = CordaRPCClient(bob.rpcAddress).start(rpcUser.username, rpcUser.password) val scheduledFor = Instant.now().plusSeconds(10) val initialiseFutures = mutableListOf&lt;CordaFuture&lt;*&gt;&gt;() for (i in 0 until N) { initialiseFutures.add(aliceClient.proxy.startFlow( ::InsertInitialStateFlow, bob.nodeInfo.legalIdentities.first(), defaultNotaryIdentity, i, scheduledFor ).returnValue) initialiseFutures.add(bobClient.proxy.startFlow( ::InsertInitialStateFlow, alice.nodeInfo.legalIdentities.first(), defaultNotaryIdentity, i + 100, scheduledFor ).returnValue) } initialiseFutures.getOrThrowAll() val spendAttemptFutures = mutableListOf&lt;CordaFuture&lt;*&gt;&gt;() for (i in (0 until N).reversed()) { spendAttemptFutures.add(aliceClient.proxy.startFlow(::AnotherFlow, (i).toString()).returnValue) spendAttemptFutures.add(bobClient.proxy.startFlow(::AnotherFlow, (i + 100).toString()).returnValue) } spendAttemptFutures.getOrThrowAll() // TODO: the queries below are not atomic so we need to allow enough time for the scheduler to finish. Would be better to query scheduler. Thread.sleep(20.seconds.toMillis()) val aliceStates = aliceClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed } val aliceSpentStates = aliceClient.proxy.vaultQuery(SpentState::class.java).states val bobStates = bobClient.proxy.vaultQuery(ScheduledState::class.java).states.filter { it.state.data.processed } val bobSpentStates = bobClient.proxy.vaultQuery(SpentState::class.java).states assertEquals(aliceStates.count() + aliceSpentStates.count(), N * 2) assertEquals(bobStates.count() + bobSpentStates.count(), N * 2) assertEquals(aliceSpentStates.count(), bobSpentStates.count())</ID>
    <ID>MaxLineLength:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests.AnotherFlow$val results = serviceHub.vaultService.queryBy&lt;ScheduledState&gt;(QueryCriteria.LinearStateQueryCriteria(externalId = ImmutableList.of(identity)))</ID>
    <ID>MaxLineLength:ScheduledState.kt$ScheduledState$override val linearId: UniqueIdentifier = UniqueIdentifier(externalId = identity)</ID>
    <ID>MaxLineLength:Schema.kt$CompositeType.Companion$return CompositeType(list[0] as String, list[1] as? String, uncheckedCast(list[2]), list[3] as Descriptor, uncheckedCast(list[4]))</ID>
    <ID>MaxLineLength:Schema.kt$Field.Companion$return Field(list[0] as String, list[1] as String, uncheckedCast(list[2]), list[3] as? String, list[4] as? String, list[5] as Boolean, list[6] as Boolean)</ID>
    <ID>MaxLineLength:Schema.kt$RestrictedType.Companion$return RestrictedType(list[0] as String, list[1] as? String, uncheckedCast(list[2]), list[3] as String, list[4] as Descriptor, uncheckedCast(list[5]))</ID>
    <ID>MaxLineLength:Schema.kt$RestrictedType.Companion$return newInstance(listOf(list[0], list[1], list[2], list[3], Descriptor.get(list[4]!!), (list[5] as List&lt;*&gt;).map { Choice.get(it!!) }))</ID>
    <ID>MaxLineLength:Schema.kt$Schema$internal</ID>
    <ID>MaxLineLength:Schema.kt$Schema$return properties.asSequence().map { it.key to it.describe(configuration, serialiseValue) }.filter { it.second != null }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val invalid = properties.groupBy(Configuration.Property.Definition&lt;*&gt;::key).mapValues { entry -&gt; entry.value.size }.filterValues { propertiesForKey -&gt; propertiesForKey &gt; 1 }</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val nestedProperties = (properties + properties.flatMap { it.schema?.properties ?: emptySet() }).asSequence().distinctBy(Configuration.Property.Definition&lt;*&gt;::schema)</ID>
    <ID>MaxLineLength:Schema.kt$Schema$val root = properties.asSequence().map { it.key to ConfigValueFactory.fromAnyRef(it.typeName) }.fold(configObject()) { config, (key, value) -&gt; config.withValue(key, value) }</ID>
    <ID>MaxLineLength:SchemaMigration.kt$DatabaseIncompatibleException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$DatabaseIncompatibleException.Companion$fun errorMessageFor(reason: String): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$MissingMigrationException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$MissingMigrationException.Companion$fun errorMessageFor(mappedSchema: MappedSchema): String</ID>
    <ID>MaxLineLength:SchemaMigration.kt$OutstandingDatabaseChangesException : DatabaseMigrationException</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$ private fun migrateOlderDatabaseToUseLiquibase(existingCheckpoints: Boolean): Boolean</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$( val schemas: Set&lt;MappedSchema&gt;, val dataSource: DataSource, private val databaseConfig: DatabaseConfig, cordappLoader: CordappLoader? = null, private val currentDirectory: Path?, // This parameter is used by the vault state migration to establish what the node's legal identity is when setting up // its copy of the identity service. It is passed through using a system property. When multiple identity support is added, this will need // reworking so that multiple identities can be passed to the migration. private val ourName: CordaX500Name? = null, // This parameter forces an error to be thrown if there are missing migrations. When using H2, Hibernate will automatically create schemas where they are // missing, so no need to throw unless you're specifically testing whether all the migrations are present. private val forceThrowOnMissingMigration: Boolean = false)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CashSchemaV1" || mappedSchema::class.qualifiedName == "net.corda.finance.schemas.CommercialPaperSchemaV1") &amp;&amp; mappedSchema.migrationResource == null -&gt; null</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$(run &amp;&amp; !check) &amp;&amp; (unRunChanges.isNotEmpty() &amp;&amp; existingCheckpoints!!) -&gt; throw CheckpointsException()</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$System.setProperty(NODE_BASE_DIR_KEY, path)</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$it.execute("SELECT COUNT(*) FROM DATABASECHANGELOG WHERE FILENAME IN ('migration/cash.changelog-init.xml','migration/commercial-paper.changelog-init.xml')")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$private</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$throw DatabaseMigrationException("Could not find Liquibase database migration script $resource. Please ensure the jar file containing it is deployed in the cordapps directory.")</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$val isFinanceAppWithLiquibaseNotMigrated = isFinanceAppWithLiquibase // If Finance App is pre v4.0 then no need to migrate it so no need to check. &amp;&amp; existingDatabase &amp;&amp; (!hasLiquibase // Migrate as other tables. || (hasLiquibase &amp;&amp; it.createStatement().use { noLiquibaseEntryLogForFinanceApp(it) })) // If Liquibase is already in the database check if Finance App schema log is missing.</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration$||</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration.CustomResourceAccessor$private</ID>
    <ID>MaxLineLength:SchemaMigration.kt$SchemaMigration.CustomResourceAccessor$val includeAllFiles = mapOf("databaseChangeLog" to changelogList.filter { it != null }.map { file -&gt; mapOf("include" to mapOf("file" to file)) })</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties(name = "Bar") { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val barConfigSchema = Configuration.Schema.withProperties(name = "Bar") { setOf(string(prop1), long(prop2), nestedObject("prop3", fooConfigSchema).list()) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val fooConfigSchema = Configuration.Schema.withProperties(name = "Foo") { setOf(boolean("prop4"), string("prop5", sensitive = true)) }</ID>
    <ID>MaxLineLength:SchemaTest.kt$SchemaTest$val prop3Value = ConfigValueFactory.fromIterable(listOf(configObject(prop4 to prop4Value, prop5 to prop5Value), configObject(prop4 to prop4Value, prop5 to prop5Value)))</ID>
    <ID>MaxLineLength:SecureHash.kt$SecureHash.Companion$ @JvmStatic fun parse(str: String?): SHA256</ID>
    <ID>MaxLineLength:SelfIssueTest.kt$diffString += "${node.propertyPath}: simulated[${node.canonicalGet(previousState.vaultsSelfIssued)}], actual[${node.canonicalGet(selfIssueVaults)}]\n"</ID>
    <ID>MaxLineLength:SellerFlow.kt$SellerFlow$serviceHub.vaultService.queryBy(CommercialPaper.State::class.java) .states</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow$@Suspendable protected open</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow${ // The first payload will be the transaction data, subsequent payload will be the transaction/attachment/network parameters data. var payload = payload // Depending on who called this flow, the type of the initial payload is different. // The authorisation logic is to maintain a dynamic list of transactions that the caller is authorised to make based on the transactions that were made already. // Each time an authorised transaction is requested, the input transactions are added to the list. // Once a transaction has been requested, it will be removed from the authorised list. This means that it is a protocol violation to request a transaction twice. val authorisedTransactions = when (payload) { is NotarisationPayload -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload.signedTransaction)) is SignedTransaction -&gt; TransactionAuthorisationFilter().addAuthorised(getInputTransactions(payload)) is RetrieveAnyTransactionPayload -&gt; TransactionAuthorisationFilter(acceptAll = true) is List&lt;*&gt; -&gt; TransactionAuthorisationFilter().addAuthorised(payload.flatMap { stateAndRef -&gt; if (stateAndRef is StateAndRef&lt;*&gt;) { getInputTransactions(serviceHub.validatedTransactions.getTransaction(stateAndRef.ref.txhash)!!) + stateAndRef.ref.txhash } else { throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?") } }.toSet()) else -&gt; throw Exception("Unknown payload type: ${payload::class.java} ?") } // This loop will receive [FetchDataFlow.Request] continuously until the `otherSideSession` has all the data they need // to resolve the transaction, a [FetchDataFlow.EndRequest] will be sent from the `otherSideSession` to indicate end of // data request. while (true) { val dataRequest = sendPayloadAndReceiveDataRequest(otherSideSession, payload).unwrap { request -&gt; when (request) { is FetchDataFlow.Request.Data -&gt; { // Security TODO: Check for abnormally large or malformed data requests verifyDataRequest(request) request } FetchDataFlow.Request.End -&gt; return null } } payload = when (dataRequest.dataType) { FetchDataFlow.DataType.TRANSACTION -&gt; dataRequest.hashes.map { txId -&gt; if (!authorisedTransactions.isAuthorised(txId)) { throw FetchDataFlow.IllegalTransactionRequest(txId) } val tx = serviceHub.validatedTransactions.getTransaction(txId) ?: throw FetchDataFlow.HashNotFound(txId) authorisedTransactions.removeAuthorised(tx.id) authorisedTransactions.addAuthorised(getInputTransactions(tx)) tx } FetchDataFlow.DataType.ATTACHMENT -&gt; dataRequest.hashes.map { serviceHub.attachments.openAttachment(it)?.open()?.readFully() ?: throw FetchDataFlow.HashNotFound(it) } FetchDataFlow.DataType.PARAMETERS -&gt; dataRequest.hashes.map { (serviceHub.networkParametersService as NetworkParametersStorage).lookupSigned(it) ?: throw FetchDataFlow.MissingNetworkParameters(it) } } } }</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$DataVendingFlow.TransactionAuthorisationFilter$private</ID>
    <ID>MaxLineLength:SendTransactionFlow.kt$SendStateAndRefFlow$open</ID>
    <ID>MaxLineLength:SerDeserCarpentryTest.kt$SerDeserCarpentryTest$val data = readTestResource().deserialize&lt;AInterface&gt;(context = SerializationFactory.defaultFactory.defaultContext.withLenientCarpenter())</ID>
    <ID>MaxLineLength:SerializationAPI.kt$SerializationFactory$abstract</ID>
    <ID>MaxLineLength:SerializationAPI.kt$context: SerializationContext = serializationFactory.defaultContext</ID>
    <ID>MaxLineLength:SerializationAPI.kt$inline</ID>
    <ID>MaxLineLength:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>MaxLineLength:SerializationFactory.kt$SerializationFactory$abstract</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$assertArrayEquals(data, DeserializationInput(factory).deserialize(compressed, testSerializationContext.withEncodingWhitelist(encodingWhitelist)))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$assertThat(des.deserialize(OpaqueBytes(copy), NonZeroByte::class.java, testSerializationContext.withEncodingWhitelist(encodingWhitelist)).value).isEqualTo(3)</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$private</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$return SerializationFactory.defaultFactory.asCurrent { withCurrentContext(newContext) { serdes(t, factory, factory2, expectedEqual) } }</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests$val crlHolder = builder.build(ContentSignerBuilder.build(Crypto.RSA_SHA256, Crypto.generateKeyPair(Crypto.RSA_SHA256).private, provider))</ID>
    <ID>MaxLineLength:SerializationOutputTests.kt$SerializationOutputTests.GenericSubclass$override fun equals(other: Any?): Boolean</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationContextImpl$override val customSerializers: Set&lt;SerializationCustomSerializer&lt;*, *&gt;&gt; = emptySet()</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$@Throws(NotSerializableException::class) override</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$private</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$return asCurrent { withCurrentContext(context) { schemeFor(byteSequence, context.useCase).first.deserialize(byteSequence, clazz, context) } }</ID>
    <ID>MaxLineLength:SerializationScheme.kt$SerializationFactoryImpl$return asCurrent { withCurrentContext(context) { schemeFor(context.preferredSerializationVersion, context.useCase).first.serialize(obj, context) } }</ID>
    <ID>MaxLineLength:SerializationToken.kt$SingletonSerializationToken$fun registerWithContext(context: SerializeAsTokenContext, toBeTokenized: SerializeAsToken)</ID>
    <ID>MaxLineLength:SerializationTokenTest.kt$SerializationTokenTest$private fun serializeAsTokenContext(toBeTokenized: Any)</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl : SerializeAsTokenContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl$constructor(toBeTokenized: Any, serializer: CheckpointSerializer, context: CheckpointSerializationContext, serviceHub: ServiceHub) : this(serviceHub, { serializer.serialize(toBeTokenized, context.withTokenContext(this)) })</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$CheckpointSerializeAsTokenContextImpl$throw UnsupportedOperationException("Attempt to write token for lazy registered $className. All tokens should be registered during context construction.")</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl$constructor(toBeTokenized: Any, serializationFactory: SerializationFactory, context: SerializationContext, serviceHub: ServiceHub) : this(serviceHub, { serializationFactory.serialize(toBeTokenized, context.withTokenContext(this)) })</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$SerializeAsTokenContextImpl$throw UnsupportedOperationException("Attempt to write token for lazy registered $className. All tokens should be registered during context construction.")</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$fun CheckpointSerializationContext.withTokenContext(serializationContext: SerializeAsTokenContext): CheckpointSerializationContext</ID>
    <ID>MaxLineLength:SerializeAsTokenContextImpl.kt$fun SerializationContext.withTokenContext(serializationContext: SerializeAsTokenContext): SerializationContext</ID>
    <ID>MaxLineLength:SerializeAsTokenSerializer.kt$SerializeAsTokenSerializer$?:</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(filteredTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$createSignature(signedTransaction, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$private</ID>
    <ID>MaxLineLength:ServiceHub.kt$ServiceHub$signInitialTransaction(builder, publicKey, SignatureMetadata(myInfo.platformVersion, Crypto.findSignatureScheme(publicKey).schemeNumberID))</ID>
    <ID>MaxLineLength:ServiceHubInternal.kt$ServiceHubInternal.Companion$vaultService.notifyAll(statesToRecord, recordedTransactions.map { it.coreTransaction }, previouslySeenTxs.map { it.coreTransaction })</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$else -&gt; throw UnsupportedOperationException("Attempting to resolve attachment for index ${stateRef.index} of a ${ctx.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$if (attachment is ContractAttachment &amp;&amp; (forContractClassName ?: transactionState.contract) in attachment.allContracts) { return attachment }</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$return attachments.openAttachment(ctx.upgradedContractAttachmentId) ?: throw AttachmentResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$return ctx.inputs.map { inner(it, transactionState.contract) }.firstOrNull() ?: throw AttachmentResolutionException(stateRef.txhash)</ID>
    <ID>MaxLineLength:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$val transactionState = SerializedStateAndRef(resolveStateRefBinaryComponent(stateRef, this)!!, stateRef).toStateAndRef().state</ID>
    <ID>MaxLineLength:SessionRejectException.kt$SessionRejectException$NotRegistered : SessionRejectException</ID>
    <ID>MaxLineLength:ShellCmdLineOptions.kt$ShellConfigurationFile.ShellConfigFile$sshHostKeyDirectory = extensions?.sshd?.let { if (it.enabled &amp;&amp; it.hostkeypath != null) Paths.get(it.hostkeypath) else null }</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromHashConstraintsTests.kt$SignatureConstraintMigrationFromHashConstraintsTests$@Test fun `HashConstraint cannot be migrated to SignatureConstraint if a HashConstraint is specified for one state and another uses an AutomaticPlaceholderConstraint`()</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$"The constraint from the issuance transaction should be the same constraint used in the consuming transaction for the first state"</ID>
    <ID>MaxLineLength:SignatureConstraintMigrationFromWhitelistConstraintTests.kt$SignatureConstraintMigrationFromWhitelistConstraintTests$@Test fun `auto migration from WhitelistConstraint to SignatureConstraint will only transition states that do not have a constraint specified`()</ID>
    <ID>MaxLineLength:SignedNodeInfo.kt$NodeInfoAndSigned$constructor(nodeInfo: NodeInfo, signer: (PublicKey, SerializedBytes&lt;NodeInfo&gt;) -&gt; DigitalSignature) : this(nodeInfo, nodeInfo.sign(signer))</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$ |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR.</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$"""Transaction $ltx is incorrectly formed. Most likely it was created during version 3 of Corda when the verification logic was more lenient. |Attempted to find local dependency for class: $missingClass, but could not find one. |If you wish to verify this transaction, please contact the originator of the transaction and install the provided missing JAR. |You can install it using the RPC command: `uploadAttachment` without restarting the node. |"""</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$?:</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$@Throws(SignatureException::class, AttachmentResolutionException::class, TransactionResolutionException::class, TransactionVerificationException::class)</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$SignaturesMissingException : NamedByHashSignatureExceptionCordaThrowable</ID>
    <ID>MaxLineLength:SignedTransaction.kt$SignedTransaction$throw TransactionVerificationException.TransactionNetworkParameterOrderingException(id, entry.value.first(), txNetworkParameters, params)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$ @Suspendable private fun agreeValuation(portfolio: Portfolio, asOf: LocalDate, valuer: Party): PortfolioValuation</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val PVs = OGTrades.map { it.info.id.get().value to pricer.presentValue(it.product, combinedRatesProvider).toCordaCompatible() }.toMap()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val margin = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, sensitivities.first, sensitivities.second)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val portfolio = serviceHub.vaultService.queryBy&lt;IRSState&gt;(VaultQueryCriteria(stateRefs = stateRef.state.data.portfolio)).states.toPortfolio()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Receiver$val valuer = serviceHub.identityService.wellKnownPartyFromAnonymous(stateRef.state.data.valuer) ?: throw IllegalStateException("Unknown valuer party ${stateRef.state.data.valuer}")</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$notary = serviceHub.networkMapCache.notaryIdentities.first()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val PVs = OGTrades.map { it.info.id.get().value to pricer.presentValue(it.product, combinedRatesProvider).toCordaCompatible() }.toMap()</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester$val margin = BimmAnalysisUtils.computeMargin(combinedRatesProvider, normalizer, calculatorTotal, sensitivities.first, sensitivities.second)</ID>
    <ID>MaxLineLength:SimmFlow.kt$SimmFlow.Requester.StateRevisionFlowRequester$private</ID>
    <ID>MaxLineLength:SimmRevaluation.kt$SimmRevaluation.Initiator$val stateAndRef = serviceHub.vaultService.queryBy&lt;PortfolioState&gt;(VaultQueryCriteria(stateRefs = listOf(curStateRef))).states.single()</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$cordappsForAllNodes = listOf(findCordapp("net.corda.vega.flows"), findCordapp("net.corda.vega.contracts"), findCordapp("net.corda.confidential")) + FINANCE_CORDAPPS</ID>
    <ID>MaxLineLength:SimmValuationTest.kt$SimmValuationTest$startNodesInProcess = false</ID>
    <ID>MaxLineLength:SimpleNotaryService.kt$SimpleNotaryService : SinglePartyNotaryService</ID>
    <ID>MaxLineLength:SinglePartyNotaryService.kt$SinglePartyNotaryService$val signableData = SignableData(txId, SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(notaryIdentityKey).schemeNumberID))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ #See https://docs.corda.net/head/testing.html#running-tests-in-intellij - 'Fiber classes not instrumented' for more details.</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$DataFeed(flows.values.map { it.fiber.logic }, changesPublisher.bufferUntilSubscribed().wrapWithDatabaseTransaction(database))</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$errorAndTerminate("Caught unrecoverable error from flow. Forcibly terminating the JVM, this might leave resources open, and most likely will.", throwable)</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$logger.debug { "Ignoring request to set time-out on timed flow $flowId to $timeoutSeconds seconds which is shorter than default of ${serviceHub.configuration.flowTimeout.timeout.seconds} seconds." }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$require(lastState.pendingDeduplicationHandlers.isEmpty()) { "Flow cannot be removed until all pending deduplications have completed" }</ID>
    <ID>MaxLineLength:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$val flowCorDappVersion = createSubFlowVersion(serviceHub.cordappProvider.getCordappForFlow(flowLogic), serviceHub.myInfo.platformVersion)</ID>
    <ID>MaxLineLength:SingletonSerializer.kt$SingletonSerializer$internal val typeNotation: TypeNotation = RestrictedType(type.typeName, "Singleton", generateProvides(), "boolean", Descriptor(typeDescriptor), emptyList())</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$ListPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override fun withDefaultValue(defaultValue: TYPE): PropertyDelegate&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$OptionalWithDefaultPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun &lt;ENUM : Enum&lt;ENUM&gt;&gt; enum(key: String?, prefix: String?, enumClass: KClass&lt;ENUM&gt;, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun boolean(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Boolean&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun double(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Double&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun duration(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Duration&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun float(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Float&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun int(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Int&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun long(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;Long&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun nestedObject(schema: Configuration.Schema?, key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;ConfigObject&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Companion$internal fun string(key: String?, prefix: String?, sensitive: Boolean, addProperty: (Configuration.Property.Definition&lt;*&gt;) -&gt; Unit): Standard&lt;String&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Optional$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Optional&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Required$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Required&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.RequiredList$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.RequiredList&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Single$operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Single&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$fun &lt;MAPPED&gt; map(mappedTypeName: String, convert: (TYPE) -&gt; MAPPED): Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegate.Standard$override operator fun provideDelegate(thisRef: Any?, property: KProperty&lt;*&gt;): ReadOnlyProperty&lt;Any?, Configuration.Property.Definition.Standard&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun &lt;MAPPED&gt; mapValid(mappedTypeName: String, convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun list(): PropertyDelegate.RequiredList&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$PropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override fun optional(): PropertyDelegate.Optional&lt;TYPE&gt;</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$override operator</ID>
    <ID>MaxLineLength:Specification.kt$RequiredPropertyDelegateImpl$private</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:${principalAddressValue.port}", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:-10", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:SpecificationTest.kt$SpecificationTest.RpcSettingsSpec$override fun parseValid(configuration: Config)</ID>
    <ID>MaxLineLength:SslConfiguration.kt$MutualSslOptions : MutualSslConfiguration</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$SelfIssueCommand(IssueAndPaymentRequest(Amount(100000, USD), OpaqueBytes.of(0), issuer.mainIdentity, notaryIdentity, anonymous = true), issuer)</ID>
    <ID>MaxLineLength:StabilityTest.kt$StabilityTest$simpleNodes.flatMap { payer -&gt; simpleNodes.map { payer to it } } .filter { it.first != it.second } .map { (payer, payee) -&gt; CrossCashCommand(PaymentRequest(Amount(1, USD), payee.mainIdentity, anonymous = true), payer) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$ fun sessionInitErrored(sessionMessage: InitialSessionMessage, sender: Party, event: ExternalEvent.ExternalMessageEvent, error: Throwable)</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$flowMessaging.sendSessionMessage(sender, replyError, SenderDeduplicationId(DeduplicationId.createRandom(secureRandom), ourSenderUUID))</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$log.info("Flow error discharged from hospital (delay ${backOff.seconds}s) by ${report.by} (error was ${report.error.message})")</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$private</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val diagnoses: Map&lt;Diagnosis, List&lt;Staff&gt;&gt; = staff.groupBy { it.consult(flowFiber, currentState, error, medicalHistory) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val record = sessionMessage.run { MedicalRecord.SessionInit(id, time, outcome, initiatorFlowClassName, flowVersion, appName, sender, error) }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital$val snapshot = (flowPatients.values.flatMap { it.records } + treatableSessionInits.values.map { it.publicRecord }).sortedBy { it.time }</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DeadlockNurse$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DoctorTimeout$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.DuplicateInsertSpecialist$override</ID>
    <ID>MaxLineLength:StaffedFlowHospital.kt$StaffedFlowHospital.FinalityDoctor$override</ID>
    <ID>MaxLineLength:StandaloneShell.kt$StandaloneShell$Ansi.ansi().fgBrightRed().a( """ ______ __""").newline().a( """ / ____/ _________/ /___ _""").newline().a( """ / / __ / ___/ __ / __ `/ """).newline().fgBrightRed().a( """/ /___ /_/ / / / /_/ / /_/ /""").newline().fgBrightRed().a( """\____/ /_/ \__,_/\__,_/""").reset().fgBrightDefault().bold() .newline()</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun &lt;RESULT&gt; badValue(message: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal fun toNetworkHostAndPort(rawValue: String)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$internal inline fun &lt;reified RESULT, reified ERROR : Exception&gt; attempt(action: () -&gt; RESULT)</ID>
    <ID>MaxLineLength:StandardConfigValueParsers.kt$private fun Config.toProperties()</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendExisting(existingSessionState.peerParty, existingMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendInitial(existingSessionState.destination, initialMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$actions.add(Action.SendInitial(sessionState.destination, initialMessage, SenderDeduplicationId(deduplicationId, startingState.senderUUID)))</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$private</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val initialMessage = createInitialSessionMessage(existingSessionState.initiatingSubFlow, sourceSessionId, existingSessionState.additionalEntropy, message)</ID>
    <ID>MaxLineLength:StartedFlowTransition.kt$StartedFlowTransition$val initialMessage = createInitialSessionMessage(sessionState.initiatingSubFlow, sourceSessionId, sessionState.additionalEntropy, null)</ID>
    <ID>MaxLineLength:StateMachineState.kt$StateMachineState</ID>
    <ID>MaxLineLength:StateRevisionFlow.kt$StateRevisionFlow.Requester$updatedData: T</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligations(): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligationsOrNull(): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;?</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun &lt;P : Any&gt; Iterable&lt;ContractState&gt;.sumObligationsOrZero(issuanceDef: Issued&lt;Obligation.Terms&lt;P&gt;&gt;): Amount&lt;Issued&lt;Obligation.Terms&lt;P&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:StateSummingUtilities.kt$ fun Iterable&lt;ContractState&gt;.sumCashBy(owner: AbstractParty): Amount&lt;Issued&lt;Currency&gt;&gt;</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$MissingParameter : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$ReflectionDataMissing : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$TooManyParameters : UnparseableCallException</ID>
    <ID>MaxLineLength:StringToMethodCallParser.kt$StringToMethodCallParser.UnparseableCallException$open</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$"twoStrings a: Some words, b: ' and some words, like, Kirk, would, speak'" to "Some words and some words, like, Kirk, would, speak"</ID>
    <ID>MaxLineLength:StringToMethodCallParserTest.kt$StringToMethodCallParserTest$val args: Array&lt;Any?&gt; = parser.parseArguments(clazz.name, names.zip(ctor.parameterTypes), "someWord: Blah blah blah, aDifferentThing: 12")</ID>
    <ID>MaxLineLength:Structures.kt$CommandWithParties$@Deprecated("Should not be used in contract verification code as it is non-deterministic, will be disabled for some future target platform version onwards and will take effect only for CorDapps targeting those versions.")</ID>
    <ID>MaxLineLength:Structures.kt$UpgradedContractWithLegacyConstraint&lt;in OldState : ContractState, out NewState : ContractState&gt; : UpgradedContract</ID>
    <ID>MaxLineLength:Structures.kt$return mapNotNull { if (it.state.data is T) StateAndRef(TransactionState(it.state.data, it.state.contract, it.state.notary), it.ref) else null }</ID>
    <ID>MaxLineLength:SubFlow.kt$SubFlow.Inlined$data</ID>
    <ID>MaxLineLength:SwapData.kt$FixedLeg$data</ID>
    <ID>MaxLineLength:SwapData.kt$FloatingLeg$data</ID>
    <ID>MaxLineLength:SwapData.kt$SwapData$return getSwapConvention(convention).createTrade(startDate, Tenor.TENOR_4Y, buySell, notional.toDouble(), fixedRate.toDouble(), ReferenceData.standard()) .toBuilder() .info(tradeInfo) .build()</ID>
    <ID>MaxLineLength:SwapDataModel.kt$SwapDataModel$Pair("swap", id)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$@Deprecated("It is unsafe to use this constructor as it requires nodes to automatically vend anonymous identities without first " + "checking if they should. Instead, use the constructor that takes in an existing FlowSession.") constructor(otherParty: Party, @Suppress("UNUSED_PARAMETER") revocationEnabled: Boolean, progressTracker: ProgressTracker) : this(null, otherParty, progressTracker)</ID>
    <ID>MaxLineLength:SwapIdentitiesFlow.kt$SwapIdentitiesFlow$validateAndRegisterIdentity(serviceHub, session.counterparty, theirIdentWithSig.identity.deserialize(), theirIdentWithSig.signature)</ID>
    <ID>MaxLineLength:SwapIdentitiesHandler.kt$SwapIdentitiesHandler$logger.warnOnce("Insecure API to swap anonymous identities was used by ${otherSide.counterparty} (${otherSide.getCounterpartyFlowInfo()})")</ID>
    <ID>MaxLineLength:TLSAuthenticationTests.kt$TLSAuthenticationTests$serverParams.needClientAuth = true</ID>
    <ID>MaxLineLength:TestCommonUtils.kt$inline fun &lt;reified TYPE : Throwable&gt; AbstractThrowableAssert&lt;*, *&gt;.isInstanceOf(): AbstractThrowableAssert&lt;*, *&gt;</ID>
    <ID>MaxLineLength:TestConstants.kt$ fun dummyCommand(vararg signers: PublicKey = arrayOf(generateKeyPair().public))</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl : TestCordappInternal</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$0</ID>
    <ID>MaxLineLength:TestCordappImpl.kt$TestCordappImpl$else -&gt; throw IllegalArgumentException("There is more than one CorDapp containing the package $scanPackage on the classpath " + "$jars. Specify a package name which is unique to the CorDapp.")</ID>
    <ID>MaxLineLength:TestCordappInternal.kt$TestCordappInternal : TestCordapp</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage, attachmentId, signers))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$attachment((services.cordappProvider as MockCordappProvider).addMockCordapp(contractClassName, services.attachments as MockAttachmentStorage, attachmentId, signers, jarManifestAttributes))</ID>
    <ID>MaxLineLength:TestDSL.kt$TestTransactionDSLInterpreter$override</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun afterClass(teardownSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestDatabaseContext.kt$TestDatabaseContext$ fun beforeClass(setupSql: List&lt;String&gt;)</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder</ID>
    <ID>MaxLineLength:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$fun addServiceIdentity(name: CordaX500Name, nodeKeyPair: KeyPair = Crypto.generateKeyPair(X509Utilities.DEFAULT_TLS_SIGNATURE_SCHEME)): Pair&lt;PartyAndCertificate, PrivateKey&gt;</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory : BindableNamedCacheFactorySingletonSerializeAsToken</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override fun bindWithConfig(nodeConfiguration: NodeConfiguration): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:TestingNamedCacheFactory.kt$TestingNamedCacheFactory$override fun bindWithMetrics(metricRegistry: MetricRegistry): BindableNamedCacheFactory</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy : InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy$internal</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.Companion$return Proxy.newProxyInstance(delegate::class.java.classLoader, arrayOf(InternalCordaRPCOps::class.java), handler) as InternalCordaRPCOps</ID>
    <ID>MaxLineLength:ThreadContextAdjustingRpcOpsProxy.kt$ThreadContextAdjustingRpcOpsProxy.ThreadContextAdjustingInvocationHandler$private</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer : Proxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer$override fun fromProxy(proxy: StackTraceElementProxy): StackTraceElement</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$StackTraceElementSerializer$override fun toProxy(obj: StackTraceElement): StackTraceElementProxy</ID>
    <ID>MaxLineLength:ThrowableSerializer.kt$ThrowableSerializer${ try { // TODO: This will need reworking when we have multiple class loaders val clazz = Class.forName(proxy.exceptionClass, false, factory.classloader) // If it is CordaException or CordaRuntimeException, we can seek any constructor and then set the properties // Otherwise we just make a CordaRuntimeException if (CordaThrowable::class.java.isAssignableFrom(clazz) &amp;&amp; Throwable::class.java.isAssignableFrom(clazz)) { val typeInformation = factory.getTypeInformation(clazz) val constructor = typeInformation.constructor val params = constructor.parameters.map { parameter -&gt; proxy.additionalProperties[parameter.name] ?: proxy.additionalProperties[parameter.name.capitalize()] } val throwable = constructor.observedMethod.newInstance(*params.toTypedArray()) (throwable as CordaThrowable).apply { if (this.javaClass.name != proxy.exceptionClass) this.originalExceptionClassName = proxy.exceptionClass this.setMessage(proxy.message) this.setCause(proxy.cause) this.addSuppressed(proxy.suppressed) } return (throwable as Throwable).apply { this.stackTrace = proxy.stackTrace } } } catch (e: Exception) { logger.warn("Unexpected exception de-serializing throwable: ${proxy.exceptionClass}. Converting to CordaRuntimeException.", e) } // If the criteria are not met or we experience an exception constructing the exception, we fall back to our own unchecked exception. return CordaRuntimeException(proxy.exceptionClass, null, null).apply { this.setMessage(proxy.message) this.setCause(proxy.cause) this.stackTrace = proxy.stackTrace this.addSuppressed(proxy.suppressed) } }</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests$addOutputState(DummyContract.SingleOwnerState(owner = info.singleIdentity()), DummyContract.PROGRAM_ID, AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.Companion$defaultParameters = MockNetworkParameters().withServicePeerAllocationStrategy(InMemoryMessagingNetwork.ServicePeerAllocationStrategy.RoundRobin())</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService$override fun createServiceFlow(otherPartySession: FlowSession): FlowLogic&lt;Void?&gt;</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService$private</ID>
    <ID>MaxLineLength:TimedFlowTests.kt$TimedFlowTests.TestNotaryService.&lt;no name provided&gt;$override</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$val clientKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/bridge_$clientAlgo.jks", "bridgepass", "bridgepass")</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$val serverKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/float_$serverAlgo.jks", "floatpass", "floatpass")</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest.Companion$arrayOf("ec", "ec", CIPHER_SUITES_ALL, false)</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest.Companion$arrayOf("ec", "ec", CIPHER_SUITES_JUST_EC, false)</ID>
    <ID>MaxLineLength:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest.Companion$arrayOf("ec", "ec", CIPHER_SUITES_JUST_RSA, true)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$logger.info("Testing: ServerAlgo: $serverAlgo, ClientAlgo: $clientAlgo, Suites: $cipherSuites, Server protocols: $serverProtocols, Client protocols: $clientProtocols, Should fail: $shouldFail")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val clientKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/bridge_$clientAlgo.jks", "bridgepass", "bridgepass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$val serverKeyStore = CertificateStore.fromResource("net/corda/nodeapi/internal/crypto/keystores/float_$serverAlgo.jks", "floatpass", "floatpass")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$@Parameterized.Parameters(name = "ServerAlgo: {0}, ClientAlgo: {1}, CipherSuites: {2}, Should fail: {3}, ServerProtocols: {4}, ClientProtocols: {5}")</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.BOTH, Companion.TlsProtocols.BOTH)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.BOTH, Companion.TlsProtocols.ONE_2)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.ONE_2, Companion.TlsProtocols.BOTH)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, false, Companion.TlsProtocols.ONE_3, Companion.TlsProtocols.ONE_3)</ID>
    <ID>MaxLineLength:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest.Companion$arrayOf(serverAlgo, clientAlgo, Companion.CipherSuites.CIPHER_SUITES_ALL, true, Companion.TlsProtocols.ONE_3, Companion.TlsProtocols.ONE_2)</ID>
    <ID>MaxLineLength:ToggleField.kt$InheritableThreadLocalToggleField$private val isAGlobalThreadBeingCreated: (Array&lt;StackTraceElement&gt;) -&gt; Boolean</ID>
    <ID>MaxLineLength:ToggleField.kt$ThreadLeakException : RuntimeException</ID>
    <ID>MaxLineLength:ToggleFieldTest.kt$ToggleFieldTest$listOf(SimpleToggleField&lt;String&gt;("simple"), ThreadLocalToggleField&lt;String&gt;("local"), inheritableThreadLocalToggleField())</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$freshErrorTransition(IllegalStateException("Tried to initiate in a flow not annotated with @${InitiatingFlow::class.java.simpleName}"))</ID>
    <ID>MaxLineLength:TopLevelTransition.kt$TopLevelTransition$val newSessions = checkpoint.sessions + (sourceSessionId to SessionState.Uninitiated(event.destination, initiatingSubFlow, sourceSessionId, context.secureRandom.nextLong()))</ID>
    <ID>MaxLineLength:Trace.kt$Trace.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(invocationId: InvocationId = InvocationId.newInstance(), sessionId: SessionId = SessionId(invocationId.value, invocationId.timestamp))</ID>
    <ID>MaxLineLength:Trace.kt$Trace.InvocationId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:Trace.kt$Trace.SessionId.Companion$ @DeleteForDJVM @JvmStatic fun newInstance(value: String = UuidGenerator.next().toString(), timestamp: Instant = Instant.now())</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObjectPropertyDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableListReadOnlyDelegate&lt;M : Any, out T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$ObservableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TrackedDelegate.kt$TrackedDelegate$WritableValueDelegate&lt;M : Any, T&gt; : TrackedDelegate</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$clientBank.runIssuer(amount = 100.DOLLARS, buyerName = nodeA.services.myInfo.singleIdentity().name, sellerName = nodeB.services.myInfo.singleIdentity().name)</ID>
    <ID>MaxLineLength:TraderDemoTest.kt$TraderDemoTest$val buyer2 = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to buyer.p2pAddress.toString())).getOrThrow()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ @Throws(MissingContractAttachments::class) fun toWireTransaction(services: ServicesForResolution): WireTransaction</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun handleContract( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, outputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, explicitContractAttachment: AttachmentId?, services: ServicesForResolution ): Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectAttachmentConstraint( contractClassName: ContractClassName, inputStates: List&lt;TransactionState&lt;ContractState&gt;&gt;?, attachmentToUse: ContractAttachment, services: ServicesForResolution): AttachmentConstraint</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$ private fun selectContractAttachmentsAndOutputStateConstraints( services: ServicesForResolution, @Suppress("UNUSED_PARAMETER") serializationContext: SerializationContext? ): Pair&lt;Collection&lt;SecureHash&gt;, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt;</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"An attachment has been explicitly set for contract $contractClassName in the transaction builder which conflicts with the HashConstraint of a state."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$"Transaction was built with $contractClassName states with multiple HashConstraints. This is illegal, because it makes it impossible to validate with a single version of the contract code."</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$(allContractAttachments + attachments).toSortedSet().toList()</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$@CordaInternal internal</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$if ((attachment as ContractAttachment).isSigned &amp;&amp; (explicitContractAttachment == null || explicitContractAttachment == attachment.id)) { val signatureConstraint = makeSignatureAttachmentConstraint(attachment.signerKeys) require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" } val resolvedOutputStates = outputStates?.map { if (it.constraint in automaticConstraints) { it.copy(constraint = signatureConstraint) } else { it } } return attachment.id to resolvedOutputStates }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$internal</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$is CommandData -&gt; throw IllegalArgumentException("You passed an instance of CommandData, but that lacks the pubkey. You need to wrap it in a Command object first.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$log.warnOnce("Signature constraints not available on network requiring a minimum platform version of 4. Current is: ${services.networkParameters.minimumPlatformVersion}.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$private fun useWhitelistedByZoneAttachmentConstraint(contractClassName: ContractClassName, networkParameters: NetworkParameters)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(automaticConstraintPropagation) { "Contract $contractClassName was marked with @NoConstraintPropagation, which means the constraint of the output states has to be set explicitly." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(defaultOutputConstraint.isSatisfiedBy(constraintAttachment)) { "Selected output constraint: $defaultOutputConstraint not satisfying $selectedAttachmentId" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(explicitAttachmentContracts.isEmpty() || explicitAttachmentContracts.groupBy { (ctr, _) -&gt; ctr }.all { (_, groups) -&gt; groups.size == 1 }) { "Multiple attachments set for the same contract." }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$require(signatureConstraint.isSatisfiedBy(attachment)) { "Selected output constraint: $signatureConstraint not satisfying ${attachment.id}" }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.")</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val (allContractAttachments: Collection&lt;SecureHash&gt;, resolvedOutputs: List&lt;TransactionState&lt;ContractState&gt;&gt;) = selectContractAttachmentsAndOutputStateConstraints(services, serializationContext)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val attachments: Collection&lt;AttachmentId&gt; = contractAttachmentsAndResolvedOutputStates.map { it.first } + refStateContractAttachments</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val automaticConstraintPropagation = contractClassName.contractHasAutomaticConstraintPropagation(inputsAndOutputs.first().data::class.java.classLoader)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val constraintAttachment = AttachmentWithContext(attachmentToUse, contractClassName, services.networkParameters.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val contractAttachmentsAndResolvedOutputStates: List&lt;Pair&lt;AttachmentId, List&lt;TransactionState&lt;ContractState&gt;&gt;?&gt;&gt; = allContracts.toSet() .map { ctr -&gt; handleContract(ctr, inputContractGroups[ctr], outputContractGroups[ctr], explicitAttachmentContractsMap[ctr], services) }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val referenceStateGroups: Map&lt;ContractClassName, List&lt;TransactionState&lt;ContractState&gt;&gt;&gt; = referencesWithTransactionState.groupBy { it.contract }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$val resolvedOutputStatesInTheOriginalOrder: List&lt;TransactionState&lt;ContractState&gt;&gt; = outputStates().map { os -&gt; resolvedStates.find { rs -&gt; rs.data == os.data &amp;&amp; rs.encumbrance == os.encumbrance }!! }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder$when { // Sanity check. constraints.isEmpty() -&gt; throw IllegalArgumentException("Cannot transition from no constraints.") // Fail when combining the insecure AlwaysAcceptAttachmentConstraint with something else. constraints.size &gt; 1 &amp;&amp; constraints.any { it is AlwaysAcceptAttachmentConstraint } -&gt; throw IllegalArgumentException("Can't mix the AlwaysAcceptAttachmentConstraint with a secure constraint in the same transaction. This can be used to hide insecure transitions.") // Multiple states with Hash constraints with different hashes. This should not happen as we checked already. constraints.size &gt; 1 &amp;&amp; constraints.all { it is HashAttachmentConstraint } -&gt; throw IllegalArgumentException("Cannot mix HashConstraints with different hashes in the same transaction.") // The HashAttachmentConstraint is the strongest constraint, so it wins when mixed with anything. As long as the actual constraints pass. // Migration from HashAttachmentConstraint to SignatureAttachmentConstraint is handled in [TransactionBuilder.handleContract] // If we have reached this point, then no migration is possible and the existing HashAttachmentConstraint must be used constraints.any { it is HashAttachmentConstraint } -&gt; constraints.find { it is HashAttachmentConstraint }!! // TODO, we don't currently support mixing signature constraints with different signers. This will change once we introduce third party signers. constraints.count { it is SignatureAttachmentConstraint } &gt; 1 -&gt; throw IllegalArgumentException("Cannot mix SignatureAttachmentConstraints signed by different parties in the same transaction.") // This ensures a smooth migration from a Whitelist Constraint to a Signature Constraint constraints.any { it is WhitelistedByZoneAttachmentConstraint } &amp;&amp; attachmentToUse.isSigned &amp;&amp; services.networkParameters.minimumPlatformVersion &gt;= 4 -&gt; transitionToSignatureConstraint(constraints, attachmentToUse) // This condition is hit when the current node has not installed the latest signed version but has already received states that have been migrated constraints.any { it is SignatureAttachmentConstraint } &amp;&amp; !attachmentToUse.isSigned -&gt; throw IllegalArgumentException("Attempting to create an illegal transaction. Please install the latest signed version for the $attachmentToUse Cordapp.") // When all input states have the same constraint. constraints.size == 1 -&gt; constraints.single() else -&gt; throw IllegalArgumentException("Unexpected constraints $constraints.") }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ // If the constraint on the output state is already set, and is not a valid transition or can't be transitioned, then fail early. inputStates?.forEach { input -&gt; require(outputConstraint.canBeTransitionedFrom(input.constraint, attachmentToUse)) { "Output state constraint $outputConstraint cannot be transitioned from ${input.constraint}" } } require(outputConstraint.isSatisfiedBy(constraintAttachment)) { "Output state constraint check fails. $outputConstraint" } it }</ID>
    <ID>MaxLineLength:TransactionBuilder.kt$TransactionBuilder${ val signatureConstraint = constraints.singleOrNull { it is SignatureAttachmentConstraint } as? SignatureAttachmentConstraint // If there were states transitioned already used in the current transaction use that signature constraint, otherwise create a new one. return when { signatureConstraint != null -&gt; signatureConstraint else -&gt; makeSignatureAttachmentConstraint(attachmentToUse.signerKeys) } }</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$fun attachment(contractClassName: ContractClassName, attachmentId: AttachmentId)</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL$fun attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String,String&gt; = emptyMap())</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSL&lt;out T : TransactionDSLInterpreter&gt; : TransactionDSLInterpreter</ID>
    <ID>MaxLineLength:TransactionDSLInterpreter.kt$TransactionDSLInterpreter$ fun _attachment(contractClassName: ContractClassName, attachmentId: AttachmentId, signers: List&lt;PublicKey&gt;, jarManifestAttributes: Map&lt;String,String&gt;)</ID>
    <ID>MaxLineLength:TransactionEncumbranceTests.kt$TransactionEncumbranceTests$output(TEST_TIMELOCK_ID, "state encumbered by state 2 which does not exist", encumbrance = 2, contractState = stateWithNewOwner)</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$private val DUMMY_CASH_ISSUER_IDENTITY = getTestPartyAndCertificate(Party(CordaX500Name("Snake Oil Issuer", "London", "GB"), DUMMY_CASH_ISSUER_KEY.public))</ID>
    <ID>MaxLineLength:TransactionGenerator.kt$TransactionGenerator$val contractAttachment = MockContractAttachment(interpreter.services.cordappProvider.getContractAttachmentID(PROGRAM_ID)!!, PROGRAM_ID)</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$val unvisitedInputTxs: Map&lt;SecureHash, SignedTransaction&gt; = inputsLeadingToUnvisitedTx.map { it.txhash }.toHashSet().mapNotNull { transactions.getTransaction(it) }.associateBy { it.id }</ID>
    <ID>MaxLineLength:TransactionGraphSearch.kt$TransactionGraphSearch$val unvisitedInputTxsWithInputIndex: Iterable&lt;Pair&lt;SignedTransaction, Int&gt;&gt; = inputsLeadingToUnvisitedTx.filter { it.txhash in unvisitedInputTxs.keys }.map { Pair(unvisitedInputTxs[it.txhash]!!, it.index) }</ID>
    <ID>MaxLineLength:TransactionGraphSearchTests.kt$TransactionGraphSearchTests$val search = TransactionGraphSearch(storage, listOf(storage.inputTx.tx), TransactionGraphSearch.Query(DummyContract.Commands.Create::class.java))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$inputState = StateAndRef(TransactionState(TestCash.State(depositRef, 100.POUNDS, MEGA_CORP), TEST_CASH_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), fakeStateRef)</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$tx = TransactionBuilder(DUMMY_NOTARY).withItems(inputState, outputState, changeState, Command(TestCash.Commands.Move(), arrayListOf(MEGA_CORP.owningKey)))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val fakeTx = megaCorpServices.signInitialTransaction(TransactionBuilder(DUMMY_NOTARY).withItems(outputState, Command(TestCash.Commands.Issue(), arrayListOf(MEGA_CORP.owningKey))))</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val megaCorpServices = object : MockServices(listOf("net.corda.coretests.serialization"), MEGA_CORP.name, mock(), testNetworkParameters(notaries = listOf(NotaryInfo(DUMMY_NOTARY, true))), MEGA_CORP_KEY) { //override mock implementation with a real one override fun loadContractAttachment(stateRef: StateRef): Attachment = servicesForResolution.loadContractAttachment(stateRef) }</ID>
    <ID>MaxLineLength:TransactionSerializationTests.kt$TransactionSerializationTests$val signatures = listOf(TransactionSignature(ByteArray(1), MEGA_CORP_KEY.public, SignatureMetadata(1, Crypto.findSignatureScheme(MEGA_CORP_KEY.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature : DigitalSignature</ID>
    <ID>MaxLineLength:TransactionSignature.kt$TransactionSignature$ @Throws(InvalidKeyException::class, SignatureException::class) fun verify(txId: SecureHash)</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_CASH_ISSUER_KEY).verifySignaturesExcept(DUMMY_KEY_1.public) }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_1).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_1, ak).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$assertFailsWith&lt;SignedTransaction.SignaturesMissingException&gt; { makeSigned(wtx, DUMMY_KEY_2).verifyRequiredSignatures() }.missing</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$keySigs + DUMMY_NOTARY_KEY.sign(SignableData(wtx.id, SignatureMetadata(1, Crypto.findSignatureScheme(DUMMY_NOTARY_KEY.public).schemeNumberID)))</ID>
    <ID>MaxLineLength:TransactionTests.kt$TransactionTests$val baseOutState = TransactionState(DummyContract.SingleOwnerState(0, ALICE), DummyContract.PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ fun &lt;T : Any&gt; deserialiseComponentGroup(componentGroups: List&lt;ComponentGroup&gt;, clazz: KClass&lt;T&gt;, groupEnum: ComponentGroupEnum, forceDeserialize: Boolean = false, factory: SerializationFactory = SerializationFactory.defaultFactory, context: SerializationContext = factory.defaultContext): List&lt;T&gt;</ID>
    <ID>MaxLineLength:TransactionUtils.kt$ContractUpgradeTransactionBuilder$val components = listOf(inputs, notary, legacyContractAttachmentId, upgradedContractClassName, upgradedContractAttachmentId, networkParametersHash).map { it.serialize() }</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (attachments.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.ATTACHMENTS_GROUP.ordinal, attachments.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.COMMANDS_GROUP.ordinal, commands.map { it.value }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (commands.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.SIGNERS_GROUP.ordinal, commands.map { it.signers }.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (networkParametersHash != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.PARAMETERS_GROUP.ordinal, listOf(networkParametersHash.serialize())))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (references.isNotEmpty()) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.REFERENCES_GROUP.ordinal, references.lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$if (timeWindow != null) componentGroupMap.add(ComponentGroup(ComponentGroupEnum.TIMEWINDOW_GROUP.ordinal, listOf(timeWindow).lazyMapped(serialize)))</ID>
    <ID>MaxLineLength:TransactionUtils.kt$serviceHub.networkParametersService.lookup(networkParametersHash) ?: throw IllegalArgumentException("Transaction for notarisation contains unknown parameters hash: $networkParametersHash")</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val commandDataList: List&lt;CommandData&gt; = deserialiseComponentGroup(componentGroups, CommandData::class, ComponentGroupEnum.COMMANDS_GROUP, forceDeserialize)</ID>
    <ID>MaxLineLength:TransactionUtils.kt$val signersList: List&lt;List&lt;PublicKey&gt;&gt; = uncheckedCast(deserialiseComponentGroup(componentGroups, List::class, ComponentGroupEnum.SIGNERS_GROUP, forceDeserialize))</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionResolutionException$@KeepForDJVM open</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConflictingAttachmentsRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ConstraintPropagationRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ContractCreationError : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$ContractRejection : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$InvalidAttachmentException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$NotaryChangeInWrongTransactionType : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$OverlappingAttachmentsException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$PackageOwnershipException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$SignersMissing : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException$TransactionNetworkParameterOrderingException : TransactionVerificationException</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractCreationError$internal constructor(txId: SecureHash, contractClass: String, cause: Throwable) : this(txId, contractClass, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.ContractRejection$internal constructor(txId: SecureHash, contract: Contract, cause: Throwable) : this(txId, contract.javaClass.name, cause, cause.message ?: "")</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.PackageOwnershipException$"""The attachment JAR: $attachmentHash containing the class: $invalidClassName is not signed by the owner of package $packageName specified in the network parameters. Please check the source of this attachment and if it is malicious contact your zone operator to report this incident. For details see: https://docs.corda.net/network-map.html#network-parameters"""</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$TransactionVerificationException.UntrustedAttachmentsException$"Please follow the operational steps outlined in https://docs.corda.net/cordapp-build-systems.html#cordapp-contract-attachments to learn more and continue."</ID>
    <ID>MaxLineLength:TransactionVerificationException.kt$net.corda.core.contracts.TransactionVerificationException.kt</ID>
    <ID>MaxLineLength:TransactionVerificationRequest.kt$TransactionVerificationRequest$@Suppress("MemberVisibilityCanBePrivate") //TODO the use of deprecated toLedgerTransaction need to be revisited as resolveContractAttachment requires attachments of the transactions which created input states... //TODO ...to check contract version non downgrade rule, curretly dummy Attachment if not fund is used which sets contract version to '1' @CordaSerializable</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun validateStatesAgainstContract()</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$?:</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$contractAttachmentsPerContract .groupBy { it.first } // Group by contract. .filter { (_, attachments) -&gt; attachments.size &gt; 1 }</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (contractWithMultipleAttachments != null) throw TransactionVerificationException.ConflictingAttachmentsRejection(ltx.id, contractWithMultipleAttachments)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (ltx.attachments.size != ltx.attachments.toSet().size) throw TransactionVerificationException.DuplicateAttachmentsRejection(ltx.id, ltx.attachments.groupBy { it }.filterValues { it.size &gt; 1 }.keys.first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$if (result.keys != contractClasses) throw TransactionVerificationException.MissingAttachmentRejection(ltx.id, contractClasses.minus(result.keys).first())</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier$val constraintAttachment = AttachmentWithContext(contractAttachment, contract, ltx.networkParameters!!.whitelistedContractImplementations)</ID>
    <ID>MaxLineLength:TransactionVerifierServiceInternal.kt$Verifier${ // checkNoNotaryChange and checkEncumbrancesValid are called here, and not in the c'tor, as they need access to the "outputs" // list, the contents of which need to be deserialized under the correct classloader. checkNoNotaryChange() checkEncumbrancesValid() // The following checks ensure the integrity of the current transaction and also of the future chain. // See: https://docs.corda.net/head/api-contract-constraints.html // A transaction contains both the data and the code that must be executed to validate the transition of the data. // Transactions can be created by malicious adversaries, who can try to use code that allows them to create transactions that appear valid but are not. // 1. Check that there is one and only one attachment for each relevant contract. val contractAttachmentsByContract = getUniqueContractAttachmentsByContract() // 2. Check that the attachments satisfy the constraints of the states. (The contract verification code is correct.) verifyConstraints(contractAttachmentsByContract) // 3. Check that the actual state constraints are correct. This is necessary because transactions can be built by potentially malicious nodes // who can create output states with a weaker constraint which can be exploited in a future transaction. verifyConstraintsValidity(contractAttachmentsByContract) // 4. Check that the [TransactionState] objects are correctly formed. validateStatesAgainstContract() // 5. Final step is to run the contract code. After the first 4 steps we are now sure that we are running the correct code. verifyContracts() }</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private fun ObservableList&lt;StateAndRef&lt;ContractState&gt;&gt;.getParties()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer$private fun ObservableList&lt;StateAndRef&lt;ContractState&gt;&gt;.toText()</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$copyableLabel(party.map { "${signature.toStringShort()} (${it?.let { PartyNameFormatter.short.format(it.name) } ?: "Anonymous"})" })</ID>
    <ID>MaxLineLength:TransactionViewer.kt$TransactionViewer.ContractStatesView$label</ID>
    <ID>MaxLineLength:TransactionViewer.kt$outputs.mapNotNull { it as? Cash.State } .filter { it.amount.token.issuer.party.owningKey.toKnownParty().value == myIdentity &amp;&amp; it.owner.owningKey.toKnownParty().value != myIdentity }</ID>
    <ID>MaxLineLength:TransactionWithSignatures.kt$TransactionWithSignatures${ val sigKeys = sigs.map { it.by }.toSet() // TODO Problem is that we can get single PublicKey wrapped as CompositeKey in allowedToBeMissing/mustSign // equals on CompositeKey won't catch this case (do we want to single PublicKey be equal to the same key wrapped in CompositeKey with threshold 1?) return requiredSigningKeys.filter { !it.isFulfilledBy(sigKeys) }.toSet() }</ID>
    <ID>MaxLineLength:TutorialFlowAsyncOperationTest.kt$TutorialFlowAsyncOperationTest$driver</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$override</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Acceptor$return Triple(ptx, arrayListOf(deal.participants.single { it is Party &amp;&amp; serviceHub.myInfo.isLegalIdentity(it) }.owningKey), emptyList())</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$@Suspendable protected abstract</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownMe == ourIdentity){"Well known party for handshake identity ${it.secondaryIdentity} does not match ourIdentity"}</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$require(wellKnownOtherParty == otherSideSession.counterparty){"Well known party for handshake identity ${it.primaryIdentity} does not match counterparty"}</ID>
    <ID>MaxLineLength:TwoPartyDealFlow.kt$TwoPartyDealFlow.Secondary$val sessionsForOtherSigners = excludeNotary(groupPublicKeysByWellKnownParty(serviceHub, ptxSignedByOtherSide.getMissingSigners()), ptxSignedByOtherSide).map { initiateFlow(it.key) }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$@Suspendable private</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(assetForSaleIdentity == sellerSession.counterparty){"Well known identity lookup returned identity that does not match counterparty"}</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$require(wellKnownPayToIdentity.party == sellerSession.counterparty) { "Well known identity to pay to must match counterparty identity" }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Buyer$val (tx, cashSigningPubKeys) = CashUtils.generateSpend(serviceHub, ptx, tradeRequest.price, ourIdentityAndCert, tradeRequest.payToIdentity.party)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlow.kt$TwoPartyTradeFlow.Seller.&lt;no name provided&gt;$val states: Iterable&lt;ContractState&gt; = serviceHub.loadStates(stx.tx.inputs.toSet()).map { it.state.data } + stx.tx.outputs.map { it.data }</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$( // Seller Alice sends her seller info to Bob, who wants to check the asset for sale. // He requests, Alice looks up in her DB to send the tx to Bob expect(TxRecord.Get(alicesFakePaper[0].id)), // Seller Alice gets a proposed tx which depends on Bob's two cash txns and her own tx. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)), // Alice notices that Bob's cash txns depend on a third tx she also doesn't know. expect(TxRecord.Get(bobsFakeCash[0].id)), // Bob answers with the transactions that are now all verifiable, as Alice bottomed out. // Bob's transactions are valid, so she commits to the database //expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[0].id]!!)), //TODO investigate missing event after introduction of signature constraints non-downgrade rule expect(TxRecord.Get(bobsFakeCash[0].id)), // Verify expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[2].id]!!)), expect(TxRecord.Get(bobsFakeCash[0].id)), // Verify expect(TxRecord.Add(bobsSignedTxns[bobsFakeCash[1].id]!!)), // Now she verifies the transaction is contract-valid (not signature valid) which means // looking up the states again. expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)), // Alice needs to look up the input states to find out which Notary they point to expect(TxRecord.Get(bobsFakeCash[1].id)), expect(TxRecord.Get(bobsFakeCash[2].id)), expect(TxRecord.Get(alicesFakePaper[0].id)) )</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, cashIssuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, 10, issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$VaultFiller(bobNode.services, dummyNotary, notary, ::Random).fillWithSomeTestCash(2000.DOLLARS, bankNode.services, 3, issuer)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$fillUpForBuyerAndInsertFakeTransactions(false, issuer, AnonymousParty(bob.owningKey), notary, bobNode, bob, notaryNode, bankNode)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "elbonian money 1", notary = notary, contractState = 800.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, "elbonian money 2", notary = notary, contractState = 1000.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$output(Cash.PROGRAM_ID, notary = notary, contractState = 700.DOLLARS.CASH issuedBy issuer ownedBy interimOwner)</ID>
    <ID>MaxLineLength:TypeIdentifier.kt$TypeIdentifier.Parameterised$data</ID>
    <ID>MaxLineLength:TypeParameterUtils.kt$private</ID>
    <ID>MaxLineLength:TypeParameterUtils.kt${ if (declaredClass == actualClass) { return null } if (actualClass.typeParameters.isEmpty()) { return actualClass } // The actual class can never have type variables resolved, due to the JVM's use of type erasure, so let's try and resolve them // Search for declared type in the inheritance hierarchy and then see if that fills in all the variables val implementationChain: List&lt;Type&gt; = findPathToDeclared(actualClass, declaredType)?.toList() ?: throw AMQPNotSerializableException( declaredType, "No inheritance path between actual $actualClass and declared $declaredType.") val start = implementationChain.last() val rest = implementationChain.dropLast(1).drop(1) val resolver = rest.reversed().fold(TypeResolver().where(start, declaredType)) { resolved, chainEntry -&gt; val newResolved = resolved.resolveType(chainEntry) TypeResolver().where(chainEntry, newResolved) } // The end type is a special case as it is a Class, so we need to fake up a ParameterizedType for it to get the TypeResolver to do anything. val endType = actualClass.asParameterizedType() return resolver.resolveType(endType) }</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleContract.State$override fun withNewOwnerAndAmount(newAmount: Amount&lt;Issued&lt;Currency&gt;&gt;, newOwner: AbstractParty): FungibleAsset&lt;Currency&gt;</ID>
    <ID>MaxLineLength:UniqueDummyFungibleContract.kt$UniqueDummyFungibleStateSchema : MappedSchema</ID>
    <ID>MaxLineLength:UniqueDummyLinearContract.kt$UniqueDummyLinearStateSchema : MappedSchema</ID>
    <ID>MaxLineLength:UniqueIdentifier.kt$UniqueIdentifier$@CordaSerializable @KeepForDJVM data</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$PersistentUniquenessProviderFactory$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(NodeNotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$RaftUniquenessProviderFactory$database = configureDatabase(makeTestDataSourceProperties(), DatabaseConfig(), { null }, { null }, NodeSchemaService(extraSchemas = setOf(RaftNotarySchemaV1)))</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val response: UniquenessProvider.Result = uniquenessProvider.commit(inputs, secondTxId, identity, requestSignature, invalidTimeWindow) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, invalidTimeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, invalidTimeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(emptyList(), secondTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result2 = uniquenessProvider.commit(listOf(inputState), secondTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniquenessProviderTests.kt$UniquenessProviderTests$val result3 = uniquenessProvider.commit(emptyList(), firstTxId, identity, requestSignature, timeWindow, references = listOf(referenceState)) .get()</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$Action(arr.name, replaceFixing(tx, arr.condition, fixings, unusedFixings), replaceFixing(tx, arr.arrangement, fixings, unusedFixings))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arr.actions.map { Action(it.name, it.condition, replaceFixing(tx, it.arrangement, fixings, unusedFixings)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, it.condition, replaceNext(it.arrangement, nextReplacement)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Actions -&gt; Actions(arrangement.actions.map { Action(it.name, replaceStartEnd(it.condition, start, end), replaceStartEnd(it.arrangement, start, end)) }.toSet())</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Interest -&gt; uncheckedCast(Interest(replaceStartEnd(p.amount, start, end), p.dayCountConvention, replaceStartEnd(p.interest, start, end), replaceStartEnd(p.start, start, end), replaceStartEnd(p.end, start, end)))</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is Obligation -&gt; Obligation(replaceStartEnd(arrangement.amount, start, end), arrangement.currency, arrangement.from, arrangement.to)</ID>
    <ID>MaxLineLength:UniversalContract.kt$UniversalContract$is PerceivableOperation -&gt; PerceivableOperation(replaceStartEnd(p.left, start, end), p.op, replaceStartEnd(p.right, start, end))</ID>
    <ID>MaxLineLength:UnstartedFlowTransition.kt$UnstartedFlowTransition$SenderDeduplicationId(DeduplicationId.createForNormal(currentState.checkpoint, 0, initiatedState), currentState.senderUUID)</ID>
    <ID>MaxLineLength:Util.kt$arrangement.actions.fold(ImmutableSet.builder&lt;PublicKey&gt;(), { builder, k -&gt; builder.addAll(liablePartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.arrangements.fold(ImmutableSet.builder&lt;Party&gt;(), { builder, k -&gt; builder.addAll(involvedPartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Util.kt$arrangement.arrangements.fold(ImmutableSet.builder&lt;PublicKey&gt;(), { builder, k -&gt; builder.addAll(liablePartiesVisitor(k)) }).build()</ID>
    <ID>MaxLineLength:Utils.kt$fun &lt;TYPE&gt; Configuration.Property.Definition.Single&lt;TYPE&gt;.listOrEmpty(): Configuration.Property.Definition&lt;List&lt;TYPE&gt;&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.RequiredList&lt;TYPE&gt;.mapValid(noinline convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; Configuration.Property.Definition.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): Configuration.Property.Definition.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.map(noinline convert: (List&lt;TYPE&gt;) -&gt; MAPPED): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.RequiredList&lt;TYPE&gt;.mapValid(noinline convert: (List&lt;TYPE&gt;) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Required&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.map(noinline convert: (TYPE) -&gt; MAPPED): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;TYPE, reified MAPPED&gt; PropertyDelegate.Standard&lt;TYPE&gt;.mapValid(noinline convert: (TYPE) -&gt; Valid&lt;MAPPED&gt;): PropertyDelegate.Standard&lt;MAPPED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;reified ENUM : Enum&lt;ENUM&gt;, VALUE : Any&gt; Configuration.Specification&lt;VALUE&gt;.enum(key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;ENUM&gt;</ID>
    <ID>MaxLineLength:Utils.kt$inline fun &lt;reified NESTED : Any&gt; Configuration.Specification&lt;*&gt;.nested(specification: Configuration.Specification&lt;NESTED&gt;, key: String? = null, sensitive: Boolean = false): PropertyDelegate.Standard&lt;NESTED&gt;</ID>
    <ID>MaxLineLength:Utils.kt$internal fun Config.serialize(options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true).setJson(true)): String</ID>
    <ID>MaxLineLength:Utils.kt$internal fun ConfigValue.serialize(options: ConfigRenderOptions = ConfigRenderOptions.concise().setFormatted(true).setJson(true)): String</ID>
    <ID>MaxLineLength:Utils.kt$return results.states.firstOrNull() ?: throw IllegalArgumentException("State (type=${T::class}) corresponding to the reference $ref not found (or is spent).")</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val additionalNodeInfoPollingFrequencyMsec by long().optional().withDefaultValue(Defaults.additionalNodeInfoPollingFrequencyMsec)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val additionalP2PAddresses by string().mapValid(::toNetworkHostAndPort).list().optional().withDefaultValue(Defaults.additionalP2PAddresses)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val certificateChainCheckPolicies by nested(CertChainPolicyConfigSpec).list().optional().withDefaultValue(Defaults.certificateChainCheckPolicies)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val cordappSignerKeyFingerprintBlacklist by string().list().optional().withDefaultValue(Defaults.cordappSignerKeyFingerprintBlacklist)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$private val flowMonitorSuspensionLoggingThresholdMillis by duration().optional().withDefaultValue(Defaults.flowMonitorSuspensionLoggingThresholdMillis)</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$val messagingServerExternal = configuration[messagingServerExternal] ?: Defaults.messagingServerExternal(configuration[messagingServerAddress])</ID>
    <ID>MaxLineLength:V1NodeConfigurationSpec.kt$private fun toError(validationErrorMessage: String): Configuration.Validation.Error</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$internal</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$return cmdLineOptions.parseConfiguration(rawConfig).doIfValid { logRawConfig(rawConfig) }.doOnErrors(::logConfigurationErrors).optional?.let { ExitCodes.SUCCESS } ?: ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli$val rawConfig = cmdLineOptions.rawConfiguration().doOnErrors(cmdLineOptions::logRawConfigurationErrors).optional ?: return ExitCodes.FAILURE</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$internal fun logRawConfig(config: Config)</ID>
    <ID>MaxLineLength:ValidateConfigurationCli.kt$ValidateConfigurationCli.Companion$logger.error(errors.joinToString(System.lineSeparator(), "Error(s) while parsing node configuration:${System.lineSeparator()}") { error -&gt; "\t- ${error.description()}" })</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED&gt; map(convert: (TARGET) -&gt; MAPPED): Validated&lt;MAPPED, ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED&gt; mapValid(convert: (TARGET) -&gt; Validated&lt;MAPPED, ERROR&gt;): Validated&lt;MAPPED, ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun &lt;MAPPED_ERROR&gt; mapErrors(convertError: (ERROR) -&gt; MAPPED_ERROR): Validated&lt;TARGET, MAPPED_ERROR&gt;</ID>
    <ID>MaxLineLength:Validated.kt$Validated$ fun value(exceptionOnErrors: (Set&lt;ERROR&gt;) -&gt; Exception = { errors -&gt; IllegalStateException(errors.joinToString(System.lineSeparator())) }): TARGET</ID>
    <ID>MaxLineLength:Validated.kt$Validated.Companion$ fun &lt;T, E&gt; withResult(target: T, errors: Set&lt;E&gt;): Validated&lt;T, E&gt;</ID>
    <ID>MaxLineLength:ValidatingNotaryFlow.kt$ValidatingNotaryFlow$open</ID>
    <ID>MaxLineLength:ValidatingNotaryServiceTests.kt$ValidatingNotaryServiceTests.&lt;no name provided&gt;$val alteredMessage = InMemoryMessage(message.topic, OpaqueBytes(alteredMessageData.serialize().bytes), message.uniqueMessageId)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ // TODO: need to make all FungibleAsset commands (issue, move, exit) generic fun fillWithSomeTestCommodity(amount: Amount&lt;Commodity&gt;, issuerServices: ServiceHub, issuedBy: PartyAndReference): Vault&lt;CommodityState&gt;</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$ fun generateCommoditiesIssue(tx: TransactionBuilder, amount: Amount&lt;Issued&lt;Commodity&gt;&gt;, owner: AbstractParty, notary: Party)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$cash.generateIssue(issuance, Amount(pennies, Issued(issuedBy, howMuch.token)), owner ?: services.myInfo.singleIdentity(), altNotary)</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$statesToRecord: StatesToRecord = StatesToRecord.ONLY_RELEVANT</ID>
    <ID>MaxLineLength:VaultFiller.kt$VaultFiller$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(issuerKey.public).schemeNumberID)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestRule$(notaryServices.myInfo.legalIdentitiesAndCerts + BOC_IDENTITY + CASH_NOTARY_IDENTITY + MINI_CORP_IDENTITY + MEGA_CORP_IDENTITY)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTests$require(produced.filter { DummyDealContract.State::class.java.isAssignableFrom(it.state.data::class.java) }.size == 10) {}</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$// Beware: do not use `MyContractClass::class.qualifiedName` as this returns a fully qualified name using "dot" notation for enclosed class val MYCONTRACT_ID = "net.corda.node.services.vault.VaultQueryTestsBase\$MyContractClass"</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Suppress("EXPECTED_CONDITION") val pagingSpec = PageSpecification(DEFAULT_PAGE_NUM, @Suppress("INTEGER_OVERFLOW") Integer.MAX_VALUE + 1) // overflow = -2147483648</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator case insensitive NOT IN does not return results containing the same characters as the case insensitive strings`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$@Test fun `logical operator case insensitive NOT_EQUAL does not return results containing the same characters as the case insensitive string`()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$QueryCriteria.TimeInstantType.CONSUMED</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.ASC -&gt; assertThat(allStates.sortedBy { it.state.data.linearNumber }.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.DESC -&gt; assertThat(allStates.sortedByDescending { it.ref.txhash }.sortedByDescending { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$Sort.Direction.DESC -&gt; assertThat(allStates.sortedByDescending { it.state.data.linearNumber }.sortedBy { it.ref.txhash }.sortedBy { it.ref.index }).isEqualTo(allStates)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(constraintResults.states.map { it.state.constraint }).containsAll(listOf(constraintHash, constraintSignature, constraintSignatureCompositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$assertThat(constraintResults4.states.map { it.state.constraint }).containsAll(listOf(constraintSignature, constraintSignatureCompositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$groupByColumns = listOf(SampleCashSchemaV2.PersistentCashState::currency, SampleCashSchemaV2.PersistentCashState::stateRef)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$listOf(100.DOLLARS, 200.DOLLARS, 300.POUNDS, 400.POUNDS, 500.SWISS_FRANCS, 600.SWISS_FRANCS).zip(1..6)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(UUID.randomUUID()))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val alwaysAcceptConstraint = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AlwaysAcceptAttachmentConstraint).states.first().state.constraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val avg = builder { CashSchemaV1.PersistentCashState::pennies.avg(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val ccyIndex = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val compositeKey = CompositeKey.Builder().addKeys(alice.publicKey, bob.publicKey, charlie.publicKey, bankOfCorda.publicKey, bigCorp.publicKey, megaCorp.publicKey, miniCorp.publicKey, cashNotary.publicKey, dummyNotary.publicKey, dummyCashIssuer.publicKey).build()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val constraintSignatureCompositeKey = linearStateSignatureCompositeKey.states.first().state.constraint as SignatureAttachmentConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId1)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaByLockIds = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.SPECIFIED, listOf(lockId1, lockId2)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaMissingLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_AND_SPECIFIED))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val criteriaUnlockedAndByLockId = VaultQueryCriteria(softLockingCondition = SoftLockingCondition(SoftLockingType.UNLOCKED_AND_SPECIFIED, listOf(lockId2)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val database = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), identitySvc::wellKnownPartyFromX500Name, identitySvc::wellKnownPartyFromAnonymous)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val externalIds = listOf(linearState1.states.first().state.data.linearId.externalId!!, linearState3.states.first().state.data.linearId.externalId!!)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val issuedStates = vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER).states.toList()</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(linearId = txns.states.map { it.state.data.linearId }, status = Vault.StateStatus.CONSUMED)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateCriteria = LinearStateQueryCriteria(uuid = linearStates.map { it.state.data.linearId.id }, status = Vault.StateStatus.ALL)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateHash = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint) // defaults to the HashConstraint</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateHash = vaultFiller.fillWithSomeTestLinearStates(1, constraint = AutomaticPlaceholderConstraint) // defaults to the hash constraint.</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateSignature = vaultFiller.fillWithSomeTestLinearStates(1, constraint = SignatureAttachmentConstraint(alice.publicKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val linearStateSignatureCompositeKey = vaultFiller.fillWithSomeTestLinearStates(1, constraint = SignatureAttachmentConstraint(compositeKey))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val maturityIndex = CommercialPaperSchemaV1.PersistentCommercialPaperState::maturity.greaterThanOrEqual(TEST_TX_TIME + 30.days)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val max = builder { CashSchemaV1.PersistentCashState::pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val max = builder { CashSchemaV1.PersistentCashState::pennies.max(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val min = builder { CashSchemaV1.PersistentCashState::pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val min = builder { CashSchemaV1.PersistentCashState::pennies.min(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val results = vaultService.queryBy&lt;DummyLinearContract.State&gt;(criteria, Sort(setOf(Sort.SortColumn(sortAttribute, Sort.Direction.ASC))))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val signatureMetadata = SignatureMetadata(services.myInfo.platformVersion, Crypto.findSignatureScheme(issuerKey.public).schemeNumberID)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val signedStatesExitingTx = services.signInitialTransaction(statesExitingTx).withAdditionalSignature(issuerKey, signatureMetadata)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sorting = Sort(setOf(Sort.SortColumn(SortAttribute.Custom(DummyLinearStateSchemaV1.PersistentDummyLinearState::class.java, "linearString"), Sort.Direction.DESC)))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency)) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val sum = builder { CashSchemaV1.PersistentCashState::pennies.sum(groupByColumns = listOf(CashSchemaV1.PersistentCashState::currency), orderBy = Sort.Direction.DESC) }</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$val utx = TransactionBuilder(notary = notaryServices.myInfo.singleIdentity()).withItems(stateAndContract).withItems(dummyCommand())</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFiller.fillWithSomeTestCommodity(Amount(100, Commodity.getInstance("FCOJ")!!), notaryServices, DUMMY_OBLIGATION_ISSUER.ref(1))</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER, charlie.party, statesToRecord = StatesToRecord.ALL_VISIBLE)</ID>
    <ID>MaxLineLength:VaultQueryTests.kt$VaultQueryTestsBase$vaultFillerCashNotary.fillWithSomeTestCash(100.DOLLARS, notaryServices, 10, DUMMY_CASH_ISSUER, statesToRecord = StatesToRecord.ALL_VISIBLE)</ID>
    <ID>MaxLineLength:VaultRestartTest.kt$VaultRestartTest$val restartedNode = startNode(providedName = DUMMY_BANK_A_NAME, customOverrides = mapOf("p2pAddress" to "localhost:30000")).getOrThrow()</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.PersistentStateRefAndKey$@Embeddable @Immutable data</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultLinearStates$@Table(name = "vault_linear_states", indexes = [Index(name = "external_id_index", columnList = "external_id"), Index(name = "uuid_index", columnList = "uuid")])</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultStates$@Table(name = "vault_states", indexes = [Index(name = "state_status_idx", columnList = "state_status"), Index(name = "lock_id_idx", columnList = "lock_id, state_status")])</ID>
    <ID>MaxLineLength:VaultSchema.kt$VaultSchemaV1.VaultTxnNote$@Table(name = "vault_transaction_notes", indexes = [Index(name = "seq_no_index", columnList = "seq_no"), Index(name = "transaction_id_index", columnList = "transaction_id")])</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.StateMetadata$return StateMetadata(ref, contractStateClassName, recordedTime, consumedTime, status, notary, lockId, lockUpdateTime, relevancyStatus, ConstraintInfo(AlwaysAcceptAttachmentConstraint))</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update$inline</ID>
    <ID>MaxLineLength:VaultService.kt$Vault.Update${ require(rhs.type == type) { "Cannot combine updates of different types" } val combinedConsumed = consumed + (rhs.consumed - produced) // The ordering below matters to preserve ordering of consumed/produced Sets when they are insertion order dependent implementations. val combinedProduced = produced.filter { it !in rhs.consumed }.toSet() + rhs.produced return copy(consumed = combinedConsumed, produced = combinedProduced, references = references + rhs.references) }</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; queryBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification, sorting: Sort): Vault.Page&lt;T&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, paging: PageSpecification, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$VaultService$fun &lt;T : ContractState&gt; trackBy(contractStateType: Class&lt;out T&gt;, criteria: QueryCriteria, sorting: Sort): DataFeed&lt;Vault.Page&lt;T&gt;, Vault.Update&lt;T&gt;&gt;</ID>
    <ID>MaxLineLength:VaultService.kt$inline</ID>
    <ID>MaxLineLength:VaultServiceInternal.kt$VaultServiceInternal$ fun notifyAll(statesToRecord: StatesToRecord, txns: Iterable&lt;CoreTransaction&gt;, previouslySeenTxns: Iterable&lt;CoreTransaction&gt; = emptyList())</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$NodePair$internals.disableDBCloseOnStop() // Otherwise the in-memory database may disappear (taking the checkpoint with it) while we reboot the client.</ID>
    <ID>MaxLineLength:VaultSoftLockManagerTest.kt$VaultSoftLockManagerTest.ClientLogic$return serviceHub.vaultService.queryBy&lt;ContractState&gt;(VaultQueryCriteria(softLockingCondition = SoftLockingCondition(LOCKED_ONLY))).states.map { it.state.data }</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator$logger.debug("Loaded page $pageNumber of ${(numStates - 1 / pageNumber.toLong()) + 1}. Current page has ${result.size} vault states")</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.Companion$effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$effectiveSerializationEnv.serializationFactory</ID>
    <ID>MaxLineLength:VaultStateMigration.kt$VaultStateIterator.VaultPageTask$return listOf(VaultPageTask(database, page.subList(0, pageSize / 2), block), VaultPageTask(database, page.subList(pageSize / 2, pageSize), block))</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$OnLedgerAsset.generateIssue(txBuilder, TransactionState(CommodityState(amount, owner), Obligation.PROGRAM_ID, dummyNotary.party), Obligation.Commands.Issue())</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$cordaDB = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), notaryServices.identityService::wellKnownPartyFromX500Name, notaryServices.identityService::wellKnownPartyFromAnonymous)</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val persistentIDs = certs.map { PersistentIdentityService.PersistentPublicKeyHashToCertificate(it.owningKey.toStringShort(), it.certPath.encoded) }</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest$val persistentName = PersistentIdentityService.PersistentPartyToPublicKeyHash(name.toString(), certs.first().owningKey.toStringShort())</ID>
    <ID>MaxLineLength:VaultStateMigrationTest.kt$VaultStateMigrationTest${ val cashStatesToAdd = 1000 val linearStatesToAdd = 0 val commodityStatesToAdd = 0 val stateMultiplier = 10 cordaDB = configureDatabase(makePersistentDataSourceProperties(), DatabaseConfig(), notaryServices.identityService::wellKnownPartyFromX500Name, notaryServices.identityService::wellKnownPartyFromAnonymous) // Starting the database this way runs the migration under test. This is fine for the unit tests (as the changelog table is ignored), // but when starting an actual node using these databases the migration will be skipped, as it has an entry in the changelog table. // This must therefore be removed. cordaDB.dataSource.connection.createStatement().use { it.execute("DELETE FROM DATABASECHANGELOG WHERE FILENAME IN ('migration/vault-schema.changelog-v9.xml')") } for (i in 1..stateMultiplier) { addCashStates(cashStatesToAdd, BOB) addLinearStates(linearStatesToAdd, listOf(BOB, ALICE)) addCommodityStates(commodityStatesToAdd, BOB) } saveOurKeys(listOf(bob.keyPair)) saveAllIdentities(listOf(BOB_IDENTITY, ALICE_IDENTITY, BOC_IDENTITY, dummyNotary.identity)) cordaDB.close() }</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef0 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef0)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef1 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef1)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef2 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef2)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef3 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef3)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$private val stateAndRef4 = StateAndRef(TransactionState(DummyState(), DUMMY_PROGRAM_ID, DUMMY_NOTARY, constraint = AlwaysAcceptAttachmentConstraint), stateRef4)</ID>
    <ID>MaxLineLength:VaultUpdateTests.kt$VaultUpdateTests$val notaryChangeUpdate = Vault.Update&lt;ContractState&gt;(setOf(stateAndRef2, stateAndRef3), setOf(stateAndRef0, stateAndRef1), type = Vault.UpdateType.NOTARY_CHANGE)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$TransactionBuilder(notary = DUMMY_NOTARY) .addOutputState(DummyLinearContract.State(linearId = linearId, participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$addOutputState(DummyLinearContract.State(linearId = linearId, participants = listOf(freshIdentity)), DUMMY_LINEAR_CONTRACT_PROGRAM_ID)</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$services.validatedTransactions.getTransaction(linearStates.first().ref.txhash)?.apply { notaryServices.recordTransactions(this) }</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest$val criteriaLocked = VaultQueryCriteria(softLockingCondition = QueryCriteria.SoftLockingCondition(QueryCriteria.SoftLockingType.LOCKED_ONLY))</ID>
    <ID>MaxLineLength:VaultWithCashTest.kt$VaultWithCashTest.Companion$val cordappPackages = listOf("net.corda.testing.internal.vault", "net.corda.finance.contracts.asset", CashSchemaV1::class.packageName, "net.corda.core.contracts")</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject("version" to null), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject("version" to versionValue), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("metadata" to configObject(), "node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionExtractorTest.kt$VersionExtractorTest$val rawConfiguration = configObject("configuration" to configObject("node" to configObject("p2pAddress" to "localhost:8080"))).toConfig()</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val addressesValue = configObject("principal" to "${principalAddressValue.host}:${principalAddressValue.port}", "admin" to "${adminAddressValue.host}:${adminAddressValue.port}")</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV1 = configObject("configuration.metadata.version" to 1, "principalHost" to principalAddressValue.host, "principalPort" to principalAddressValue.port, "adminHost" to adminAddressValue.host, "adminPort" to adminAddressValue.port).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest$val configurationV2 = configObject("configuration.metadata.version" to 2, "configuration.value.addresses" to addressesValue).toConfig().also { println(it.serialize()) }</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec$return Validated.invalid(Configuration.Validation.Error.BadValue.of(host, Address::class.java.simpleName, "Value must be of format \"host(String):port(Int &gt; 0)\" e.g., \"127.0.0.1:8080\""))</ID>
    <ID>MaxLineLength:VersionedParsingExampleTest.kt$private fun Configuration.Version.Extractor.parseRequired(config: Config, options: Configuration.Validation.Options = Configuration.Validation.Options.defaults)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry$value?.let { valid(it) } ?: invalid&lt;Configuration.Specification&lt;VALUE&gt;, Configuration.Validation.Error&gt;(Configuration.Validation.Error.UnsupportedVersion.of(version))</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: (Config) -&gt; Valid&lt;Int&gt;, vararg specifications: Pair&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: Configuration.Value.Parser&lt;Int&gt;, specifications: Map&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry.Companion$fun &lt;V&gt; mapping(versionParser: Configuration.Value.Parser&lt;Int&gt;, vararg specifications: Pair&lt;Int, Configuration.Specification&lt;V&gt;&gt;)</ID>
    <ID>MaxLineLength:VersionedSpecificationRegistry.kt$VersionedSpecificationRegistry&lt;VALUE&gt; : </ID>
    <ID>MaxLineLength:VirtualCordapps.kt$VirtualCordapp$info = Cordapp.Info.Default("corda-notary-bft-smart", versionInfo.vendor, versionInfo.releaseVersion, "Open Source (Apache 2)")</ID>
    <ID>MaxLineLength:WebServerPluginRegistry.kt$WebServerPluginRegistry$/** * Map of static serving endpoints to the matching resource directory. All endpoints will be prefixed with "/web" and postfixed with "\*. * Resource directories can be either on disk directories (especially when debugging) in the form "a/b/c". Serving from a JAR can * be specified with: javaClass.getResource("&lt;folder-in-jar&gt;").toExternalForm() */ val staticServeDirs: Map&lt;String, String&gt; get() = emptyMap()</ID>
    <ID>MaxLineLength:WhitelistGenerator.kt$logger.info("Include contracts from $INCLUDE_WHITELIST_FILE_NAME: ${includeContracts.joinToString()} present in JARs: $optionalCordappJars.")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction : TraversableTransaction</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$// This calculates a value that is slightly lower than the actual re-serialized version. But it is stable and does not depend on the classloader. fun componentGroupSize(componentGroup: ComponentGroupEnum): Int</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$ReplaceWith("WireTransaction(val componentGroups: List&lt;ComponentGroup&gt;, override val privacySalt: PrivacySalt)")</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(availableComponentNonces[it.groupIndex]!![internalIndex], internalIt) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$componentGroups.map { Pair(it.groupIndex, it.components.mapIndexed { internalIndex, internalIt -&gt; componentHash(internalIt, privacySalt, it.groupIndex, internalIndex) }) }.toMap()</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$require(remainingTransactionSize &gt; size) { "Transaction exceeded network's maximum transaction size limit : $maxTransactionSize bytes." }</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$return this.componentGroups.firstOrNull { it.groupIndex == componentGroup.ordinal }?.let { cg -&gt; cg.components.sumBy { it.size } + 4 } ?: 0</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction$val resolvedNetworkParameters = resolveParameters(networkParametersHash) ?: throw TransactionResolutionException.UnknownParametersException(id, networkParametersHash!!)</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>MaxLineLength:WireTransaction.kt$WireTransaction.Companion$else -&gt; throw UnsupportedOperationException("Attempting to resolve input ${stateRef.index} of a ${coreTransaction.javaClass} transaction. This is not supported.")</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$SubmitCompletionFlow : FlowLogic</ID>
    <ID>MaxLineLength:WorkflowTransactionBuildTutorial.kt$TradeApprovalContract$"Completed command requires the counterparty as signer" using (command.signers.contains(before.counterparty.owningKey))</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore</ID>
    <ID>MaxLineLength:X509KeyStore.kt$X509KeyStore.Companion$val internal: KeyStore = if (createNew) loadOrCreateKeyStore(keyStoreFile, storePassword) else loadKeyStore(keyStoreFile, storePassword)</ID>
    <ID>MaxLineLength:X509NameConstraintsTest.kt$X509NameConstraintsTest$setPrivateKey(X509Utilities.CORDA_CLIENT_TLS, tlsKeyPair.private, listOf(tlsCert, nodeCaCert, intermediateCa.certificate, rootCa.certificate), keyPassword)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$ fun createCertificateSigningRequest(subject: X500Principal, email: String, publicKey: PublicKey, contentSigner: ContentSigner, certRole: CertRole = CertRole.NODE_CA): PKCS10CertificationRequest</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$JcaX509v3CertificateBuilder(issuer, serial, validityWindow.first, validityWindow.second, subject, subjectPublicKey) .addExtension(Extension.subjectKeyIdentifier, false, BcX509ExtensionUtils().createSubjectKeyIdentifier(subjectPublicKeyInfo)) .addExtension(Extension.basicConstraints, true, BasicConstraints(certificateType.isCA)) .addExtension(Extension.keyUsage, false, certificateType.keyUsage) .addExtension(Extension.extendedKeyUsage, false, keyPurposes) .addExtension(Extension.authorityKeyIdentifier, false, JcaX509ExtensionUtils().createAuthorityKeyIdentifier(issuerPublicKey))</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$fun createCertificateSigningRequest(subject: X500Principal, email: String, keyPair: KeyPair, certRole: CertRole = CertRole.NODE_CA): PKCS10CertificationRequest</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities$val builder = createPartialCertificate(certificateType, issuer, issuerPublicKey, subject, subjectPublicKey, validityWindow, nameConstraints, crlDistPoint, crlIssuer)</ID>
    <ID>MaxLineLength:X509Utilities.kt$X509Utilities${ val distPointName = DistributionPointName(GeneralNames(GeneralName(GeneralName.uniformResourceIdentifier, crlDistPoint))) val crlIssuerGeneralNames = crlIssuer?.let { GeneralNames(GeneralName(crlIssuer)) } // The second argument is flag that allows you to define what reason of certificate revocation is served by this distribution point see [ReasonFlags]. // The idea is that you have different revocation per revocation reason. Since we won't go into such a granularity, we can skip that parameter. // The third argument allows you to specify the name of the CRL issuer, it needs to be consistent with the crl (IssuingDistributionPoint) extension and the idp argument. // If idp == true, set it, if idp == false, leave it null as done here. val distPoint = DistributionPoint(distPointName, null, crlIssuerGeneralNames) builder.addExtension(Extension.cRLDistributionPoints, false, CRLDistPoint(arrayOf(distPoint))) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$childSubject: X500Principal = X500Principal("CN=Test Child Cert,O=R3 Ltd,L=London,C=GB")</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$p2pSslConfig.keyStore.get(createNew = true).also { it.registerDevP2pCertificates(MEGA_CORP.name, rootCa.certificate, intermediateCa, nodeCa) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$signingCertStore.get(createNew = true).also { it.installDevNodeCaCertPath(MEGA_CORP.name, rootCa.certificate, intermediateCa, nodeCa) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val (sslCert) = sslKeyStoreReloaded.query { getCertificateAndKeyPair(X509Utilities.CORDA_CLIENT_TLS, sslKeyStoreReloaded.entryPassword) }</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val caSubjectKeyIdentifier = SubjectKeyIdentifier.getInstance(caCert.toBc().getExtension(Extension.subjectKeyIdentifier).parsedValue)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest$val certCaAuthorityKeyIdentifier = AuthorityKeyIdentifier.getInstance(getExtension(Extension.authorityKeyIdentifier).parsedValue)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$Triple(ECDSA_SECP256K1_SHA256,java.security.interfaces.ECPrivateKey::class.java, org.bouncycastle.jce.interfaces.ECPrivateKey::class.java)</ID>
    <ID>MaxLineLength:X509UtilitiesTest.kt$X509UtilitiesTest.Companion$Triple(ECDSA_SECP256R1_SHA256,java.security.interfaces.ECPrivateKey::class.java, org.bouncycastle.jce.interfaces.ECPrivateKey::class.java)</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$( inputs: List&lt;StateAndRef&lt;ContractState&gt;&gt;, outputs: List&lt;TransactionState&lt;ContractState&gt;&gt;, commands: List&lt;CommandWithParties&lt;CommandData&gt;&gt;, attachments: List&lt;Attachment&gt;, id: SecureHash, notary: Party?, timeWindow: TimeWindow?, privacySalt: PrivacySalt, networkParameters: NetworkParameters, references: List&lt;StateAndRef&lt;ContractState&gt;&gt;, componentGroups: List&lt;ComponentGroup&gt;? = null, serializedInputs: List&lt;SerializedStateAndRef&gt;? = null, serializedReferences: List&lt;SerializedStateAndRef&gt;? = null, isAttachmentTrusted: (Attachment) -&gt; Boolean )</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$fun createContractCreationError(txId: SecureHash, contractClass: String, cause: Throwable)</ID>
    <ID>MaxLineLength:internalAccessTestHelpers.kt$fun createContractRejection(txId: SecureHash, contract: Contract, cause: Throwable)</ID>
    <ID>ModifierOrder:NodeNamedCache.kt$DefaultNamedCacheFactory$open protected</ID>
    <ID>NestedBlockDepth:ANSIProgressRenderer.kt$ANSIProgressRenderer$// Returns number of lines rendered. private fun renderLevel(ansi: Ansi, error: Boolean): Int</ID>
    <ID>NestedBlockDepth:AbstractAggregatedList.kt$AbstractAggregatedList$override fun sourceChanged(c: ListChangeListener.Change&lt;out E&gt;)</ID>
    <ID>NestedBlockDepth:AbstractConcatenatedList.kt$AbstractConcatenatedList$// This is where we handle changes to the *source* list. override fun sourceChanged(change: ListChangeListener.Change&lt;out ObservableList&lt;A&gt;&gt;)</ID>
    <ID>NestedBlockDepth:AbstractNode.kt$AbstractNode$private fun installCordaServices()</ID>
    <ID>NestedBlockDepth:AbstractNode.kt$AbstractNode$private fun registerCordappFlows()</ID>
    <ID>NestedBlockDepth:AllButBlacklisted.kt$AllButBlacklisted$ override fun hasListed(type: Class&lt;*&gt;): Boolean</ID>
    <ID>NestedBlockDepth:Amount.kt$Amount.Companion$ @JvmStatic fun parseCurrency(input: String): Amount&lt;Currency&gt;</ID>
    <ID>NestedBlockDepth:AttachmentDemo.kt$@Suppress("DEPRECATION") // DOCSTART 1 fun recipient(rpc: CordaRPCOps, webPort: Int)</ID>
    <ID>NestedBlockDepth:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$override fun execute(database: Database?)</ID>
    <ID>NestedBlockDepth:AttachmentsClassLoader.kt$AttachmentsClassLoader$private fun checkAttachments(attachments: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:CheckpointAgent.kt$CheckpointAgent.Companion$fun parseArguments(argumentsString: String?)</ID>
    <ID>NestedBlockDepth:CheckpointAgent.kt$CheckpointHook$private fun instrumentClass(clazz: CtClass): CtClass?</ID>
    <ID>NestedBlockDepth:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>NestedBlockDepth:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>NestedBlockDepth:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onConnectionFinal(event: Event)</ID>
    <ID>NestedBlockDepth:ConnectionStateMachine.kt$ConnectionStateMachine$override fun onDelivery(event: Event)</ID>
    <ID>NestedBlockDepth:CordaPersistence.kt$CordaPersistence$private fun &lt;T&gt; inTopLevelTransaction(isolationLevel: TransactionIsolationLevel, recoverableFailureTolerance: Int, recoverAnyNestedSQLException: Boolean, statement: DatabaseTransaction.() -&gt; T): T</ID>
    <ID>NestedBlockDepth:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>NestedBlockDepth:FetchDataFlow.kt$FetchAttachmentsFlow$override fun maybeWriteToDisk(downloaded: List&lt;Attachment&gt;)</ID>
    <ID>NestedBlockDepth:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$override fun parseCriteria(criteria: CommonQueryCriteria): Collection&lt;Predicate&gt;</ID>
    <ID>NestedBlockDepth:InteractiveShell.kt$InteractiveShell$ @JvmStatic fun runFlowByNameFragment(nameFragment: String, inputData: String, output: RenderPrintWriter, rpcOps: CordaRPCOps, ansiProgressRenderer: ANSIProgressRenderer, inputObjectMapper: ObjectMapper = createYamlInputMapper(rpcOps))</ID>
    <ID>NestedBlockDepth:InternalUtils.kt$ inline fun &lt;T&gt; Iterable&lt;T&gt;.noneOrSingle(predicate: (T) -&gt; Boolean): T?</ID>
    <ID>NestedBlockDepth:JarSignatureTestUtils.kt$JarSignatureTestUtils$fun Path.addManifest(fileName: String, vararg entries: Pair&lt;Attributes.Name, String&gt;)</ID>
    <ID>NestedBlockDepth:Main.kt$Node$fun avalancheLoop()</ID>
    <ID>NestedBlockDepth:NetworkBootstrapper.kt$CopyCordapps$protected fun List&lt;Path&gt;.copy(nodeDirs: List&lt;Path&gt;)</ID>
    <ID>NestedBlockDepth:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$ private fun pollServerForCertificates(requestId: String): List&lt;X509Certificate&gt;</ID>
    <ID>NestedBlockDepth:Node.kt$Node$ override fun startDatabase()</ID>
    <ID>NestedBlockDepth:Node.kt$Node$ private fun tryDetectIfNotPublicHost(host: String): String?</ID>
    <ID>NestedBlockDepth:Node.kt$Node$private fun startLocalRpcBroker(securityManager: RPCSecurityManager): BrokerAddresses?</ID>
    <ID>NestedBlockDepth:NodeVaultService.kt$NodeVaultService$private fun recordUpdate(update: Vault.Update&lt;ContractState&gt;): Vault.Update&lt;ContractState&gt;</ID>
    <ID>NestedBlockDepth:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$override fun verifyTransaction(requestPayload: NotarisationPayload)</ID>
    <ID>NestedBlockDepth:ObjectDiffer.kt$ObjectDiffer$fun diff(a: Any?, b: Any?): DiffTree?</ID>
    <ID>NestedBlockDepth:Obligation.kt$Obligation$override fun verify(tx: LedgerTransaction)</ID>
    <ID>NestedBlockDepth:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun openProfile(): List&lt;InstallConfig&gt;?</ID>
    <ID>NestedBlockDepth:ProfileController.kt$ProfileController$ @Throws(IOException::class) fun saveProfile(): Boolean</ID>
    <ID>NestedBlockDepth:QuasarInstrumentationHook.kt$PackageTree$ fun toGlobs(excludeTree: PackageTree): List&lt;Glob&gt;</ID>
    <ID>NestedBlockDepth:RPCClientProxyHandler.kt$RPCClientProxyHandler$// The handler for Artemis messages. private fun artemisMessageHandler(message: ClientMessage)</ID>
    <ID>NestedBlockDepth:ShutdownManager.kt$ShutdownManager$fun shutdown()</ID>
    <ID>NestedBlockDepth:SpringDriver.kt$SpringBootDriverDSL$private fun queryWebserver(handle: NodeHandle, process: Process, checkUrl: String): WebserverHandle</ID>
    <ID>NestedBlockDepth:StartedFlowTransition.kt$StartedFlowTransition$private fun TransitionBuilder.sendToSessionsTransition(sourceSessionIdToMessage: Map&lt;SessionId, SerializedBytes&lt;Any&gt;&gt;)</ID>
    <ID>NestedBlockDepth:StatusTransitions.kt$StatusTransitions$ fun verify(tx: LedgerTransaction)</ID>
    <ID>NestedBlockDepth:ThrowableSerializer.kt$ThrowableSerializer$override fun fromProxy(proxy: ThrowableProxy): Throwable</ID>
    <ID>NestedBlockDepth:TransactionVerifierServiceInternal.kt$Verifier$ private fun verifyConstraintsValidity(contractAttachmentsByContract: Map&lt;ContractClassName, ContractAttachment&gt;)</ID>
    <ID>SpreadOperator:AMQPSerializationScheme.kt$AbstractAMQPSerializationScheme$(*it.whitelist.toTypedArray())</ID>
    <ID>SpreadOperator:AbstractNode.kt$FlowStarterImpl$(logicType, *args)</ID>
    <ID>SpreadOperator:AbstractParty.kt$AbstractParty$(*bytes)</ID>
    <ID>SpreadOperator:AbstractRPCTest.kt$AbstractRPCTest.Companion$(*modes)</ID>
    <ID>SpreadOperator:AssertingTestDatabaseContext.kt$AssertingTestDatabaseContext$(*expectedScripts)</ID>
    <ID>SpreadOperator:AttachmentDemo.kt$(*args)</ID>
    <ID>SpreadOperator:AttachmentsClassLoaderStaticContractTests.kt$AttachmentsClassLoaderStaticContractTests$(*packages.toTypedArray())</ID>
    <ID>SpreadOperator:AuthenticatedRpcOpsProxy.kt$(methodName, *(args.map(Class&lt;*&gt;::getName).toTypedArray()))</ID>
    <ID>SpreadOperator:AuthenticatedRpcOpsProxy.kt$AuthenticatedRpcOpsProxy$(logicType, *args)</ID>
    <ID>SpreadOperator:AzureInstantiator.kt$AzureInstantiator$(*portsToOpen.toIntArray())</ID>
    <ID>SpreadOperator:ByteArrays.kt$OpaqueBytes.Companion$(*b)</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(newNodeCert, INTERMEDIATE_CA.certificate, *nodeKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_CA) }.drop(2).toTypedArray())</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$(newTlsCert, newNodeCert, INTERMEDIATE_CA.certificate, *sslKeyStore.query { getCertificateChain(X509Utilities.CORDA_CLIENT_TLS) }.drop(3).toTypedArray())</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$( server, SIGNATURE_ALGORITHM, INTERMEDIATE_CA.certificate, INTERMEDIATE_CA.keyPair.private, NODE_CRL, false, *revokedNodeCerts.toTypedArray())</ID>
    <ID>SpreadOperator:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests.CrlServlet$( server, SIGNATURE_ALGORITHM, ROOT_CA.certificate, ROOT_CA.keyPair.private, INTEMEDIATE_CRL, false, *revokedIntermediateCerts.toTypedArray())</ID>
    <ID>SpreadOperator:CertificateStore.kt$CertificateStore$(*options)</ID>
    <ID>SpreadOperator:ClassCarpenterTestUtils.kt$AmqpCarpenterBase$(*constructorParams)</ID>
    <ID>SpreadOperator:ClassCarpentingTypeLoaderTests.kt$ClassCarpentingTypeLoaderTests$(*params)</ID>
    <ID>SpreadOperator:CollectSignaturesFlow.kt$CollectSignatureFlow$(*signingKeys)</ID>
    <ID>SpreadOperator:CollectSignaturesFlowTests.kt$CollectSignaturesFlowTests$(*party)</ID>
    <ID>SpreadOperator:CommercialPaperTests.kt$CommercialPaperTestsGeneric$(*allIdentities)</ID>
    <ID>SpreadOperator:CompositeKey.kt$CompositeKey.Builder$(*keys.toTypedArray())</ID>
    <ID>SpreadOperator:ConfigOperatorTests.kt$ConfigOperatorTests$(*config)</ID>
    <ID>SpreadOperator:ConfigOperatorTests.kt$ConfigOperatorTests$(*overrides)</ID>
    <ID>SpreadOperator:ConfigParsingTest.kt$ConfigParsingTest$(*values)</ID>
    <ID>SpreadOperator:ConfigUtilities.kt$(*pairs)</ID>
    <ID>SpreadOperator:Configuration.kt$Configuration.Validation.Error$(*(containingPath.toList() + this.containingPath).toTypedArray())</ID>
    <ID>SpreadOperator:ContractJarTestUtils.kt$ContractJarTestUtils$(jarName, *contractNames.map{ "${it.replace(".", "/")}.class" }.toTypedArray())</ID>
    <ID>SpreadOperator:CordaCliWrapper.kt$(RunLast().useOut(System.out).useAnsi(defaultAnsiMode), DefaultExceptionHandler&lt;List&lt;Any&gt;&gt;().useErr(System.err).useAnsi(defaultAnsiMode).andExit(ExitCodes.FAILURE), *args)</ID>
    <ID>SpreadOperator:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$(logicType, context(), *args)</ID>
    <ID>SpreadOperator:CordaX500Name.kt$CordaX500Name.Companion$(*Locale.getISOCountries(), unspecifiedCountry)</ID>
    <ID>SpreadOperator:CustomCordapp.kt$CustomCordapp$(*classes.map { it.name }.toTypedArray())</ID>
    <ID>SpreadOperator:CustomCordapp.kt$CustomCordapp$(*packages.map { it.replace('.', '/') }.toTypedArray())</ID>
    <ID>SpreadOperator:DemoBench.kt$DemoBench.Companion$(DemoBench::class.java, *args)</ID>
    <ID>SpreadOperator:DevCertificatesTest.kt$DevCertificatesTest$(*oldX509Certificates)</ID>
    <ID>SpreadOperator:DockerInstantiator.kt$DockerInstantiator$(*it.toTypedArray())</ID>
    <ID>SpreadOperator:DummyContract.kt$DummyContract.Companion$( /* INPUTS */ *priors.toTypedArray(), /* COMMAND */ Command(cmd, priorState.owner.owningKey), /* OUTPUT */ StateAndContract(state, PROGRAM_ID) )</ID>
    <ID>SpreadOperator:DummyContract.kt$DummyContract.Companion$(*items)</ID>
    <ID>SpreadOperator:DummyContractV2.kt$DummyContractV2.Companion$( /* INPUTS */ *priors.toTypedArray(), /* COMMAND */ Command(cmd, priorState.owners.map { it.owningKey }), /* OUTPUT */ StateAndContract(state, DummyContractV2.PROGRAM_ID) )</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*fields)</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*fields, cause.staticLocationBasedHash(hashedFields, visited + cause))</ID>
    <ID>SpreadOperator:ExceptionsErrorCodeFunctions.kt$(*hashedFields.invoke(this))</ID>
    <ID>SpreadOperator:Expect.kt$(*Array(number) { expectation(it) })</ID>
    <ID>SpreadOperator:Expect.kt$(*expectations)</ID>
    <ID>SpreadOperator:Explorer.kt$ExplorerController$(explorerPath, *args)</ID>
    <ID>SpreadOperator:FlowFrameworkTests.kt$FlowFrameworkTests$(*expected)</ID>
    <ID>SpreadOperator:FlowFrameworkTripartyTests.kt$FlowFrameworkTripartyTests$(*expected)</ID>
    <ID>SpreadOperator:FlowLogicRefFactoryImpl.kt$FlowLogicRefFactoryImpl$(flowClass, *args)</ID>
    <ID>SpreadOperator:FlowOverrideTests.kt$FlowOverrideTests$(*nodeAClasses.toTypedArray())</ID>
    <ID>SpreadOperator:FlowOverrideTests.kt$FlowOverrideTests$(*nodeBClasses.toTypedArray())</ID>
    <ID>SpreadOperator:FlowTestsUtils.kt$(*allSessions)</ID>
    <ID>SpreadOperator:FlowTestsUtils.kt$(session, *sessions)</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*ourInputStates.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*ourOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*theirInputStates.toTypedArray())</ID>
    <ID>SpreadOperator:FxTransactionBuildTutorial.kt$ForeignExchangeFlow$(*theirOutputState.map { StateAndContract(it, Cash.PROGRAM_ID) }.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*leftPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*leftPredicates.toTypedArray(), *rightPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$AbstractQueryCriteriaParser$(*rightPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateAttachmentQueryCriteriaParser$(*predicateSet.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$(*combinedPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$(*joinPredicates.toTypedArray())</ID>
    <ID>SpreadOperator:IRSDemo.kt$(*args)</ID>
    <ID>SpreadOperator:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$(*commandAndArgs)</ID>
    <ID>SpreadOperator:InteractiveShell.kt$InteractiveShell$(clazz, *args)</ID>
    <ID>SpreadOperator:InteractiveShellTest.kt$InteractiveShellTest$(*args)</ID>
    <ID>SpreadOperator:InteractiveShellTest.kt$InteractiveShellTest$(*args.map { it!!::class.java }.toTypedArray())</ID>
    <ID>SpreadOperator:InternalUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:InvocationHandlerTemplate.kt$InvocationHandlerTemplate$(delegate, *args)</ID>
    <ID>SpreadOperator:IrsDemoWebApplication.kt$IrsDemoWebApplication.Companion$(IrsDemoWebApplication::class.java, *args)</ID>
    <ID>SpreadOperator:IssueCash.kt$IssueCash$(*args)</ID>
    <ID>SpreadOperator:JVMConfig.kt$JVMConfig$(jarPath, *args)</ID>
    <ID>SpreadOperator:JVMConfig.kt$JVMConfig$(javaPath.toString(), "-jar", jarPath.toString(), *args)</ID>
    <ID>SpreadOperator:JacksonSupportTest.kt$JacksonSupportTest$(*fieldNames)</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$((bin / command[0]).toString(), *command.sliceArray(1 until command.size))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "cvf", fileName) + contents))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "i", fileName)))</ID>
    <ID>SpreadOperator:JarSignatureTestUtils.kt$JarSignatureTestUtils$(*(arrayOf("jar", "uvf", fileName) + contents))</ID>
    <ID>SpreadOperator:Kryo.kt$ImmutableClassSerializer$(*args)</ID>
    <ID>SpreadOperator:LogHelper.kt$LogHelper$(*classes.map { "+" + it.packageName }.toTypedArray())</ID>
    <ID>SpreadOperator:LogHelper.kt$LogHelper$(*classes.map { it.packageName }.toTypedArray())</ID>
    <ID>SpreadOperator:Main.kt$(*args)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( identityService, *arrayOf(initialIdentity.keyPair) + moreKeys )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, *moreIdentities )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$( listOf(getCallerPackage(MockServices::class)!!), firstIdentity, networkParameters, *moreIdentities )</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(*listOf(firstIdentity, *moreIdentities).map { it.identity }.toTypedArray())</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(cordappPackages, TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(firstIdentity, *moreIdentities)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices$(listOf(getCallerPackage(MockServices::class)!!), TestIdentity(initialIdentityName, key), identityService, *moreKeys)</ID>
    <ID>SpreadOperator:MockServices.kt$MockServices.Companion$( identityService, *arrayOf(initialIdentity.keyPair) + moreKeys )</ID>
    <ID>SpreadOperator:NetworkBuilder.kt$(*this.toTypedArray())</ID>
    <ID>SpreadOperator:NetworkMapTest.kt$NetworkMapTest$(*nodes)</ID>
    <ID>SpreadOperator:NetworkMapUpdater.kt$NetworkMapUpdater$(*networkMapDownloadFutures)</ID>
    <ID>SpreadOperator:NetworkParametersCopier.kt$NetworkParametersCopier$(nodeDir / fileName, *copyOptions)</ID>
    <ID>SpreadOperator:NodeRegistrationTest.kt$NodeRegistrationTest$( pollInterval = 1.seconds, hostAndPort = portAllocation.nextHostAndPort(), myHostNameValue = "localhost", additionalServices = *arrayOf(registrationHandler))</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(*commonPredicates)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(*commonPredicates, stateRefsPredicate)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(lockUpdateTime, lockIdPredicate, *commonPredicates)</ID>
    <ID>SpreadOperator:NodeVaultService.kt$NodeVaultService$(stateStatusPredication, lockIdPredicate, *commonPredicates)</ID>
    <ID>SpreadOperator:ObjectBuilder.kt$ConstructorCaller$(*parameters)</ID>
    <ID>SpreadOperator:ObligationUtils.kt$ObligationUtils$(*inputs)</ID>
    <ID>SpreadOperator:PathUtils.kt$(*options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(parent / fileName, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *attrs)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, BasicFileAttributes::class.java, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, bytes, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, lines, charset, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, maxDepth, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, target, *options)</ID>
    <ID>SpreadOperator:PathUtils.kt$(this, targetFile, *options)</ID>
    <ID>SpreadOperator:ProgressTracker.kt$ProgressTracker$(UNSTARTED, STARTING, *inputSteps, DONE)</ID>
    <ID>SpreadOperator:Properties.kt$FunctionalListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$ListProperty$(*error.containingPath(index).toTypedArray())</ID>
    <ID>SpreadOperator:Properties.kt$StandardProperty$(*key.split(".").toTypedArray())</ID>
    <ID>SpreadOperator:PropertyValidationTest.kt$PropertyValidationTest$(*key.split(".").toTypedArray())</ID>
    <ID>SpreadOperator:PropertyValidationTest.kt$PropertyValidationTest$(*key.split(".").toTypedArray(), nestedKey)</ID>
    <ID>SpreadOperator:RPCClient.kt$RPCClient$(*haPoolTransportConfigurations.toTypedArray())</ID>
    <ID>SpreadOperator:RPCDriver.kt$RandomRpcUser.Companion$(handle.proxy, *arguments.toTypedArray())</ID>
    <ID>SpreadOperator:RPCOpsWithContext.kt$(cordaRPCOps, *(args ?: arrayOf()))</ID>
    <ID>SpreadOperator:RPCSecurityManagerTest.kt$RPCSecurityManagerTest$(request.first(), *args)</ID>
    <ID>SpreadOperator:RPCServer.kt$RPCServer$(invocationTarget.instance, *arguments.toTypedArray())</ID>
    <ID>SpreadOperator:ReactiveArtemisConsumer.kt$ReactiveArtemisConsumer.Companion$(queueName, *queueNames)</ID>
    <ID>SpreadOperator:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ErrorInterceptingHandler$(reconnectingRPCConnection.proxy, *(args ?: emptyArray()))</ID>
    <ID>SpreadOperator:ServiceHub.kt$ServiceHub$(first, *remaining)</ID>
    <ID>SpreadOperator:StandaloneShell.kt$StandaloneShell$(format, *args)</ID>
    <ID>SpreadOperator:StringToMethodCallParser.kt$StringToMethodCallParser.ParsedMethodCall$(target, *args)</ID>
    <ID>SpreadOperator:TestNodeInfoBuilder.kt$TestNodeInfoBuilder$(*certs, intermediateAndRoot.first.certificate, intermediateAndRoot.second)</ID>
    <ID>SpreadOperator:TestUtils.kt$TestIdentity$(*bytes)</ID>
    <ID>SpreadOperator:ThrowableSerializer.kt$ThrowableSerializer$(*params.toTypedArray())</ID>
    <ID>SpreadOperator:TraderDemo.kt$TraderDemo$(*args)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*keys)</ID>
    <ID>SpreadOperator:TransactionBuilder.kt$TransactionBuilder$(*types)</ID>
    <ID>SpreadOperator:TransactionWithSignatures.kt$TransactionWithSignatures$(*allowedToBeMissing)</ID>
    <ID>SpreadOperator:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$(listOf(bc1), node, identity, notaryNode, *extraSigningNodes)</ID>
    <ID>SpreadOperator:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$(listOf(bc2), node, identity, notaryNode, *extraSigningNodes)</ID>
    <ID>SpreadOperator:TwoPartyTradeFlowTests.kt$TwoPartyTradeFlowTests$(listOf(eb1), node, identity, notaryNode, *extraSigningNodes)</ID>
    <ID>SpreadOperator:VaultQueryTests.kt$VaultQueryTestRule$( cordappPackages, makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity), megaCorp, moreKeys = *arrayOf(DUMMY_NOTARY_KEY))</ID>
    <ID>SpreadOperator:VaultQueryTests.kt$VaultQueryTestsBase$(*states.toList().toTypedArray())</ID>
    <ID>SpreadOperator:VaultWithCashTest.kt$VaultWithCashTest$( cordappPackages, makeTestIdentityService(MEGA_CORP_IDENTITY, MINI_CORP_IDENTITY, dummyCashIssuer.identity, dummyNotary.identity), TestIdentity(MEGA_CORP.name, servicesKey), networkParameters, moreKeys = *arrayOf(dummyNotary.keyPair))</ID>
    <ID>SpreadOperator:WaitForStateConsumption.kt$WaitForStateConsumption$(*futures.toTypedArray())</ID>
    <ID>SpreadOperator:WebArgsParser.kt$ArgsParser$(*args)</ID>
    <ID>SpreadOperator:WebServer.kt$(*args)</ID>
    <ID>SpreadOperator:WithContracts.kt$WithContracts$( magicNumber, mockNet.defaultNotaryIdentity, owner, *others)</ID>
    <ID>SpreadOperator:WithContracts.kt$WithContracts$(owner, magicNumber, *others)</ID>
    <ID>SpreadOperator:X509Utilities.kt$X509Utilities$(*certificates)</ID>
    <ID>ThrowsCount:AMQPTypeIdentifierParser.kt$AMQPTypeIdentifierParser$// Make sure our inputs aren't designed to blow things up. private fun validate(typeString: String)</ID>
    <ID>ThrowsCount:AbstractNode.kt$fun CordaPersistence.startHikariPool(hikariProperties: Properties, databaseConfig: DatabaseConfig, schemas: Set&lt;MappedSchema&gt;, metricRegistry: MetricRegistry? = null, cordappLoader: CordappLoader? = null, currentDir: Path? = null, ourName: CordaX500Name)</ID>
    <ID>ThrowsCount:ArtemisMessagingServer.kt$ArtemisMessagingServer$// TODO: Maybe wrap [IOException] on a key store load error so that it's clearly splitting key store loading from // Artemis IO errors @Throws(IOException::class, AddressBindingException::class, KeyStoreException::class) private fun configureAndStartServer()</ID>
    <ID>ThrowsCount:BrokerJaasLoginModule.kt$BaseBrokerJaasLoginModule$@Suppress("DEPRECATION") // should use java.security.cert.X509Certificate protected fun getUsernamePasswordAndCerts(): Triple&lt;String, String, Array&lt;javax.security.cert.X509Certificate&gt;?&gt;</ID>
    <ID>ThrowsCount:CheckpointVerifier.kt$CheckpointVerifier$ fun verifyCheckpointsCompatible( checkpointStorage: CheckpointStorage, currentCordapps: List&lt;Cordapp&gt;, platformVersion: Int, serviceHub: ServiceHub, tokenizableServices: List&lt;Any&gt; )</ID>
    <ID>ThrowsCount:CheckpointVerifier.kt$CheckpointVerifier$// Throws exception when the flow is incompatible private fun checkFlowCompatible(subFlow: SubFlow, currentCordappsByHash: Map&lt;SecureHash.SHA256, Cordapp&gt;, platformVersion: Int)</ID>
    <ID>ThrowsCount:ClassCarpenter.kt$ClassCarpenterImpl$ private fun validateSchema(schema: Schema)</ID>
    <ID>ThrowsCount:ConnectionManager.kt$ fun setupJSchWithSshAgent(): JSch</ID>
    <ID>ThrowsCount:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$ fun resolve(services: ServicesForResolution, sigs: List&lt;TransactionSignature&gt;): ContractUpgradeLedgerTransaction</ID>
    <ID>ThrowsCount:Crypto.kt$Crypto$ @JvmStatic @Throws(InvalidKeyException::class, SignatureException::class) fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean</ID>
    <ID>ThrowsCount:DeserializationInput.kt$DeserializationInput$@Throws( AMQPNotSerializableException::class, AMQPNoTypeNotSerializableException::class) private fun &lt;R&gt; des(generator: () -&gt; R): R</ID>
    <ID>ThrowsCount:DeserializationInput.kt$DeserializationInput$fun readObject(obj: Any, schemas: SerializationSchemas, type: Type, context: SerializationContext): Any</ID>
    <ID>ThrowsCount:EnumTransforms.kt$EnumTransforms$ private fun validateNoCycles(constants: Map&lt;String, Int&gt;)</ID>
    <ID>ThrowsCount:JacksonSupport.kt$JacksonSupport.PartyDeserializer$private fun lookupByNameSegment(mapper: PartyObjectMapper, parser: JsonParser): Party</ID>
    <ID>ThrowsCount:JarScanningCordappLoader.kt$JarScanningCordappLoader$private fun parseVersion(versionStr: String?, attributeName: String): Int</ID>
    <ID>ThrowsCount:LedgerDSLInterpreter.kt$Verifies$ fun failsWith(expectedMessage: String?): EnforceVerifyOrFail</ID>
    <ID>ThrowsCount:MockServices.kt$ fun &lt;T : SerializeAsToken&gt; createMockCordaService(serviceHub: MockServices, serviceConstructor: (AppServiceHub) -&gt; T): T</ID>
    <ID>ThrowsCount:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$private fun validateCertificates(registeringPublicKey: PublicKey, certificates: List&lt;X509Certificate&gt;)</ID>
    <ID>ThrowsCount:NodeInfoFilesCopier.kt$NodeInfoFilesCopier$private fun atomicCopy(source: Path, destination: Path)</ID>
    <ID>ThrowsCount:NodeVaultService.kt$NodeVaultService$@Throws(VaultQueryException::class) private fun &lt;T : ContractState&gt; _queryBy(criteria: QueryCriteria, paging_: PageSpecification, sorting: Sort, contractStateType: Class&lt;out T&gt;, skipPagingChecks: Boolean): Vault.Page&lt;T&gt;</ID>
    <ID>ThrowsCount:NodeVaultService.kt$NodeVaultService$private fun makeUpdates(batch: Iterable&lt;CoreTransaction&gt;, statesToRecord: StatesToRecord, previouslySeen: Boolean): List&lt;Vault.Update&lt;ContractState&gt;&gt;</ID>
    <ID>ThrowsCount:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$ private fun checkNotaryWhitelisted(notary: Party, attachedParameterHash: SecureHash?)</ID>
    <ID>ThrowsCount:PropertyDescriptor.kt$PropertyDescriptor$ fun validate()</ID>
    <ID>ThrowsCount:RPCApi.kt$RPCApi.ServerToClient.Companion$fun fromClientMessage(context: SerializationContext, message: ClientMessage): ServerToClient</ID>
    <ID>ThrowsCount:RPCServer.kt$RPCServer$private fun invokeRpc(context: RpcAuthContext, inMethodName: String, arguments: List&lt;Any?&gt;): Try&lt;Any&gt;</ID>
    <ID>ThrowsCount:SchemaMigration.kt$SchemaMigration$private fun doRunMigration( run: Boolean, check: Boolean, existingCheckpoints: Boolean? = null )</ID>
    <ID>ThrowsCount:ServicesForResolutionImpl.kt$ServicesForResolutionImpl$// We may need to recursively chase transactions if there are notary changes. fun inner(stateRef: StateRef, forContractClassName: String?): Attachment</ID>
    <ID>ThrowsCount:SignedNodeInfo.kt$SignedNodeInfo$// TODO Add root cert param (or TrustAnchor) to make sure all the identities belong to the same root fun verified(): NodeInfo</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$// TODO: Verify contract constraints here as well as in LedgerTransaction to ensure that anything being deserialised // from the attachment is trusted. This will require some partial serialisation work to not load the ContractState // objects from the TransactionState. @DeleteForDJVM private fun verifyRegularTransaction(services: ServiceHub, checkSufficientSignatures: Boolean)</ID>
    <ID>ThrowsCount:SignedTransaction.kt$SignedTransaction$@DeleteForDJVM private fun resolveAndCheckNetworkParameters(services: ServiceHub)</ID>
    <ID>ThrowsCount:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$private fun getInitiatedFlowFactory(message: InitialSessionMessage): InitiatedFlowFactory&lt;*&gt;</ID>
    <ID>ThrowsCount:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parse(target: T?, command: String): ParsedMethodCall</ID>
    <ID>ThrowsCount:StringToMethodCallParser.kt$StringToMethodCallParser$ @Throws(UnparseableCallException::class) fun parseArguments(methodNameHint: String, parameters: List&lt;Pair&lt;String, Type&gt;&gt;, args: String): Array&lt;Any?&gt;</ID>
    <ID>ThrowsCount:StructuresTests.kt$AttachmentTest$@Test fun `openAsJAR does not leak file handle if attachment has corrupted manifest`()</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ fun withItems(vararg items: Any)</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun addMissingDependency(services: ServicesForResolution, wireTx: WireTransaction): Boolean</ID>
    <ID>ThrowsCount:TransactionBuilder.kt$TransactionBuilder$ private fun attachmentConstraintsTransition( constraints: Set&lt;AttachmentConstraint&gt;, attachmentToUse: ContractAttachment, services: ServicesForResolution ): AttachmentConstraint</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$ private fun getUniqueContractAttachmentsByContract(): Map&lt;ContractClassName, ContractAttachment&gt;</ID>
    <ID>ThrowsCount:TransactionVerifierServiceInternal.kt$Verifier$// Using basic graph theory, a full cycle of encumbered (co-dependent) states should exist to achieve bi-directional // encumbrances. This property is important to ensure that no states involved in an encumbrance-relationship // can be spent on their own. Briefly, if any of the states is having more than one encumbrance references by // other states, a full cycle detection will fail. As a result, all of the encumbered states must be present // as "from" and "to" only once (or zero times if no encumbrance takes place). For instance, // a -&gt; b // c -&gt; b and a -&gt; b // b -&gt; a b -&gt; c // do not satisfy the bi-directionality (full cycle) property. // // In the first example "b" appears twice in encumbrance ("to") list and "c" exists in the encumbered ("from") list only. // Due the above, one could consume "a" and "b" in the same transaction and then, because "b" is already consumed, "c" cannot be spent. // // Similarly, the second example does not form a full cycle because "a" and "c" exist in one of the lists only. // As a result, one can consume "b" and "c" in the same transactions, which will make "a" impossible to be spent. // // On other hand the following are valid constructions: // a -&gt; b a -&gt; c // b -&gt; c and c -&gt; b // c -&gt; a b -&gt; a // and form a full cycle, meaning that the bi-directionality property is satisfied. private fun checkBidirectionalOutputEncumbrances(statesAndEncumbrance: List&lt;Pair&lt;Int, Int&gt;&gt;)</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction$private fun toLedgerTransactionInternal( resolveIdentity: (PublicKey) -&gt; Party?, resolveAttachment: (SecureHash) -&gt; Attachment?, resolveStateRefAsSerialized: (StateRef) -&gt; SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?, resolveParameters: (SecureHash?) -&gt; NetworkParameters?, isAttachmentTrusted: (Attachment) -&gt; Boolean ): LedgerTransaction</ID>
    <ID>ThrowsCount:WireTransaction.kt$WireTransaction.Companion$ @CordaInternal fun resolveStateRefBinaryComponent(stateRef: StateRef, services: ServicesForResolution): SerializedBytes&lt;TransactionState&lt;ContractState&gt;&gt;?</ID>
    <ID>TooGenericExceptionCaught:AMQPChannelHandler.kt$AMQPChannelHandler$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:AMQPExceptions.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:AMQPTestUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$AbstractNode$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$AbstractNode.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNode.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:AbstractNodeTests.kt$ColdJVM.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:Amount.kt$Amount.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentDemo.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentLoadingTests.kt$AttachmentLoadingTests.ConsumeAndBroadcastResponderFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AttachmentVersionNumberMigration.kt$AttachmentVersionNumberMigration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:AzureSmbVolume.kt$AzureSmbVolume$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BCCryptoService.kt$BCCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BankOfCordaWebApi.kt$BankOfCordaWebApi$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BlobInspector.kt$BlobInspector$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BootstrapperView.kt$BootstrapperView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:BridgeControlListener.kt$BridgeControlListener$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:BrokerJaasLoginModule.kt$BrokerJaasLoginModule$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CertRole.kt$CertRole.Companion$ex: ArrayIndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:CheckpointAgent.kt$CheckpointAgent.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckpointAgent.kt$CheckpointHook$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:CheckpointDumper.kt$CheckpointDumper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CheckpointVerifier.kt$CheckpointVerifier$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CollectSignaturesFlow.kt$SignTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ConcurrencyUtils.kt$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ConfigUtilities.kt$e:Exception</ID>
    <ID>TooGenericExceptionCaught:ConnectionStateMachine.kt$ConnectionStateMachine$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ContractAttachmentSerializer.kt$ContractAttachmentSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ContractUpgradeTransactions.kt$ContractUpgradeWireTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaAuthenticationPlugin.kt$CordaAuthenticationPlugin$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaClassResolver.kt$LoggingWhitelist.Companion$ioEx: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$CordaFutureImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$ValueOrException$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaFutureImpl.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaPersistence.kt$CordaPersistence$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCClientTest.kt$CordaRPCClientTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CordaRPCOpsImpl.kt$CordaRPCOpsImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CryptoUtilsTest.kt$CryptoUtilsTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DBNetworkParametersStorage.kt$DBNetworkParametersStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DataUploadServlet.kt$DataUploadServlet$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:DbMapDeadlockTest.kt$DbMapDeadlockTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DemoBenchView.kt$DemoBenchView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DeserializationInput.kt$DeserializationInput$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DeserializeSimpleTypesTests.kt$DeserializeSimpleTypesTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DockerInstantiator.kt$DockerInstantiator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DriverDSLImpl.kt$DriverDSLImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DriverDSLImpl.kt$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:DriverTests.kt$DriverTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ErrorCodeLoggingTests.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ErrorHandling.kt$ErrorHandling.CheckpointAfterErrorFlow$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:EventProcessor.kt$EventProcessor$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:Eventually.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Expect.kt$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Explorer.kt$Explorer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FiberDeserializationCheckingInterceptor.kt$FiberDeserializationChecker$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FinanceJSONSupport.kt$CalendarDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowHandle.kt$FlowProgressHandleImpl$e: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowMessaging.kt$FlowMessagingImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStackSnapshotTest.kt$FlowStackSnapshotTest$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStateMachineImpl.kt$FlowStateMachineImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:FlowStateMachineImpl.kt$FlowStateMachineImpl$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:FutureMatchers.kt$&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HibernateConfiguration.kt$HibernateConfiguration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IRSDemo.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:IRSDemoTest.kt$IRSDemoTest.InterestRateSwapStateDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InitialRegistrationCli.kt$InitialRegistration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InitialRegistrationCli.kt$InitialRegistration.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Injectors.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InstallShellExtensionsParser.kt$ShellExtensionsGenerator$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:InteractiveShell.kt$InteractiveShell$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InteractiveShell.kt$InteractiveShell$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:InterestSwapRestAPI.kt$InterestRateSwapAPI$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalMockNetwork.kt$InternalMockNetwork$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:InternalTestUtils.kt$&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:InternalUtils.kt$th: Throwable</ID>
    <ID>TooGenericExceptionCaught:IssueCash.kt$IssueCash$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JVMAgentUtil.kt$JVMAgentUtil$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.PartyDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.PublicKeyDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JacksonSupport.kt$JacksonSupport.SecureHashDeserializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:JarScanningCordappLoader.kt$JarScanningCordappLoader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Kryo.kt$ImmutableClassSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:LedgerDSLInterpreter.kt$Verifies$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:LoadTest.kt$LoadTest$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:LoginView.kt$LoginView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Main.kt$Main$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MerkleTransaction.kt$FilteredTransaction$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MigrationServicesForResolution.kt$MigrationServicesForResolution$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockAttachmentStorage.kt$MockAttachmentStorage$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockCryptoService.kt$MockCryptoService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MockNodeMessagingService.kt$MockNodeMessagingService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:MyCustomNotaryService.kt$MyValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NamedCacheTest.kt$NamedCacheTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NettyTestHandler.kt$NettyTestHandler$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:NetworkBootstrapper.kt$NetworkBootstrapper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapServer.kt$NetworkMapServer.InMemoryNetworkMapService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapUpdater.kt$NetworkMapUpdater$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkMapUpdater.kt$NetworkMapUpdater.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkParameterOverridesSpec.kt$NetworkParameterOverridesSpec.PackageOwnershipSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkParametersReader.kt$NetworkParametersReader$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NetworkRegistrationHelper.kt$NetworkRegistrationHelper$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeController.kt$NodeController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeInfoWatcher.kt$NodeInfoWatcher$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeInterestRates.kt$NodeInterestRates$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeMonitorModel.kt$NodeMonitorModel$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeProcess.kt$NodeProcess.Factory$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeRPC.kt$NodeRPC$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeRPC.kt$NodeRPC.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeSchedulerService.kt$NodeSchedulerService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeStartup.kt$NodeStartup$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeTerminalView.kt$NodeTerminalView$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeVaultService.kt$NodeVaultService$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NodeVaultServiceTest.kt$NodeVaultServiceTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NonValidatingNotaryFlow.kt$NonValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryServiceFlow.kt$NotaryServiceFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:NotaryUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ObjectDiffer.kt$ObjectDiffer$throwable: Exception</ID>
    <ID>TooGenericExceptionCaught:P2PMessagingClient.kt$P2PMessagingClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PersistentIdentityMigrationNewTableTest.kt$PersistentIdentityMigrationNewTableTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PersistentUniquenessProvider.kt$PersistentUniquenessProvider$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ProfileController.kt$ProfileController$e: Exception</ID>
    <ID>TooGenericExceptionCaught:PropertyValidationTest.kt$PropertyValidationTest$e: Exception</ID>
    <ID>TooGenericExceptionCaught:QuasarInstrumentationHook.kt$QuasarInstrumentationHook$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:R3Pty.kt$R3Pty$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCApi.kt$RPCApi.ServerToClient.Companion$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClient.kt$RPCClient$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCClientProxyHandler.kt$RPCClientProxyHandler$e: RuntimeException</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$exception: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCServer.kt$RPCServer$throwable: Throwable</ID>
    <ID>TooGenericExceptionCaught:RPCStabilityTests.kt$RPCStabilityTests$e2: Exception</ID>
    <ID>TooGenericExceptionCaught:RPCStabilityTests.kt$RPCStabilityTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RandomFailingProxy.kt$RandomFailingProxy$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReceiveTransactionFlow.kt$ReceiveTransactionFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingCordaRPCOps.kt$ReconnectingCordaRPCOps.ReconnectingRPCConnection$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ReconnectingObservable.kt$ReconnectingObservable.ReconnectingSubscriber$e: Exception</ID>
    <ID>TooGenericExceptionCaught:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SSLHelper.kt$LoggingTrustManagerWrapper$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SerializationOutputTests.kt$SerializationOutputTests$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:ShutdownManager.kt$ShutdownManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:SimpleMQClient.kt$SimpleMQClient$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$e: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:StandaloneShell.kt$StandaloneShell$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StandardConfigValueParsers.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:StringToMethodCallParser.kt$StringToMethodCallParser$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TLSAuthenticationTests.kt$TLSAuthenticationTests$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:ThrowableSerializer.kt$ThrowableSerializer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TlsDiffAlgorithmsTest.kt$TlsDiffAlgorithmsTest$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:TlsDiffProtocolsTest.kt$TlsDiffProtocolsTest$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:TraderDemo.kt$TraderDemo$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransactionBuilder.kt$TransactionBuilder$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:TransactionSignatureTest.kt$TransactionSignatureTest$e: Throwable</ID>
    <ID>TooGenericExceptionCaught:TransactionUtils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:TransformTypes.kt$TransformTypes.Companion$e: IndexOutOfBoundsException</ID>
    <ID>TooGenericExceptionCaught:TransitionExecutorImpl.kt$TransitionExecutorImpl$exception: Exception</ID>
    <ID>TooGenericExceptionCaught:Try.kt$Try.Companion$t: Throwable</ID>
    <ID>TooGenericExceptionCaught:Utils.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:V1NodeConfigurationSpec.kt$V1NodeConfigurationSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:ValidatingNotaryFlow.kt$ValidatingNotaryFlow$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VaultStateMigration.kt$VaultStateIterator$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VaultStateMigration.kt$VaultStateMigration$e: Exception</ID>
    <ID>TooGenericExceptionCaught:VersionedParsingExampleTest.kt$VersionedParsingExampleTest.RpcSettingsSpec$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$WebServer$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:WebServer.kt$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:WithMockNet.kt$WithMockNet.&lt;no name provided&gt;$e: Exception</ID>
    <ID>TooGenericExceptionCaught:X509EdDSAEngine.kt$X509EdDSAEngine$e: Exception</ID>
    <ID>TooGenericExceptionCaught:X509UtilitiesTest.kt$X509UtilitiesTest$ex: Exception</ID>
    <ID>TooGenericExceptionThrown:AMQPExceptionsTests.kt$AMQPExceptionsTests$throw Exception("FAILED")</ID>
    <ID>TooGenericExceptionThrown:AzureBackend.kt$AzureBackend.Companion$throw RuntimeException(e)</ID>
    <ID>TooGenericExceptionThrown:ClassLoadingUtilsTest.kt$ClassLoadingUtilsTest$throw RuntimeException()</ID>
    <ID>TooGenericExceptionThrown:CommandParsers.kt$AzureParser.RegionConverter$throw Error("Unknown azure region: $value")</ID>
    <ID>TooGenericExceptionThrown:ContractHierarchyTest.kt$ContractHierarchyTest.IndirectContractParent$throw RuntimeException("Boom!")</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated exit of ${request.amount} from $issuer, however there is no cash to exit!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from $issuer, " + "however they only have $issuerQuantity!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from ${node.mainIdentity}, " + "however there is no cash from $issuer!" )</ID>
    <ID>TooGenericExceptionThrown:CrossCashTest.kt$throw Exception( "Generated payment of ${request.amount} from ${node.mainIdentity}, " + "however they only have $senderQuantity!" )</ID>
    <ID>TooGenericExceptionThrown:DbListenerService.kt$DbListenerService$throw Exception("Mother of all exceptions")</ID>
    <ID>TooGenericExceptionThrown:FlowAsyncOperationTests.kt$FlowAsyncOperationTests.ErroredExecute$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:FlowFrameworkTests.kt$FlowFrameworkTests$throw Exception("Error")</ID>
    <ID>TooGenericExceptionThrown:Generator.kt$Generator$throw Exception("Failed to generate", error)</ID>
    <ID>TooGenericExceptionThrown:MerkleTransaction.kt$FilteredTransaction$throw Exception("Malformed transaction, signers at index $internalIndex cannot be deserialised", e)</ID>
    <ID>TooGenericExceptionThrown:NodeConnection.kt$NodeConnection.ShellCommandOutput$throw Exception(diagnostic)</ID>
    <ID>TooGenericExceptionThrown:PhysicalLocationStructures.kt$CityDatabase$throw Exception("Could not parse line: $line")</ID>
    <ID>TooGenericExceptionThrown:RPCDriver.kt$RandomRpcUser.Companion$throw Exception("No generator for ${it.type}")</ID>
    <ID>TooGenericExceptionThrown:RpcExceptionHandlingTest.kt$RpcExceptionHandlingTest.ClientRelevantErrorFlow$throw Exception(message, SQLException("Oops!"))</ID>
    <ID>TooGenericExceptionThrown:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$throw Error("Observable serializer must be registerable with factory, unexpected exception - ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:RpcServerObservableSerializerTests.kt$RpcServerObservableSerializerTests$throw Error("Serialization of observable should not throw - ${e.message}")</ID>
    <ID>TooGenericExceptionThrown:SelfIssueTest.kt$throw Exception( "Simulated state diverged from actual state" + "\nSimulated state:\n${previousState.vaultsSelfIssued}" + "\nActual state:\n$selfIssueVaults" + "\nDiff:\n$diffString" )</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${payload::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SendTransactionFlow.kt$DataVendingFlow$throw Exception("Unknown payload type: ${stateAndRef!!::class.java} ?")</ID>
    <ID>TooGenericExceptionThrown:SerializationOutputTests.kt$SerializationOutputTests$throw Error("Deserializing serialized \$C should not throw")</ID>
    <ID>TooGenericExceptionThrown:SerializationOutputTests.kt$SerializationOutputTests.&lt;no name provided&gt;$throw Exception()</ID>
    <ID>TooGenericExceptionThrown:UniversalContract.kt$UniversalContract$throw Error("Unable to evaluate")</ID>
    <ID>TooGenericExceptionThrown:WebServerConfig.kt$WebServerConfig$throw Exception("Missing rpc address property. Either 'rpcSettings' or 'rpcAddress' must be specified.")</ID>
    <ID>TooManyFunctions:AbstractNode.kt$AbstractNode&lt;S&gt; : SingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:ActionExecutorImpl.kt$ActionExecutorImpl : ActionExecutor</ID>
    <ID>TooManyFunctions:AppendOnlyPersistentMap.kt$AppendOnlyPersistentMapBase&lt;K, V, E, out EK&gt;</ID>
    <ID>TooManyFunctions:ArtemisTcpTransport.kt$ArtemisTcpTransport$Companion</ID>
    <ID>TooManyFunctions:BCCryptoService.kt$BCCryptoService : CryptoService</ID>
    <ID>TooManyFunctions:BFTSmart.kt$BFTSmart$Replica : DefaultRecoverable</ID>
    <ID>TooManyFunctions:BaseTransaction.kt$BaseTransaction : NamedByHash</ID>
    <ID>TooManyFunctions:ClassCarpenter.kt$ClassCarpenterImpl : ClassCarpenter</ID>
    <ID>TooManyFunctions:ConfigUtilities.kt$net.corda.nodeapi.internal.config.ConfigUtilities.kt</ID>
    <ID>TooManyFunctions:Configuration.kt$Configuration$Specification&lt;VALUE&gt; : SchemaParser</ID>
    <ID>TooManyFunctions:ConnectionStateMachine.kt$ConnectionStateMachine : BaseHandler</ID>
    <ID>TooManyFunctions:ContractUpgradeTransactions.kt$ContractUpgradeLedgerTransaction : FullTransactionTransactionWithSignatures</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$CordaRPCOps : RPCOps</ID>
    <ID>TooManyFunctions:CordaRPCOps.kt$net.corda.core.messaging.CordaRPCOps.kt</ID>
    <ID>TooManyFunctions:CordaRPCOpsImpl.kt$CordaRPCOpsImpl : InternalCordaRPCOpsAutoCloseable</ID>
    <ID>TooManyFunctions:Crypto.kt$Crypto</ID>
    <ID>TooManyFunctions:CryptoUtils.kt$net.corda.core.crypto.CryptoUtils.kt</ID>
    <ID>TooManyFunctions:Currencies.kt$net.corda.finance.Currencies.kt</ID>
    <ID>TooManyFunctions:Driver.kt$DriverParameters</ID>
    <ID>TooManyFunctions:DriverDSLImpl.kt$DriverDSLImpl : InternalDriverDSL</ID>
    <ID>TooManyFunctions:EncodingUtils.kt$net.corda.core.utilities.EncodingUtils.kt</ID>
    <ID>TooManyFunctions:FlowLogic.kt$FlowLogic&lt;out T&gt;</ID>
    <ID>TooManyFunctions:FlowStateMachineImpl.kt$FlowStateMachineImpl&lt;R&gt; : FiberFlowStateMachineFlowFiber</ID>
    <ID>TooManyFunctions:Generator.kt$Generator$Companion</ID>
    <ID>TooManyFunctions:HibernateQueryCriteriaParser.kt$HibernateQueryCriteriaParser : AbstractQueryCriteriaParserIQueryCriteriaParser</ID>
    <ID>TooManyFunctions:HibernateStatistics.kt$DelegatingStatisticsService : StatisticsService</ID>
    <ID>TooManyFunctions:InteractiveShell.kt$InteractiveShell</ID>
    <ID>TooManyFunctions:InternalMockNetwork.kt$InternalMockNetwork : AutoCloseable</ID>
    <ID>TooManyFunctions:InternalMockNetwork.kt$InternalMockNetwork$MockNode : AbstractNode</ID>
    <ID>TooManyFunctions:InternalTestUtils.kt$net.corda.testing.internal.InternalTestUtils.kt</ID>
    <ID>TooManyFunctions:InternalTestUtils.kt$net.corda.testing.node.internal.InternalTestUtils.kt</ID>
    <ID>TooManyFunctions:InternalUtils.kt$net.corda.core.internal.InternalUtils.kt</ID>
    <ID>TooManyFunctions:JarScanningCordappLoader.kt$JarScanningCordappLoader : CordappLoaderTemplate</ID>
    <ID>TooManyFunctions:LedgerTransaction.kt$LedgerTransaction : FullTransaction</ID>
    <ID>TooManyFunctions:LocalSerializerFactory.kt$DefaultLocalSerializerFactory : LocalSerializerFactory</ID>
    <ID>TooManyFunctions:LocalTypeInformationBuilder.kt$LocalTypeInformationBuilder</ID>
    <ID>TooManyFunctions:MockNodeMessagingService.kt$MockNodeMessagingService : SingletonSerializeAsTokenMessagingService</ID>
    <ID>TooManyFunctions:NetworkBootstrapper.kt$NetworkBootstrapper : NetworkBootstrapperWithOverridableParameters</ID>
    <ID>TooManyFunctions:Node.kt$Node : AbstractNode</ID>
    <ID>TooManyFunctions:NodeAttachmentService.kt$NodeAttachmentService : AttachmentStorageInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:NodeConnection.kt$NodeConnection : Closeable</ID>
    <ID>TooManyFunctions:NodeController.kt$NodeController : Controller</ID>
    <ID>TooManyFunctions:NodeVaultService.kt$NodeVaultService : SingletonSerializeAsTokenVaultServiceInternal</ID>
    <ID>TooManyFunctions:OGSwapPricingExample.kt$SwapPricingExample</ID>
    <ID>TooManyFunctions:ObservableUtilities.kt$net.corda.client.jfx.utils.ObservableUtilities.kt</ID>
    <ID>TooManyFunctions:P2PMessagingClient.kt$P2PMessagingClient : SingletonSerializeAsTokenMessagingServiceAddressToArtemisQueueResolver</ID>
    <ID>TooManyFunctions:PathUtils.kt$net.corda.core.internal.PathUtils.kt</ID>
    <ID>TooManyFunctions:Perceivable.kt$net.corda.finance.contracts.universal.Perceivable.kt</ID>
    <ID>TooManyFunctions:PersistentIdentityService.kt$PersistentIdentityService : SingletonSerializeAsTokenIdentityServiceInternal</ID>
    <ID>TooManyFunctions:PersistentNetworkMapCache.kt$PersistentNetworkMapCache : NetworkMapCacheInternalSingletonSerializeAsToken</ID>
    <ID>TooManyFunctions:PortfolioApi.kt$PortfolioApi</ID>
    <ID>TooManyFunctions:PropertyDescriptor.kt$net.corda.serialization.internal.amqp.PropertyDescriptor.kt</ID>
    <ID>TooManyFunctions:QueryCriteria.kt$QueryCriteria$VaultQueryCriteria : CommonQueryCriteria</ID>
    <ID>TooManyFunctions:QueryCriteriaUtils.kt$Builder</ID>
    <ID>TooManyFunctions:RPCApi.kt$net.corda.nodeapi.RPCApi.kt</ID>
    <ID>TooManyFunctions:RPCClientProxyHandler.kt$RPCClientProxyHandler : InvocationHandler</ID>
    <ID>TooManyFunctions:RPCServer.kt$RPCServer</ID>
    <ID>TooManyFunctions:SerializationHelper.kt$net.corda.serialization.internal.amqp.SerializationHelper.kt</ID>
    <ID>TooManyFunctions:ServiceHub.kt$ServiceHub : ServicesForResolution</ID>
    <ID>TooManyFunctions:SignedTransaction.kt$SignedTransaction : TransactionWithSignatures</ID>
    <ID>TooManyFunctions:SingleThreadedStateMachineManager.kt$SingleThreadedStateMachineManager : StateMachineManagerStateMachineManagerInternal</ID>
    <ID>TooManyFunctions:StartedFlowTransition.kt$StartedFlowTransition : Transition</ID>
    <ID>TooManyFunctions:TestDSL.kt$TestLedgerDSLInterpreter : LedgerDSLInterpreter</ID>
    <ID>TooManyFunctions:TopLevelTransition.kt$TopLevelTransition : Transition</ID>
    <ID>TooManyFunctions:TransactionBuilder.kt$TransactionBuilder</ID>
    <ID>TooManyFunctions:TransactionDSLInterpreter.kt$TransactionDSL&lt;out T : TransactionDSLInterpreter&gt; : TransactionDSLInterpreter</ID>
    <ID>TooManyFunctions:TypeModellingFingerPrinter.kt$FingerPrintingState</ID>
    <ID>TooManyFunctions:Util.kt$net.corda.finance.contracts.universal.Util.kt</ID>
    <ID>TooManyFunctions:Utils.kt$net.corda.common.configuration.parsing.internal.Utils.kt</ID>
    <ID>TooManyFunctions:VaultFiller.kt$VaultFiller</ID>
    <ID>TooManyFunctions:VaultService.kt$VaultService</ID>
    <ID>TooManyFunctions:X509Utilities.kt$X509Utilities</ID>
    <ID>TopLevelPropertyNaming:ConcurrencyUtils.kt$@VisibleForTesting internal const val shortCircuitedTaskFailedMessage = "Short-circuited task failed:"</ID>
    <ID>TopLevelPropertyNaming:CordaPersistence.kt$internal val _prohibitDatabaseAccess = ThreadLocal.withInitial { false }</ID>
    <ID>TopLevelPropertyNaming:ProviderMap.kt$// OID taken from https://tools.ietf.org/html/draft-ietf-curdle-pkix-00 val `id-Curve25519ph` = ASN1ObjectIdentifier("1.3.101.112")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _allEnabledSerializationEnvs: List&lt;Pair&lt;String, SerializationEnvironment&gt;&gt; get() = serializationEnvFields.mapNotNull { it.get()?.let { env -&gt; Pair(it.name, env) } }</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _contextSerializationEnv = ThreadLocalToggleField&lt;SerializationEnvironment&gt;("contextSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _driverSerializationEnv = SimpleToggleField&lt;SerializationEnvironment&gt;("driverSerializationEnv")</ID>
    <ID>TopLevelPropertyNaming:SerializationEnvironment.kt$val _inheritableContextSerializationEnv = InheritableThreadLocalToggleField&lt;SerializationEnvironment&gt;("inheritableContextSerializationEnv") { stack -&gt; stack.fold(false) { isAGlobalThreadBeingCreated, e -&gt; isAGlobalThreadBeingCreated || (e.className == "io.netty.util.concurrent.GlobalEventExecutor" &amp;&amp; e.methodName == "startThread") || (e.className == "java.util.concurrent.ForkJoinPool\$DefaultForkJoinWorkerThreadFactory" &amp;&amp; e.methodName == "newThread") } }</ID>
    <ID>TopLevelPropertyNaming:SerializationFormat.kt$const val encodingNotPermittedFormat = "Encoding not permitted: %s"</ID>
    <ID>VariableNaming:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val DUMMY_NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 20).party</ID>
    <ID>VariableNaming:AttachmentsClassLoaderSerializationTests.kt$AttachmentsClassLoaderSerializationTests$val MEGA_CORP = TestIdentity(CordaX500Name("MegaCorp", "London", "GB")).party</ID>
    <ID>VariableNaming:BootstrapperView.kt$BootstrapperView$val YAML_MAPPER = Constants.getContextMapper()</ID>
    <ID>VariableNaming:ByteArraysTest.kt$ByteArraysTest$val HEX_REGEX = "^[0-9A-F]+\$".toRegex()</ID>
    <ID>VariableNaming:Cap.kt$Cap$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:Caplet.kt$Caplet$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val ECDSA_ALGORITHM = "SHA256withECDSA"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val EC_ALGORITHM = "EC"</ID>
    <ID>VariableNaming:CertificateRevocationListNodeTests.kt$CertificateRevocationListNodeTests$val EMPTY_CRL = "empty.crl"</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val EdSignature = keyPairEd.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairEd.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val K1Signature = keyPairK1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairK1.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val R1Signature = keyPairR1.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairR1.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val RSASignature = keyPairRSA.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairRSA.public).schemeNumberID)))</ID>
    <ID>VariableNaming:CompositeKeyTests.kt$CompositeKeyTests$val SPSignature = keyPairSP.sign(SignableData(secureHash, SignatureMetadata(1, Crypto.findSignatureScheme(keyPairSP.public).schemeNumberID)))</ID>
    <ID>VariableNaming:ContractDefinition.kt$ContractDefinition$val american_fx_option = arrange { actions { acmeCorp may { "exercise" anytime { highStreetBank.owes(acmeCorp, 1.M, USD) acmeCorp.owes(highStreetBank, 1070.K, EUR) } } highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } } }</ID>
    <ID>VariableNaming:ContractDefinition.kt$ContractDefinition$val cds_contract = arrange { actions { acmeCorp may { "payout".givenThat(acmeCorporationHasDefaulted and before("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } } }</ID>
    <ID>VariableNaming:ContractDefinition.kt$ContractDefinition$val european_fx_option = arrange { actions { acmeCorp may { "exercise" anytime { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) acmeCorp.owes(highStreetBank, 1070.K, EUR) } } } } } highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } } }</ID>
    <ID>VariableNaming:CryptoUtilsTest.kt$CryptoUtilsTest$val MBbyte = ByteArray(1000000) // 1.000.000</ID>
    <ID>VariableNaming:DummyContract.kt$DummyContract$val PROGRAM_ID = "net.corda.testing.contracts.DummyContract"</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj1_AA = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path1_AA.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj1_B = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path1_B.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj1_C = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path1_C.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj2_AA = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path2_AA.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj2_BB = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path2_BB.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj2_C = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path2_C.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj3_AA = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path3_AA.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj3_C = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path3_C.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val obj3_XX = DeserializationInput(sf).deserialize(SerializedBytes&lt;C&gt;(path3_XX.readBytes()))</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path1_AA = EvolvabilityTests::class.java.getResource("$resource.1.AA")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path1_B = EvolvabilityTests::class.java.getResource("$resource.1.B")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path1_C = EvolvabilityTests::class.java.getResource("$resource.1.C")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path2_AA = EvolvabilityTests::class.java.getResource("$resource.2.AA")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path2_BB = EvolvabilityTests::class.java.getResource("$resource.2.BB")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path2_C = EvolvabilityTests::class.java.getResource("$resource.2.C")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path3_AA = EvolvabilityTests::class.java.getResource("$resource.3.AA")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path3_C = EvolvabilityTests::class.java.getResource("$resource.3.C")</ID>
    <ID>VariableNaming:EnumEvolveTests.kt$EnumEvolveTests$val path3_XX = EvolvabilityTests::class.java.getResource("$resource.3.XX")</ID>
    <ID>VariableNaming:EnumTests.kt$EnumTests$val schema_bras = schema.types.find { it.name == brasTestName } as RestrictedType</ID>
    <ID>VariableNaming:EnumTests.kt$EnumTests$val schema_c = schema.types.find { it.name == classTestName("C") } as CompositeType</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$@Suppress("UNUSED_VARIABLE") val A = 1</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$@Suppress("UNUSED_VARIABLE") val B = 100</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val A = 1</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val B = "two"</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val B = 100</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val B = 2</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val C = "This is not a banana"</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val C = "three"</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val D = 4</ID>
    <ID>VariableNaming:EvolvabilityTests.kt$EvolvabilityTests$val E = null</ID>
    <ID>VariableNaming:Examples.kt$Examples$// fx swap // both parties have the right to trigger the exchange of cash flows val an_fx_swap = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1070.K, EUR) acmeCorp.owes(highStreetBank, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$// maybe in the presence of negative interest rates you would want other side of contract to be able to take initiative as well val zero_coupon_bond_2 = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$// no touch // Party Receiver // Party Giver // // Giver has right to annul contract if barrier is breached // Receiver has right to receive money at/after expiry // // Assume observable is using FX fixing // val no_touch = arrange { actions { (acmeCorp or highStreetBank) may { "execute".givenThat(after("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } highStreetBank may { "knock out".givenThat(EUR / USD gt 1.3) { zero } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val american_fx_option = arrange { actions { acmeCorp may { "exercise".givenThat(before("2017-09-01")) { highStreetBank.owes(acmeCorp, 1070.K, EUR) acmeCorp.owes(highStreetBank, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val cds_contract = arrange { actions { acmeCorp may { "claim".givenThat(acmeCorporationHasDefaulted and before("2017-09-01")) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val european_fx_option = arrange { actions { acmeCorp may { "exercise".givenThat(before("2017-09-01")) { fx_swap("2017-09-01", 1.M, 1.2.bd, EUR, USD, acmeCorp, highStreetBank) } } (acmeCorp or highStreetBank) may { "expire" anytime { zero } } } }</ID>
    <ID>VariableNaming:Examples.kt$Examples$val one_touch = arrange { actions { highStreetBank may { "expire".givenThat(after("2017-09-01")) { zero } } acmeCorp may { "knock in".givenThat(EUR / USD gt 1.3) { highStreetBank.owes(acmeCorp, 1.M, USD) } } } }</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val A = services.keyManagementService.freshKey(id) // Automatically calls registerKeyToParty and registerKeyToExternalId</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val B = services.keyManagementService.freshKey(id) // Automatically calls registerKeyToParty and registerKeyToExternalId</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val C = services.keyManagementService.freshKey(idTwo) // Automatically calls registerKeyToParty and registerKeyToExternalId</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val D = services.keyManagementService.freshKey() // Automatically calls registerKeyToParty and registerKeyToExternalId</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val E = Crypto.generateKeyPair().public</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val F = Crypto.generateKeyPair().public</ID>
    <ID>VariableNaming:ExternalIdMappingTest.kt$ExternalIdMappingTest$val G = Crypto.generateKeyPair().public</ID>
    <ID>VariableNaming:FXFwdTimeOption.kt$FXFwdTimeOption$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXFwdTimeOption.kt$FXFwdTimeOption$val TEST_TX_TIME_AFTER_MATURITY: Instant get() = Instant.parse("2018-06-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXFwdTimeOption.kt$FXFwdTimeOption$val TEST_TX_TIME_BEFORE_MATURITY: Instant get() = Instant.parse("2018-05-01T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXSwap.kt$FXSwap$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:FXSwap.kt$FXSwap$val TEST_TX_TIME_TOO_EARLY: Instant get() = Instant.parse("2017-08-31T12:00:00.00Z")</ID>
    <ID>VariableNaming:HibernateConfigurationTest.kt$HibernateConfigurationTest$val _dummyLinearStates = it[2] as DummyLinearStateSchemaV1.PersistentDummyLinearState</ID>
    <ID>VariableNaming:HibernateConfigurationTest.kt$HibernateConfigurationTest$val _vaultLinearStates = it[1] as VaultSchemaV1.VaultLinearStates</ID>
    <ID>VariableNaming:InternalMockNetwork.kt$MessagingServiceSpy$internal var _messagingService: MessagingService? = null set(value) { check(field == null) { "Spy has already been attached to a node" } field = value }</ID>
    <ID>VariableNaming:InternalUtilsTest.kt$InternalUtilsTest$val MAX_SIZE = 100</ID>
    <ID>VariableNaming:Literal.kt$ActionBuilder$val This = this</ID>
    <ID>VariableNaming:NodePerformanceTests.kt$NodePerformanceTests$val N = 10000</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _rawUpdatesPublisher = PublishSubject.create&lt;Vault.Update&lt;ContractState&gt;&gt;()!!</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _updatesInDbTx = _updatesPublisher.wrapWithDatabaseTransaction().asObservable()!!</ID>
    <ID>VariableNaming:NodeVaultService.kt$NodeVaultService.InnerState$val _updatesPublisher = PublishSubject.create&lt;Vault.Update&lt;ContractState&gt;&gt;()!!</ID>
    <ID>VariableNaming:OracleNodeTearOffTests.kt$OracleNodeTearOffTests$val DUMMY_NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 20).party</ID>
    <ID>VariableNaming:PersistentStateServiceTests.kt$PersistentStateServiceTests$val MEGA_CORP = TestIdentity(CordaX500Name("MegaCorp", "London", "GB")).party</ID>
    <ID>VariableNaming:PortfolioApi.kt$PortfolioApi$var IMs: Map&lt;String, InitialMarginTriple&gt;? = null</ID>
    <ID>VariableNaming:PortfolioApi.kt$PortfolioApi$var PVs: Map&lt;String, MultiCurrencyAmount&gt;? = null</ID>
    <ID>VariableNaming:RPCPerformanceTests.kt$RPCPerformanceTests$val N = 10000</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_action1 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_action2 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_and1 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } actions { acmeCorp may { "do it" anytime { acmeCorp.owes(momAndPop, 10.K, USD) } } } next() }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_and2 = arrange { actions { highStreetBank may { "do it" anytime { highStreetBank.owes(acmeCorp, 10.K, USD) } } } actions { acmeCorp may { "do it" anytime { acmeCorp.owes(momAndPop, 10.K, USD) } } } next() }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_transfer1 = arrange { highStreetBank.owes(acmeCorp, 10.K, USD) }</ID>
    <ID>VariableNaming:RollOutTests.kt$RollOutTests$val contract_transfer2 = arrange { highStreetBank.owes(acmeCorp, 10.K, USD) }</ID>
    <ID>VariableNaming:ScheduledFlowIntegrationTests.kt$ScheduledFlowIntegrationTests$val N = 23</ID>
    <ID>VariableNaming:ScheduledFlowTests.kt$ScheduledFlowTests$val N = 99</ID>
    <ID>VariableNaming:SwapExample.kt$SwapExample$val VALUATION_DATE = LocalDate.of(2016, 6, 6)!!</ID>
    <ID>VariableNaming:Swaption.kt$Swaption$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>VariableNaming:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$val ALICE = TestIdentity(ALICE_NAME, 70)</ID>
    <ID>VariableNaming:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$val DUMMY_BANK_A = TestIdentity(DUMMY_BANK_A_NAME, 3)</ID>
    <ID>VariableNaming:TestCommsFlowInitiatorTest.kt$TestCommsFlowInitiatorTest$val NOTARY = TestIdentity(DUMMY_NOTARY_NAME, 12)</ID>
    <ID>VariableNaming:TransactionSerializationTests.kt$TransactionSerializationTests$val DUMMY_KEY_2 = generateKeyPair()</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val ALICE get() = alice.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val ALICE_IDENTITY get() = alice.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BIG_CORP get() = bigCorp.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BIG_CORP_IDENTITY get() = bigCorp.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOB get() = bob.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOB_IDENTITY get() = bob.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC get() = bankOfCorda.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC_IDENTITY get() = bankOfCorda.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC_KEY get() = bankOfCorda.keyPair</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val BOC_PUBKEY get() = bankOfCorda.publicKey</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CASH_NOTARY get() = cashNotary.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CASH_NOTARY_IDENTITY get() = cashNotary.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CHARLIE get() = charlie.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val CHARLIE_IDENTITY get() = charlie.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_CASH_ISSUER: PartyAndReference</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_NOTARY get() = dummyNotary.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_NOTARY_KEY get() = dummyNotary.keyPair</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val DUMMY_OBLIGATION_ISSUER: Party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP get() = megaCorp.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP_IDENTITY get() = megaCorp.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP_KEY get() = megaCorp.keyPair</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MEGA_CORP_PUBKEY get() = megaCorp.publicKey</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MINI_CORP get() = miniCorp.party</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryParties$val MINI_CORP_IDENTITY get() = miniCorp.identity</ID>
    <ID>VariableNaming:VaultQueryTests.kt$VaultQueryTestsBase$// Beware: do not use `MyContractClass::class.qualifiedName` as this returns a fully qualified name using "dot" notation for enclosed class val MYCONTRACT_ID = "net.corda.node.services.vault.VaultQueryTestsBase\$MyContractClass"</ID>
    <ID>VariableNaming:ZeroCouponBond.kt$ZeroCouponBond$val TEST_TX_TIME_1: Instant get() = Instant.parse("2017-09-02T12:00:00.00Z")</ID>
    <ID>WildcardImport:AMQPClient.kt$import io.netty.channel.*</ID>
    <ID>WildcardImport:AMQPClientSerializationScheme.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:AMQPClientSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPRemoteTypeModel.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:AMQPSerializationScheme.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:AMQPServerSerializationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTestSerialiationScheme.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTestUtils.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AMQPTestUtils.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:AMQPTypeIdentifierParser.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:AMQPTypeIdentifiers.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:ANSIProgressRendererTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:AbstractCashFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AbstractCashSelection.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:AdvancedExceptionDialog.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:AffinityExecutorTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:AliasPrivateKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:AllButBlacklisted.kt$import java.io.*</ID>
    <ID>WildcardImport:AllButBlacklisted.kt$import java.lang.invoke.*</ID>
    <ID>WildcardImport:AmountTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:AnotherDummyContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AppendOnlyPersistentMapTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:ArtemisMessagingClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:ArtemisMessagingServer.kt$import net.corda.node.internal.artemis.*</ID>
    <ID>WildcardImport:ArtemisRpcBroker.kt$import net.corda.node.internal.artemis.*</ID>
    <ID>WildcardImport:AttachmentDemoFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:AttachmentLoadingTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:AttachmentTests.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:AttachmentTrustCalculatorTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import java.net.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:AttachmentsClassLoader.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:AttachmentsClassLoaderStaticContractTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:AutoOfferFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:BCCryptoService.kt$import java.security.*</ID>
    <ID>WildcardImport:BCCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:BCCryptoServiceTests.kt$import java.security.*</ID>
    <ID>WildcardImport:BFTNotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BFTNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:BFTSmart.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BFTSmartNotaryService.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:BankOfCordaWebApi.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:BaseTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:BasicHSMKeyManagementService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:BasicHSMKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:BlobInspector.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:BlobWriter.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:BootTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import net.corda.networkbuilder.nodes.*</ID>
    <ID>WildcardImport:BootstrapperView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CarpenterExceptionTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CarpenterExceptionTests.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:Cash.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashExitFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashPaymentFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CashPaymentFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CashSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:CashTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CashTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:CashTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CashUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CashViewer.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.explorer.ui.*</ID>
    <ID>WildcardImport:CashViewer.kt$import net.corda.explorer.views.*</ID>
    <ID>WildcardImport:CashViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CertRoleTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CertificateRevocationListNodeTests.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:CertificateRevocationListNodeTests.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:CertificatesUtils.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CheckpointDumper.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:CheckpointSerializationAPI.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:ClassCarpenter.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:ClassCarpenterTestUtils.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:ClassCarpenterTestUtils.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:CloseableTab.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CommandLineCompatibilityCheckerTest.kt$import org.hamcrest.CoreMatchers.*</ID>
    <ID>WildcardImport:CommercialPaper.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommercialPaperIssueFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CommercialPaperTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommercialPaperTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CommercialPaperUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CommonSchema.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:CompatibleTransactionTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:ComposableTypePropertySerializer.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:CompositeKey.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:CompositeKeyFactory.kt$import java.security.*</ID>
    <ID>WildcardImport:CompositeKeyTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CompositeSignature.kt$import java.security.*</ID>
    <ID>WildcardImport:ConcurrencyUtilsTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:ConfigParsingTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:ConfigUtilities.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:Configuration.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:ConnectionStateMachine.kt$import org.apache.qpid.proton.amqp.messaging.*</ID>
    <ID>WildcardImport:ConnectionStateMachine.kt$import org.apache.qpid.proton.engine.*</ID>
    <ID>WildcardImport:Constants.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:ConstraintsPropagationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ConstraintsPropagationTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:ConstraintsUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractAttachmentSerializerTest.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:ContractHierarchyTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractHierarchyTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ContractUpgradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowRPCTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowTest.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeFlowTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractUpgradeTransactions.kt$import net.corda.core.transactions.ContractUpgradeWireTransaction.Component.*</ID>
    <ID>WildcardImport:ContractUpgradeUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractsDSLTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ContractsScanning.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CorDappInfoServlet.kt$import kotlinx.html.*</ID>
    <ID>WildcardImport:CorDappSerializerTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:CordaClassResolver.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:CordaClassResolver.kt$import java.nio.file.StandardOpenOption.*</ID>
    <ID>WildcardImport:CordaClassResolverTests.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:CordaCliWrapper.kt$import picocli.CommandLine.*</ID>
    <ID>WildcardImport:CordaExceptionTest.kt$import net.corda.core.contracts.TransactionVerificationException.*</ID>
    <ID>WildcardImport:CordaExceptionTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:CordaFutureImplTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:CordaInternal.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:CordaMigration.kt$import net.corda.node.services.persistence.*</ID>
    <ID>WildcardImport:CordaModule.kt$import com.fasterxml.jackson.annotation.*</ID>
    <ID>WildcardImport:CordaModule.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:CordaModule.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.core.context.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCClientTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CordaRPCOps.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CordaRPCOpsImplTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:CordaRPCOpsImplTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:CordaServiceTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CordaViewModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Cordapp.kt$import net.corda.core.cordapp.Cordapp.Info.*</ID>
    <ID>WildcardImport:CordappConstraintsTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:CordappConstraintsTests.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:CordappController.kt$import java.nio.file.StandardCopyOption.*</ID>
    <ID>WildcardImport:CordappController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CordappController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:CordappProviderImplTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:CordappScanningDriverTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CordappSmokeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CordappSmokeTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CoreFlowHandlers.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CryptoSignUtils.kt$import java.security.*</ID>
    <ID>WildcardImport:CryptoSignUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:CryptoUtilsTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:CustomCordapp.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:CustomVaultQuery.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:CustomVaultQuery.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:CustomVaultQueryTest.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:CustomVaultQueryTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:DBNetworkParametersStorage.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DBRunnerExtension.kt$import org.junit.jupiter.api.extension.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:DBTransactionStorage.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:DBTransactionStorageTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:DefaultKryoCustomizer.kt$import de.javakaffee.kryoserializers.guava.*</ID>
    <ID>WildcardImport:DefaultKryoCustomizer.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:DeleteForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:DemoBench.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DemoBenchNodeInfoFilesCopier.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DemoBenchView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:DeserializationInput.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryOfEnumsTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryOfEnumsTest.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryOfEnumsTest.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentrySimpleTypesTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentrySimpleTypesTest.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentrySimpleTypesTest.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DeserializeNeedingCarpentryTests.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:DeserializeSimpleTypesTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:DigitalSignatureWithCert.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:DistributedServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:DoRemainingWorkTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:DockerInstantiator.kt$import com.github.dockerjava.api.model.*</ID>
    <ID>WildcardImport:DriverDSLImpl.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:DummyContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyContractV2.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyContractV3.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyDealStateSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DummyFungibleContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:DummyLinearStateSchemaV1.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:DummyLinearStateSchemaV2.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:E2ETestKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:EnumEvolvabilityTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:EnumEvolvabilityTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:ErrorFlowTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:EventProcessor.kt$import org.apache.qpid.proton.engine.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactoryTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:EvolutionSerializerFactoryTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:Explorer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:FiberDeserializationCheckingInterceptor.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:FinalityFlowMigration.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FinalityFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:FinalityFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FinalityHandlerTest.kt$import net.corda.node.services.statemachine.StaffedFlowHospital.*</ID>
    <ID>WildcardImport:FinalityHandlerTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FinanceJSONSupport.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FixingFlow.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:FlowCheckpointCordapp.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowCheckpointVersionNodeStartupCheckTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowCheckpointVersionNodeStartupCheckTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowCookbook.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FlowCookbook.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowFrameworkPersistenceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowFrameworkTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowFrameworkTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowFrameworkTripartyTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:FlowLogic.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowLogicRefFactoryImpl.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowMatchers.kt$import net.corda.testing.internal.matchers.*</ID>
    <ID>WildcardImport:FlowOverrideTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowRetryTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStackSnapshotTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachine.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineImpl.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FlowStateMachineImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:FlowsDrainingModeContentionTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorial.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorial.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:FxTransactionBuildTutorialTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:GenericsTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:Gui.kt$import tornadofx.*</ID>
    <ID>WildcardImport:GuiUtilities.kt$import tornadofx.*</ID>
    <ID>WildcardImport:HTTPNetworkRegistrationService.kt$import java.net.HttpURLConnection.*</ID>
    <ID>WildcardImport:HardRestartTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:HibernateConfigurationTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import javax.persistence.criteria.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.BinaryComparisonOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:HibernateQueryCriteriaParser.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:HibernateStatistics.kt$import org.hibernate.stat.*</ID>
    <ID>WildcardImport:IOUContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IOUFlowResponder.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IRS.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IRS.kt$import net.corda.finance.contracts.*</ID>
    <ID>WildcardImport:IRSState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:IRSTests.kt$import net.corda.finance.contracts.*</ID>
    <ID>WildcardImport:IRSTests.kt$import net.corda.testing.dsl.*</ID>
    <ID>WildcardImport:IRSTradeFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:IdempotentFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:IdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:IdentityService.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:IdentityServiceToStringShortMigrationTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:IdentityServiceToStringShortMigrationTest.kt$import org.hamcrest.Matchers.*</ID>
    <ID>WildcardImport:InMemoryIdentityService.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InMemoryIdentityServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:InheritanceSchemaToClassCarpenterTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:InitialRegistrationCli.kt$import net.corda.node.internal.*</ID>
    <ID>WildcardImport:InputStreamSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:InstallFactory.kt$import tornadofx.*</ID>
    <ID>WildcardImport:InstallShellExtensionsParser.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InteractiveShellIntegrationTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:InteractiveShellIntegrationTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:InterestRatesSwapDemoAPI.kt$import org.springframework.web.bind.annotation.*</ID>
    <ID>WildcardImport:InterestSwapRestAPI.kt$import org.springframework.web.bind.annotation.*</ID>
    <ID>WildcardImport:InternalAccessTestHelpers.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:InternalMockNetwork.kt$import net.corda.testing.node.*</ID>
    <ID>WildcardImport:InternalSerializationTestHelpers.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:InternalTestUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:InternalUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:IssuerModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:JVMConfig.kt$import tornadofx.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import com.fasterxml.jackson.core.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:JacksonSupport.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:JacksonSupportTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:JacksonUtils.kt$import com.fasterxml.jackson.databind.*</ID>
    <ID>WildcardImport:JarScanningCordappLoader.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:JarScanningCordappLoader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:JarScanningCordappLoaderTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:JarSignatureCollectorTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:KeyStoreUtilities.kt$import java.security.*</ID>
    <ID>WildcardImport:KeyStoreUtilities.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:KotlinIntegrationTestingTutorial.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:Kryo.kt$import com.esotericsoftware.kryo.*</ID>
    <ID>WildcardImport:Kryo.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:KryoCheckpointSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:KryoCheckpointSerializer.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:KryoStreamsTest.kt$import java.io.*</ID>
    <ID>WildcardImport:KryoTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:KryoTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:KryoTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:KryoTests.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:KryoTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:LargeTransactionsTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:LazyMappedListTest.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:LedgerTransactionQueryTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:LedgerTransactionQueryTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:ListsSerializationTest.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:LocalSerializationRule.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:LocalSerializationRule.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LocalSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:LocalSerializerFactory.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:LocalTypeInformation.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:LocalTypeInformationBuilder.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LocalTypeModel.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:LocalTypeModelTests.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:LoginView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:LoginView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.cliutils.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.explorer.views.*</ID>
    <ID>WildcardImport:Main.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:MainView.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:MainView.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:MainView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:MappedSchemasCrossReferenceDetectionTests.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:Matchers.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:MaxTransactionSizeTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.contracts.ComponentGroupEnum.*</ID>
    <ID>WildcardImport:MerkleTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:MessageChainState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MessageState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MigrationServicesForResolution.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:MockAttachmentStorage.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:MockCryptoService.kt$import net.corda.nodeapi.internal.cryptoservice.*</ID>
    <ID>WildcardImport:MockKeyManagementService.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:MockNetworkTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:MockNodeMessagingService.kt$import net.corda.node.services.messaging.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.core.node.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.node.services.api.*</ID>
    <ID>WildcardImport:MockServices.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:MultiCurrencyAmountSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:Network.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:Network.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:Network.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NetworkBootstrapper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapper.kt$import net.corda.nodeapi.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapperRunnerTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:NetworkBootstrapperTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkBootstrapperTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkBuilder.kt$import net.corda.networkbuilder.nodes.*</ID>
    <ID>WildcardImport:NetworkIdentityModel.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NetworkMapServer.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkMapTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdater.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdater.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkMapUpdaterTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NetworkParametersReader.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkParametersReaderTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkParametersReaderTest.kt$import net.corda.nodeapi.internal.network.*</ID>
    <ID>WildcardImport:NetworkParametersTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NetworkParametersTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:NetworkRegistrationHelper.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NetworkRegistrationHelperTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import javafx.scene.control.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:NewTransaction.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentService.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:NodeAttachmentServiceTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:NodeAttachmentServiceTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeAttachmentServiceTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:NodeAttachmentTrustCalculator.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeBasedTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:NodeController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeControllerTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:NodeData.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeInfoFilesCopier.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInfoSchema.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeInfoWatcher.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeInterestRates.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NodeInterestRatesTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NodeInterestRatesTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:NodeProcess.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeRegistrationTest.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:NodeSchedulerService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeSchedulerServiceTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:NodeSchedulerServiceTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeSchedulerServiceTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NodeSchemaService.kt$import net.corda.core.schemas.*</ID>
    <ID>WildcardImport:NodeSchemaServiceTest.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.node.*</ID>
    <ID>WildcardImport:NodeStartup.kt$import net.corda.node.internal.subcommands.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import net.corda.demobench.model.*</ID>
    <ID>WildcardImport:NodeTabView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeTerminalView.kt$import tornadofx.*</ID>
    <ID>WildcardImport:NodeTest.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:NodeTestUtils.kt$import net.corda.testing.dsl.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:NodeVaultService.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.identity.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.core.node.services.vault.QueryCriteria.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import net.corda.testing.internal.vault.*</ID>
    <ID>WildcardImport:NodeVaultServiceTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:NodeVersioningTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:NodeWebServer.kt$import net.corda.webserver.servlets.*</ID>
    <ID>WildcardImport:NodeWebServer.kt$import org.eclipse.jetty.server.*</ID>
    <ID>WildcardImport:NonValidatingNotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NonValidatingNotaryServiceTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NonValidatingNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NotaryChangeTests.kt$import net.corda.testing.node.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:NotaryChangeTransactions.kt$import net.corda.core.transactions.NotaryChangeWireTransaction.Component.*</ID>
    <ID>WildcardImport:NotaryFlow.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:NotaryServiceFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:NotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:NotaryWhitelistTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:NotaryWhitelistTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:OGSwapPricingExample.kt$import com.opengamma.strata.product.swap.*</ID>
    <ID>WildcardImport:OGTrade.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObligationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObligationTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:ObligationTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:ObligationTests.kt$import net.corda.testing.dsl.*</ID>
    <ID>WildcardImport:ObligationUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ObservablesTests.kt$import net.corda.nodeapi.internal.persistence.*</ID>
    <ID>WildcardImport:ObserverNodeTransactionTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ObserverNodeTransactionTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:OnLedgerAsset.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:OracleNodeTearOffTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:P2PFlowsDrainingModeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import net.corda.nodeapi.internal.ArtemisMessagingComponent.*</ID>
    <ID>WildcardImport:P2PMessagingClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:PackageOwnershipVerificationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PartialMerkleTreeTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:PartialMerkleTreeTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PartialMerkleTreeTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:PartyAndCertificate.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.io.*</ID>
    <ID>WildcardImport:PathUtils.kt$import java.nio.file.*</ID>
    <ID>WildcardImport:PersistentIdentityMigrationNewTableTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentIdentityServiceTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentNetworkMapCacheTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:PersistentStateServiceTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:Portfolio.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PortfolioApi.kt$import javax.ws.rs.*</ID>
    <ID>WildcardImport:PortfolioState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PortfolioSwap.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:PrivacySaltTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:PrivateKeySerializationTest.kt$import net.corda.core.serialization.SerializationContext.UseCase.*</ID>
    <ID>WildcardImport:PrivateKeySerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:PrivatePropertyTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:ProfileController.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ProfileController.kt$import net.corda.demobench.model.*</ID>
    <ID>WildcardImport:ProfileController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:Properties.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:PropertyDescriptor.kt$import net.corda.serialization.internal.amqp.MethodClassifier.*</ID>
    <ID>WildcardImport:ProtonWrapperTests.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:PublicKeyHashToExternalId.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:PublicKeySerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.CollectionOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.ColumnPredicate.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.EqualityComparisonOperator.*</ID>
    <ID>WildcardImport:QueryCriteriaUtils.kt$import net.corda.core.node.services.vault.LikenessOperator.*</ID>
    <ID>WildcardImport:RPCMultipleInterfacesTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:RPCSecurityManagerImpl.kt$import org.apache.shiro.authc.*</ID>
    <ID>WildcardImport:RPCServer.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:RPCServer.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:ReceiveFinalityFlowTest.kt$import net.corda.node.services.statemachine.StaffedFlowHospital.*</ID>
    <ID>WildcardImport:ReceiveFinalityFlowTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ReceiveTransactionFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReferenceInputStateTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReferencedStatesFlowTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ReferencedStatesFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ReferencedStatesFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:RemoteSerializerFactory.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:RemoteTypeCarpenter.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:ResolveStatePointersTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ResolveTransactionsFlowTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ResolveTransactionsFlowTest.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:RigorousMockTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:RoundTripObservableSerializerTests.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:RpcClientObservableDeSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:RpcExceptionHandlingTest.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:RpcServerObservableSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:SSLHelper.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:SampleCashSchemaV2.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:ScheduledFlowIntegrationTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ScheduledFlowTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:ScheduledFlowsDrainingModeTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledFlowsDrainingModeTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ScheduledFlowsDrainingModeTest.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:ScheduledState.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ScheduledState.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Schema.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:Schema.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:SchemaFields.kt$import org.objectweb.asm.Opcodes.*</ID>
    <ID>WildcardImport:SearchField.kt$import tornadofx.*</ID>
    <ID>WildcardImport:SecureHashTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:SendTransactionFlow.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SerializationEnvironmentRule.kt$import net.corda.testing.internal.*</ID>
    <ID>WildcardImport:SerializationHelper.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:SerializationHelper.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import java.time.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.serialization.internal.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:SerializationOutputTests.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:SerializationPropertyOrdering.kt$import net.corda.serialization.internal.amqp.testutils.*</ID>
    <ID>WildcardImport:SerializationSchemaTests.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationScheme.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializationTokenTest.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializeAsTokenContextImpl.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SerializerFactoryBuilder.kt$import net.corda.serialization.internal.model.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:ServiceHub.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:ServiceHubInternal.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:ServicesForResolutionImpl.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SettingsModel.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SettingsModel.kt$import tornadofx.*</ID>
    <ID>WildcardImport:SharedContexts.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:SignatureConstraintVersioningTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:SignedTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:SimpleMQClient.kt$import org.apache.activemq.artemis.api.core.client.*</ID>
    <ID>WildcardImport:SingleThreadedStateMachineManager.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:SingleThreadedStateMachineManager.kt$import net.corda.node.services.statemachine.interceptors.*</ID>
    <ID>WildcardImport:SpringDriver.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import net.corda.core.messaging.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:StandaloneCordaRPClientTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:StartedFlowTransition.kt$import net.corda.node.services.statemachine.*</ID>
    <ID>WildcardImport:StatePointerSearchTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:StubOutForDJVM.kt$import kotlin.annotation.AnnotationTarget.*</ID>
    <ID>WildcardImport:SubFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:SwapIdentitiesFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TLSAuthenticationTests.kt$import net.corda.nodeapi.internal.crypto.*</ID>
    <ID>WildcardImport:TenorDateParameterMetadataSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TenorSerializer.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TestCommsFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TestCordappImpl.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TestDSL.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TestDSL.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TestResponseFlowInIsolation.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TestUtils.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ThrowableSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:TimedFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TimedFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:TlsDiffAlgorithmsTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TlsDiffProtocolsTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:TraderDemoTest.kt$import net.corda.testing.driver.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionBuilder.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:TransactionBuilderTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionBuilderTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TransactionDSLInterpreter.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionDataModel.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionEncumbranceTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionOrderingTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TransactionSerializationTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import java.security.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:TransactionSignatureTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:TransactionTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:TransactionTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.serialization.*</ID>
    <ID>WildcardImport:TransactionUtils.kt$import net.corda.core.transactions.*</ID>
    <ID>WildcardImport:TransactionVerifierServiceInternal.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.client.jfx.model.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.client.jfx.utils.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TransactionViewer.kt$import tornadofx.*</ID>
    <ID>WildcardImport:TutorialContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TutorialTestDSL.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TwoPartyDealFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:TwoPartyTradeFlowTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:TypeIdentifier.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:TypeIdentifierTests.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:TypeLoader.kt$import net.corda.serialization.internal.carpenter.*</ID>
    <ID>WildcardImport:TypeModellingFingerPrinter.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:TypeModellingFingerPrinter.kt$import net.corda.serialization.internal.model.TypeIdentifier.*</ID>
    <ID>WildcardImport:TypeParameterUtils.kt$import java.lang.reflect.*</ID>
    <ID>WildcardImport:UniqueDummyFungibleContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:UniqueIdentifierTest.kt$import org.junit.Assert.*</ID>
    <ID>WildcardImport:UniversalContract.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:UpdateBusinessDayFlow.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:Utils.kt$import com.typesafe.config.*</ID>
    <ID>WildcardImport:UtilsTest.kt$import org.assertj.core.api.Assertions.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.node.services.config.*</ID>
    <ID>WildcardImport:V1NodeConfigurationSpec.kt$import net.corda.node.services.config.schema.parsers.*</ID>
    <ID>WildcardImport:ValidatingNotaryServiceTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:ValidatingNotaryServiceTests.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:ValidatingNotaryServiceTests.kt$import net.corda.testing.node.internal.*</ID>
    <ID>WildcardImport:VaultFiller.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultFlowTest.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.core.node.services.vault.QueryCriteria.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultQueryExceptionsTests.kt$import org.junit.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.Vault.ConstraintInfo.Type.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.node.services.vault.QueryCriteria.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.core.utilities.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultQueryTests.kt$import net.corda.testing.internal.vault.*</ID>
    <ID>WildcardImport:VaultSchema.kt$import javax.persistence.*</ID>
    <ID>WildcardImport:VaultSchema.kt$import net.corda.core.schemas.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.Vault.RelevancyStatus.*</ID>
    <ID>WildcardImport:VaultService.kt$import net.corda.core.node.services.vault.*</ID>
    <ID>WildcardImport:VaultSoftLockManagerTest.kt$import com.nhaarman.mockito_kotlin.*</ID>
    <ID>WildcardImport:VaultSoftLockManagerTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultStateMigration.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultStateMigration.kt$import net.corda.core.serialization.internal.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultStateMigrationTest.kt$import org.junit.*</ID>
    <ID>WildcardImport:VaultUpdateTests.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:VaultWithCashTest.kt$import net.corda.finance.*</ID>
    <ID>WildcardImport:VaultWithCashTest.kt$import net.corda.testing.core.*</ID>
    <ID>WildcardImport:VaultWithCashTest.kt$import net.corda.testing.internal.vault.*</ID>
    <ID>WildcardImport:VerifyTransactionTest.kt$import net.corda.finance.contracts.asset.Cash.Commands.*</ID>
    <ID>WildcardImport:VersionedParsingExampleTest.kt$import net.corda.common.configuration.parsing.internal.*</ID>
    <ID>WildcardImport:WebServerController.kt$import tornadofx.*</ID>
    <ID>WildcardImport:WhitelistBasedTypeModelConfiguration.kt$import org.apache.qpid.proton.amqp.*</ID>
    <ID>WildcardImport:WhitelistGenerator.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.crypto.*</ID>
    <ID>WildcardImport:WireTransaction.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:WithFinality.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:WithMockNet.kt$import com.natpryce.hamkrest.*</ID>
    <ID>WildcardImport:WorkflowTransactionBuildTutorial.kt$import net.corda.core.contracts.*</ID>
    <ID>WildcardImport:WorkflowTransactionBuildTutorial.kt$import net.corda.core.flows.*</ID>
    <ID>WildcardImport:X509CRLSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:X509CertificateSerializer.kt$import net.corda.serialization.internal.amqp.*</ID>
    <ID>WildcardImport:X509EdDSAEngine.kt$import java.security.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import java.security.cert.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import net.corda.core.internal.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import org.bouncycastle.asn1.*</ID>
    <ID>WildcardImport:X509Utilities.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:X509UtilitiesTest.kt$import javax.net.ssl.*</ID>
    <ID>WildcardImport:X509UtilitiesTest.kt$import kotlin.test.*</ID>
    <ID>WildcardImport:X509UtilitiesTest.kt$import org.bouncycastle.asn1.x509.*</ID>
    <ID>WildcardImport:internalAccessTestHelpers.kt$import net.corda.core.contracts.*</ID>
  </Whitelist>
</SmellBaseline>
